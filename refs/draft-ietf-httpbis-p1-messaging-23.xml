<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt'?>
<!DOCTYPE rfc [
  <!ENTITY MAY "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MAY</bcp14>">
  <!ENTITY MUST "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST</bcp14>">
  <!ENTITY MUST-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST NOT</bcp14>">
  <!ENTITY OPTIONAL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>OPTIONAL</bcp14>">
  <!ENTITY RECOMMENDED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>RECOMMENDED</bcp14>">
  <!ENTITY REQUIRED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>REQUIRED</bcp14>">
  <!ENTITY SHALL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL</bcp14>">
  <!ENTITY SHALL-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL NOT</bcp14>">
  <!ENTITY SHOULD "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD</bcp14>">
  <!ENTITY SHOULD-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD NOT</bcp14>">
  <!ENTITY ID-VERSION "23">
  <!ENTITY ID-MONTH "July">
  <!ENTITY ID-YEAR "2013">
  <!ENTITY mdash "&#8212;">
  <!ENTITY Note "<x:h xmlns:x='http://purl.org/net/xml2rfc/ext'>Note:</x:h>">
  <!ENTITY caching-overview       "<xref target='Part6' x:rel='#caching.overview' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY cache-incomplete       "<xref target='Part6' x:rel='#response.cacheability' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY payload                "<xref target='Part2' x:rel='#payload' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY media-type            "<xref target='Part2' x:rel='#media.type' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY content-codings        "<xref target='Part2' x:rel='#content.codings' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY CONNECT                "<xref target='Part2' x:rel='#CONNECT' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY content.negotiation    "<xref target='Part2' x:rel='#content.negotiation' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY diff-mime              "<xref target='Part2' x:rel='#differences.between.http.and.mime' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY representation         "<xref target='Part2' x:rel='#representations' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY HEAD                   "<xref target='Part2' x:rel='#HEAD' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-allow           "<xref target='Part2' x:rel='#header.allow' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-cache-control   "<xref target='Part6' x:rel='#header.cache-control' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-content-encoding    "<xref target='Part2' x:rel='#header.content-encoding' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-content-location    "<xref target='Part2' x:rel='#header.content-location' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-content-range   "<xref target='Part5' x:rel='#header.content-range' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-content-type    "<xref target='Part2' x:rel='#header.content-type' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-date            "<xref target='Part2' x:rel='#header.date' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-etag            "<xref target='Part4' x:rel='#header.etag' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-expires         "<xref target='Part6' x:rel='#header.expires' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-last-modified   "<xref target='Part4' x:rel='#header.last-modified' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-mime-version    "<xref target='Part2' x:rel='#mime-version' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-pragma          "<xref target='Part6' x:rel='#header.pragma' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-proxy-authenticate  "<xref target='Part7' x:rel='#header.proxy-authenticate' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-proxy-authorization "<xref target='Part7' x:rel='#header.proxy-authorization' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-server          "<xref target='Part2' x:rel='#header.server' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY header-warning         "<xref target='Part6' x:rel='#header.warning' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY idempotent-methods     "<xref target='Part2' x:rel='#idempotent.methods' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY safe-methods           "<xref target='Part2' x:rel='#safe.methods' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY methods                "<xref target='Part2' x:rel='#methods' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY OPTIONS                "<xref target='Part2' x:rel='#OPTIONS' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY qvalue                 "<xref target='Part2' x:rel='#quality.values' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY resource               "<xref target='Part2' x:rel='#resources' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-codes           "<xref target='Part2' x:rel='#status.codes' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-1xx             "<xref target='Part2' x:rel='#status.1xx' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-203             "<xref target='Part2' x:rel='#status.203' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-3xx             "<xref target='Part2' x:rel='#status.3xx' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-304             "<xref target='Part4' x:rel='#status.304' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-4xx             "<xref target='Part2' x:rel='#status.4xx' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY status-414             "<xref target='Part2' x:rel='#status.414' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
  <!ENTITY iana-header-registry   "<xref target='Part2' x:rel='#header.field.registry' xmlns:x='http://purl.org/net/xml2rfc/ext'/>">
]>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no" ?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-references-in-index="yes" ?>
<rfc obsoletes="2145,2616" updates="2817,2818" category="std" x:maturity-level="proposed"
     ipr="pre5378Trust200902" docName="draft-ietf-httpbis-p1-messaging-&ID-VERSION;"
     xmlns:x='http://purl.org/net/xml2rfc/ext'>
<x:link rel="next" basename="draft-ietf-httpbis-p2-semantics-23"/>
<x:feedback template="mailto:ietf-http-wg@w3.org?subject={docname},%20%22{section}%22&amp;body=&lt;{ref}&gt;:"/>
<front>

  <title abbrev="HTTP/1.1 Message Syntax and Routing">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>

  <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
    <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
    <address>
      <postal>
        <street>345 Park Ave</street>
        <city>San Jose</city>
        <region>CA</region>
        <code>95110</code>
        <country>USA</country>
      </postal>
      <email>fielding@gbiv.com</email>
      <uri>http://roy.gbiv.com/</uri>
    </address>
  </author>

  <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
    <organization abbrev="greenbytes">greenbytes GmbH</organization>
    <address>
      <postal>
        <street>Hafenweg 16</street>
        <city>Muenster</city><region>NW</region><code>48155</code>
        <country>Germany</country>
      </postal>
      <email>julian.reschke@greenbytes.de</email>
      <uri>http://greenbytes.de/tech/webdav/</uri>
    </address>
  </author>

  <date month="&ID-MONTH;" year="&ID-YEAR;" day="15"/>
  <workgroup>HTTPbis Working Group</workgroup>

<abstract>
<t>
   The Hypertext Transfer Protocol (HTTP) is an application-level protocol for
   distributed, collaborative, hypertext information systems. HTTP has been in
   use by the World Wide Web global information initiative since 1990.
   This document provides an overview of HTTP architecture and its associated
   terminology, defines the "http" and "https" Uniform Resource Identifier
   (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements,
   and describes general security concerns for implementations.
</t>   
</abstract>

<note title="Editorial Note (To be removed by RFC Editor)">
  <t>
    Discussion of this draft takes place on the HTTPBIS working group
    mailing list (ietf-http-wg@w3.org), which is archived at
    <eref target="http://lists.w3.org/Archives/Public/ietf-http-wg/"/>.
  </t>
  <t>
    The current issues list is at
    <eref target="http://tools.ietf.org/wg/httpbis/trac/report/3"/> and related
    documents (including fancy diffs) can be found at
    <eref target="http://tools.ietf.org/wg/httpbis/"/>.
  </t>
  <t>
    The changes in this draft are summarized in <xref target="changes.since.22"/>.
  </t>
</note>
</front>
<middle>
<section title="Introduction" anchor="introduction">
<t>
   The Hypertext Transfer Protocol (HTTP) is an application-level
   request/response protocol that uses extensible semantics and self-descriptive
   message payloads for flexible interaction with network-based hypertext
   information systems. This document is the first in a series of documents
   that collectively form the HTTP/1.1 specification:
   <list style="empty">
    <t>RFC xxx1: Message Syntax and Routing</t>
    <t><xref target="Part2" x:fmt="none">RFC xxx2</xref>: Semantics and Content</t>
    <t><xref target="Part4" x:fmt="none">RFC xxx3</xref>: Conditional Requests</t>
    <t><xref target="Part5" x:fmt="none">RFC xxx4</xref>: Range Requests</t>
    <t><xref target="Part6" x:fmt="none">RFC xxx5</xref>: Caching</t>
    <t><xref target="Part7" x:fmt="none">RFC xxx6</xref>: Authentication</t>
   </list>
</t>
<t>
   This HTTP/1.1 specification obsoletes and moves to historic status
   <xref target="RFC2616" x:fmt="none">RFC 2616</xref>, its predecessor
   <xref target="RFC2068" x:fmt="none">RFC 2068</xref>, and
   <xref target="RFC2145" x:fmt="none">RFC 2145</xref> (on HTTP versioning).
   This specification also updates the use of CONNECT to establish a tunnel,
   previously defined in <xref target="RFC2817" x:fmt="none">RFC 2817</xref>,
   and defines the "https" URI scheme that was described informally in
   <xref target="RFC2818" x:fmt="none">RFC 2818</xref>.
</t>
<t>
   HTTP is a generic interface protocol for information systems. It is
   designed to hide the details of how a service is implemented by presenting
   a uniform interface to clients that is independent of the types of
   resources provided. Likewise, servers do not need to be aware of each
   client's purpose: an HTTP request can be considered in isolation rather
   than being associated with a specific type of client or a predetermined
   sequence of application steps. The result is a protocol that can be used
   effectively in many different contexts and for which implementations can
   evolve independently over time.
</t>
<t>
   HTTP is also designed for use as an intermediation protocol for translating
   communication to and from non-HTTP information systems.
   HTTP proxies and gateways can provide access to alternative information
   services by translating their diverse protocols into a hypertext
   format that can be viewed and manipulated by clients in the same way
   as HTTP services.
</t>
<t>
   One consequence of this flexibility is that the protocol cannot be
   defined in terms of what occurs behind the interface. Instead, we
   are limited to defining the syntax of communication, the intent
   of received communication, and the expected behavior of recipients.
   If the communication is considered in isolation, then successful
   actions ought to be reflected in corresponding changes to the
   observable interface provided by servers. However, since multiple
   clients might act in parallel and perhaps at cross-purposes, we
   cannot require that such changes be observable beyond the scope
   of a single response.
</t>
<t>
   This document describes the architectural elements that are used or
   referred to in HTTP, defines the "http" and "https" URI schemes,
   describes overall network operation and connection management,
   and defines HTTP message framing and forwarding requirements.
   Our goal is to define all of the mechanisms necessary for HTTP message
   handling that are independent of message semantics, thereby defining the
   complete set of requirements for message parsers and
   message-forwarding intermediaries.
</t>


<section title="Requirement Notation" anchor="intro.requirements">
<t>
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <xref target="RFC2119"/>.
</t>
<t>
   Conformance criteria and considerations regarding error handling
   are defined in <xref target="conformance"/>.
</t>
</section>

<section title="Syntax Notation" anchor="notation">
<iref primary="true" item="Grammar" subitem="ALPHA"/>
<iref primary="true" item="Grammar" subitem="CR"/>
<iref primary="true" item="Grammar" subitem="CRLF"/>
<iref primary="true" item="Grammar" subitem="CTL"/>
<iref primary="true" item="Grammar" subitem="DIGIT"/>
<iref primary="true" item="Grammar" subitem="DQUOTE"/>
<iref primary="true" item="Grammar" subitem="HEXDIG"/>
<iref primary="true" item="Grammar" subitem="HTAB"/>
<iref primary="true" item="Grammar" subitem="LF"/>
<iref primary="true" item="Grammar" subitem="OCTET"/>
<iref primary="true" item="Grammar" subitem="SP"/>
<iref primary="true" item="Grammar" subitem="VCHAR"/>
<t>
   This specification uses the Augmented Backus-Naur Form (ABNF) notation
   of <xref target="RFC5234"/> with the list rule extension defined in
   <xref target="abnf.extension"/>.  <xref target="collected.abnf"/> shows
   the collected ABNF with the list rule expanded.
</t>
<t anchor="core.rules">
  <x:anchor-alias value="ALPHA"/>
  <x:anchor-alias value="CTL"/>
  <x:anchor-alias value="CR"/>
  <x:anchor-alias value="CRLF"/>
  <x:anchor-alias value="DIGIT"/>
  <x:anchor-alias value="DQUOTE"/>
  <x:anchor-alias value="HEXDIG"/>
  <x:anchor-alias value="HTAB"/>
  <x:anchor-alias value="LF"/>
  <x:anchor-alias value="OCTET"/>
  <x:anchor-alias value="SP"/>
  <x:anchor-alias value="VCHAR"/>
   The following core rules are included by
   reference, as defined in <xref target="RFC5234" x:fmt="," x:sec="B.1"/>:
   ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls),
   DIGIT (decimal 0-9), DQUOTE (double quote),
   HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF (line feed),
   OCTET (any 8-bit sequence of data), SP (space), and
   VCHAR (any visible <xref target="USASCII"/> character).
</t>
<t>
   As a convention, ABNF rule names prefixed with "obs-" denote
   "obsolete" grammar rules that appear for historical reasons.
</t>
</section>
</section>

<section title="Architecture" anchor="architecture">
<t>
   HTTP was created for the World Wide Web architecture
   and has evolved over time to support the scalability needs of a worldwide
   hypertext system. Much of that architecture is reflected in the terminology
   and syntax productions used to define HTTP.
</t>

<section title="Client/Server Messaging" anchor="operation">
<iref primary="true" item="client"/>
<iref primary="true" item="server"/>
<iref primary="true" item="connection"/>
<t>
   HTTP is a stateless request/response protocol that operates by exchanging
   <x:dfn>messages</x:dfn> (<xref target="http.message"/>) across a reliable
   transport or session-layer
   "<x:dfn>connection</x:dfn>" (<xref target="connection.management"/>).
   An HTTP "<x:dfn>client</x:dfn>" is a program that establishes a connection
   to a server for the purpose of sending one or more HTTP requests.
   An HTTP "<x:dfn>server</x:dfn>" is a program that accepts connections
   in order to service HTTP requests by sending HTTP responses.
</t>
<iref primary="true" item="user agent"/>
<iref primary="true" item="origin server"/>
<iref primary="true" item="browser"/>
<iref primary="true" item="spider"/>
<iref primary="true" item="sender"/>
<iref primary="true" item="recipient"/>
<t>
   The terms client and server refer only to the roles that
   these programs perform for a particular connection.  The same program
   might act as a client on some connections and a server on others.
   We use the term "<x:dfn>user agent</x:dfn>" to refer to any of the various
   client programs that initiate a request, including (but not limited to)
   browsers, spiders (web-based robots), command-line tools, native
   applications, and mobile apps.  The term "<x:dfn>origin server</x:dfn>" is
   used to refer to the program that can originate authoritative responses to
   a request. For general requirements, we use the terms
   "<x:dfn>sender</x:dfn>" and "<x:dfn>recipient</x:dfn>" to refer to any
   component that sends or receives, respectively, a given message.
</t>
<t>
   HTTP relies upon the Uniform Resource Identifier (URI)
   standard <xref target="RFC3986"/> to indicate the target resource
   (<xref target="target-resource"/>) and relationships between resources.
   Messages are passed in a format similar to that used by Internet mail
   <xref target="RFC5322"/> and the Multipurpose Internet Mail Extensions
   (MIME) <xref target="RFC2045"/> (see &diff-mime; for the differences
   between HTTP and MIME messages).
</t>
<t>
   Most HTTP communication consists of a retrieval request (GET) for
   a representation of some resource identified by a URI.  In the
   simplest case, this might be accomplished via a single bidirectional
   connection (===) between the user agent (UA) and the origin server (O).
</t>
<figure><artwork type="drawing">
         request   &gt;
    <x:highlight>UA</x:highlight> ======================================= <x:highlight>O</x:highlight>
                                &lt;   response
</artwork></figure>
<iref primary="true" item="message"/>
<iref primary="true" item="request"/>
<iref primary="true" item="response"/>
<t>
   A client sends an HTTP request to a server in the form of a <x:dfn>request</x:dfn>
   message, beginning with a request-line that includes a method, URI, and
   protocol version (<xref target="request.line"/>),
   followed by header fields containing
   request modifiers, client information, and representation metadata
   (<xref target="header.fields"/>),
   an empty line to indicate the end of the header section, and finally
   a message body containing the payload body (if any,
   <xref target="message.body"/>).
</t>
<t>
   A server responds to a client's request by sending one or more HTTP
   <x:dfn>response</x:dfn>
   messages, each beginning with a status line that
   includes the protocol version, a success or error code, and textual
   reason phrase (<xref target="status.line"/>),
   possibly followed by header fields containing server
   information, resource metadata, and representation metadata
   (<xref target="header.fields"/>),
   an empty line to indicate the end of the header section, and finally
   a message body containing the payload body (if any,
   <xref target="message.body"/>).
</t>
<t>
   A connection might be used for multiple request/response exchanges,
   as defined in <xref target="persistent.connections"/>.
</t>
<t>
   The following example illustrates a typical message exchange for a
   GET request on the URI "http://www.example.com/hello.txt":
</t>
<figure><preamble>
client request:
</preamble><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
GET /hello.txt HTTP/1.1
User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
Host: www.example.com
Accept-Language: en, mi

</artwork></figure>
<figure><preamble>
server response:
</preamble><artwork type="message/http; msgtype=&#34;response&#34;" x:indent-with="  ">
HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache
Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
ETag: "34aa387-d-1568eb00"
Accept-Ranges: bytes
Content-Length: <x:length-of target="exbody"/>
Vary: Accept-Encoding
Content-Type: text/plain

<x:span anchor="exbody">Hello World! My payload includes a trailing CRLF.
</x:span></artwork>
</figure>
</section>

<section title="Implementation Diversity" anchor="implementation-diversity">
<t>
   When considering the design of HTTP, it is easy to fall into a trap of
   thinking that all user agents are general-purpose browsers and all origin
   servers are large public websites. That is not the case in practice.
   Common HTTP user agents include household appliances, stereos, scales,
   firmware update scripts, command-line programs, mobile apps,
   and communication devices in a multitude of shapes and sizes.  Likewise,
   common HTTP origin servers include home automation units, configurable
   networking components, office machines, autonomous robots, news feeds,
   traffic cameras, ad selectors, and video delivery platforms.
</t>
<t>
   The term "user agent" does not imply that there is a human user directly
   interacting with the software agent at the time of a request. In many
   cases, a user agent is installed or configured to run in the background
   and save its results for later inspection (or save only a subset of those
   results that might be interesting or erroneous). Spiders, for example, are
   typically given a start URI and configured to follow certain behavior while
   crawling the Web as a hypertext graph.
</t>
<t>
   The implementation diversity of HTTP means that we cannot assume the
   user agent can make interactive suggestions to a user or provide adequate
   warning for security or privacy options.  In the few cases where this
   specification requires reporting of errors to the user, it is acceptable
   for such reporting to only be observable in an error console or log file.
   Likewise, requirements that an automated action be confirmed by the user
   before proceeding might be met via advance configuration choices,
   run-time options, or simple avoidance of the unsafe action; confirmation
   does not imply any specific user interface or interruption of normal
   processing if the user has already made that choice.
</t>
</section>

<section title="Intermediaries" anchor="intermediaries">
<iref primary="true" item="intermediary"/>
<t>
   HTTP enables the use of intermediaries to satisfy requests through
   a chain of connections.  There are three common forms of HTTP
   <x:dfn>intermediary</x:dfn>: proxy, gateway, and tunnel.  In some cases,
   a single intermediary might act as an origin server, proxy, gateway,
   or tunnel, switching behavior based on the nature of each request.
</t>
<figure><artwork type="drawing">
         &gt;             &gt;             &gt;             &gt;
    <x:highlight>UA</x:highlight> =========== <x:highlight>A</x:highlight> =========== <x:highlight>B</x:highlight> =========== <x:highlight>C</x:highlight> =========== <x:highlight>O</x:highlight>
               &lt;             &lt;             &lt;             &lt;
</artwork></figure>
<t>
   The figure above shows three intermediaries (A, B, and C) between the
   user agent and origin server. A request or response message that
   travels the whole chain will pass through four separate connections.
   Some HTTP communication options
   might apply only to the connection with the nearest, non-tunnel
   neighbor, only to the end-points of the chain, or to all connections
   along the chain. Although the diagram is linear, each participant might
   be engaged in multiple, simultaneous communications. For example, B
   might be receiving requests from many clients other than A, and/or
   forwarding requests to servers other than C, at the same time that it
   is handling A's request. Likewise, later requests might be sent through a
   different path of connections, often based on dynamic configuration for
   load balancing.   
</t>
<t>
<iref primary="true" item="upstream"/><iref primary="true" item="downstream"/>
<iref primary="true" item="inbound"/><iref primary="true" item="outbound"/>
   We use the terms "<x:dfn>upstream</x:dfn>" and "<x:dfn>downstream</x:dfn>"
   to describe various requirements in relation to the directional flow of a
   message: all messages flow from upstream to downstream.
   Likewise, we use the terms inbound and outbound to refer to
   directions in relation to the request path:
   "<x:dfn>inbound</x:dfn>" means toward the origin server and
   "<x:dfn>outbound</x:dfn>" means toward the user agent.
</t>
<t><iref primary="true" item="proxy"/>
   A "<x:dfn>proxy</x:dfn>" is a message forwarding agent that is selected by the
   client, usually via local configuration rules, to receive requests
   for some type(s) of absolute URI and attempt to satisfy those
   requests via translation through the HTTP interface.  Some translations
   are minimal, such as for proxy requests for "http" URIs, whereas
   other requests might require translation to and from entirely different
   application-level protocols. Proxies are often used to group an
   organization's HTTP requests through a common intermediary for the
   sake of security, annotation services, or shared caching.
</t>
<t>
<iref primary="true" item="transforming proxy"/>
<iref primary="true" item="non-transforming proxy"/>
   An HTTP-to-HTTP proxy is called a "<x:dfn>transforming proxy</x:dfn>" if it is designed
   or configured to modify request or response messages in a semantically
   meaningful way (i.e., modifications, beyond those required by normal
   HTTP processing, that change the message in a way that would be
   significant to the original sender or potentially significant to
   downstream recipients).  For example, a transforming proxy might be
   acting as a shared annotation server (modifying responses to include
   references to a local annotation database), a malware filter, a
   format transcoder, or an intranet-to-Internet privacy filter.  Such
   transformations are presumed to be desired by the client (or client
   organization) that selected the proxy and are beyond the scope of
   this specification.  However, when a proxy is not intended to transform
   a given message, we use the term "<x:dfn>non-transforming proxy</x:dfn>" to target
   requirements that preserve HTTP message semantics. See &status-203; and
   &header-warning; for status and warning codes related to transformations.
</t>
<t><iref primary="true" item="gateway"/><iref primary="true" item="reverse proxy"/>
<iref primary="true" item="accelerator"/>
   A "<x:dfn>gateway</x:dfn>" (a.k.a., "<x:dfn>reverse proxy</x:dfn>") is an
   intermediary that acts as an origin server for the outbound connection, but
   translates received requests and forwards them inbound to another server or
   servers. Gateways are often used to encapsulate legacy or untrusted
   information services, to improve server performance through
   "<x:dfn>accelerator</x:dfn>" caching, and to enable partitioning or load
   balancing of HTTP services across multiple machines.
</t>
<t>
   All HTTP requirements applicable to an origin server
   also apply to the outbound communication of a gateway.
   A gateway communicates with inbound servers using any protocol that
   it desires, including private extensions to HTTP that are outside
   the scope of this specification.  However, an HTTP-to-HTTP gateway
   that wishes to interoperate with third-party HTTP servers ought to conform
   to user agent requirements on the gateway's inbound connection.
</t>
<t><iref primary="true" item="tunnel"/>
   A "<x:dfn>tunnel</x:dfn>" acts as a blind relay between two connections
   without changing the messages. Once active, a tunnel is not
   considered a party to the HTTP communication, though the tunnel might
   have been initiated by an HTTP request. A tunnel ceases to exist when
   both ends of the relayed connection are closed. Tunnels are used to
   extend a virtual connection through an intermediary, such as when
   Transport Layer Security (TLS, <xref target="RFC5246"/>) is used to
   establish confidential communication through a shared firewall proxy.
</t>
<t><iref primary="true" item="interception proxy"/>
<iref primary="true" item="transparent proxy"/>
<iref primary="true" item="captive portal"/>
   The above categories for intermediary only consider those acting as
   participants in the HTTP communication.  There are also intermediaries
   that can act on lower layers of the network protocol stack, filtering or
   redirecting HTTP traffic without the knowledge or permission of message
   senders. Network intermediaries often introduce security flaws or
   interoperability problems by violating HTTP semantics.  For example, an
   "<x:dfn>interception proxy</x:dfn>" <xref target="RFC3040"/> (also commonly
   known as a "<x:dfn>transparent proxy</x:dfn>" <xref target="RFC1919"/> or
   "<x:dfn>captive portal</x:dfn>")
   differs from an HTTP proxy because it is not selected by the client.
   Instead, an interception proxy filters or redirects outgoing TCP port 80
   packets (and occasionally other common port traffic).
   Interception proxies are commonly found on public network access points,
   as a means of enforcing account subscription prior to allowing use of
   non-local Internet services, and within corporate firewalls to enforce
   network usage policies.
   They are indistinguishable from a man-in-the-middle attack.
</t>
<t>
   HTTP is defined as a stateless protocol, meaning that each request message
   can be understood in isolation.  Many implementations depend on HTTP's
   stateless design in order to reuse proxied connections or dynamically
   load-balance requests across multiple servers.  Hence, servers &MUST-NOT;
   assume that two requests on the same connection are from the same user
   agent unless the connection is secured and specific to that agent.
   Some non-standard HTTP extensions (e.g., <xref target="RFC4559"/>) have
   been known to violate this requirement, resulting in security and
   interoperability problems.
</t>
</section>

<section title="Caches" anchor="caches">
<iref primary="true" item="cache"/>
<t>
   A "<x:dfn>cache</x:dfn>" is a local store of previous response messages and the
   subsystem that controls its message storage, retrieval, and deletion.
   A cache stores cacheable responses in order to reduce the response
   time and network bandwidth consumption on future, equivalent
   requests. Any client or server &MAY; employ a cache, though a cache
   cannot be used by a server while it is acting as a tunnel.
</t>
<t>
   The effect of a cache is that the request/response chain is shortened
   if one of the participants along the chain has a cached response
   applicable to that request. The following illustrates the resulting
   chain if B has a cached copy of an earlier response from O (via C)
   for a request that has not been cached by UA or A.
</t>
<figure><artwork type="drawing">
            &gt;             &gt;
       <x:highlight>UA</x:highlight> =========== <x:highlight>A</x:highlight> =========== <x:highlight>B</x:highlight> - - - - - - <x:highlight>C</x:highlight> - - - - - - <x:highlight>O</x:highlight>
                  &lt;             &lt;
</artwork></figure>
<t><iref primary="true" item="cacheable"/>
   A response is "<x:dfn>cacheable</x:dfn>" if a cache is allowed to store a copy of
   the response message for use in answering subsequent requests.
   Even when a response is cacheable, there might be additional
   constraints placed by the client or by the origin server on when
   that cached response can be used for a particular request. HTTP
   requirements for cache behavior and cacheable responses are
   defined in &caching-overview;.  
</t>
<t>
   There are a wide variety of architectures and configurations
   of caches deployed across the World Wide Web and
   inside large organizations. These include national hierarchies
   of proxy caches to save transoceanic bandwidth, collaborative systems that
   broadcast or multicast cache entries, archives of pre-fetched cache
   entries for use in off-line or high-latency environments, and so on.
</t>
</section>

<section title="Conformance and Error Handling" anchor="conformance">
<t>
   This specification targets conformance criteria according to the role of
   a participant in HTTP communication.  Hence, HTTP requirements are placed
   on senders, recipients, clients, servers, user agents, intermediaries,
   origin servers, proxies, gateways, or caches, depending on what behavior
   is being constrained by the requirement. Additional (social) requirements
   are placed on implementations, resource owners, and protocol element
   registrations when they apply beyond the scope of a single communication.
</t>
<t>
   The verb "generate" is used instead of "send" where a requirement
   differentiates between creating a protocol element and merely forwarding a
   received element downstream.
</t>
<t>
   An implementation is considered conformant if it complies with all of the
   requirements associated with the roles it partakes in HTTP.
</t>
<t>
   Conformance applies to both the syntax and semantics of HTTP protocol
   elements. A sender &MUST-NOT; generate protocol elements that convey a
   meaning that is known by that sender to be false. A sender &MUST-NOT;
   generate protocol elements that do not match the grammar defined by the
   ABNF rules for those protocol elements that are applicable to the sender's
   role. If a received protocol element is processed, the recipient &MUST; be
   able to parse any value that would match the ABNF rules for that protocol
   element, excluding only those rules not applicable to the recipient's role.
</t>
<t>
   Unless noted otherwise, a recipient &MAY; attempt to recover a usable
   protocol element from an invalid construct.  HTTP does not define
   specific error handling mechanisms except when they have a direct impact
   on security, since different applications of the protocol require
   different error handling strategies.  For example, a Web browser might
   wish to transparently recover from a response where the
   <x:ref>Location</x:ref> header field doesn't parse according to the ABNF,
   whereas a systems control client might consider any form of error recovery
   to be dangerous.
</t>
</section>

<section title="Protocol Versioning" anchor="http.version">
  <x:anchor-alias value="HTTP-version"/>
  <x:anchor-alias value="HTTP-name"/>
<t>
   HTTP uses a "&lt;major&gt;.&lt;minor&gt;" numbering scheme to indicate
   versions of the protocol. This specification defines version "1.1".
   The protocol version as a whole indicates the sender's conformance
   with the set of requirements laid out in that version's corresponding
   specification of HTTP.
</t>
<t>
   The version of an HTTP message is indicated by an HTTP-version field
   in the first line of the message. HTTP-version is case-sensitive.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="HTTP-version"/><iref primary="true" item="Grammar" subitem="HTTP-name"/>
  <x:ref>HTTP-version</x:ref>  = <x:ref>HTTP-name</x:ref> "/" <x:ref>DIGIT</x:ref> "." <x:ref>DIGIT</x:ref>
  <x:ref>HTTP-name</x:ref>     = <x:abnf-char-sequence>"HTTP"</x:abnf-char-sequence> ; "HTTP", case-sensitive 
</artwork></figure>
<t>
   The HTTP version number consists of two decimal digits separated by a "."
   (period or decimal point).  The first digit ("major version") indicates the
   HTTP messaging syntax, whereas the second digit ("minor version") indicates
   the highest minor version within that major version to which the sender is
   conformant and able to understand for future communication.  The minor
   version advertises the sender's communication capabilities even when the
   sender is only using a backwards-compatible subset of the protocol,
   thereby letting the recipient know that more advanced features can
   be used in response (by servers) or in future requests (by clients).
</t>
<t>
   When an HTTP/1.1 message is sent to an HTTP/1.0 recipient
   <xref target="RFC1945"/> or a recipient whose version is unknown,
   the HTTP/1.1 message is constructed such that it can be interpreted
   as a valid HTTP/1.0 message if all of the newer features are ignored.
   This specification places recipient-version requirements on some
   new features so that a conformant sender will only use compatible
   features until it has determined, through configuration or the
   receipt of a message, that the recipient supports HTTP/1.1.
</t>
<t>
   The interpretation of a header field does not change between minor
   versions of the same major HTTP version, though the default
   behavior of a recipient in the absence of such a field can change.
   Unless specified otherwise, header fields defined in HTTP/1.1 are
   defined for all versions of HTTP/1.x.  In particular, the <x:ref>Host</x:ref>
   and <x:ref>Connection</x:ref> header fields ought to be implemented by all
   HTTP/1.x implementations whether or not they advertise conformance with
   HTTP/1.1.
</t>
<t>
   New header fields can be defined such that, when they are
   understood by a recipient, they might override or enhance the
   interpretation of previously defined header fields.  When an
   implementation receives an unrecognized header field, the recipient
   &MUST; ignore that header field for local processing regardless of
   the message's HTTP version.  An unrecognized header field received
   by a proxy &MUST; be forwarded downstream unless the header field's
   field-name is listed in the message's <x:ref>Connection</x:ref> header field
   (see <xref target="header.connection"/>).
   These requirements allow HTTP's functionality to be enhanced without
   requiring prior update of deployed intermediaries.
</t>
<t>
   Intermediaries that process HTTP messages (i.e., all intermediaries
   other than those acting as tunnels) &MUST; send their own HTTP-version
   in forwarded messages.  In other words, they &MUST-NOT; blindly
   forward the first line of an HTTP message without ensuring that the
   protocol version in that message matches a version to which that
   intermediary is conformant for both the receiving and
   sending of messages.  Forwarding an HTTP message without rewriting
   the HTTP-version might result in communication errors when downstream
   recipients use the message sender's version to determine what features
   are safe to use for later communication with that sender.
</t>
<t>
   A client &SHOULD; send a request version equal to the highest
   version to which the client is conformant and
   whose major version is no higher than the highest version supported
   by the server, if this is known.  A client &MUST-NOT; send a
   version to which it is not conformant.
</t>
<t>
   A client &MAY; send a lower request version if it is known that
   the server incorrectly implements the HTTP specification, but only
   after the client has attempted at least one normal request and determined
   from the response status or header fields (e.g., <x:ref>Server</x:ref>) that
   the server improperly handles higher request versions.
</t>
<t>
   A server &SHOULD; send a response version equal to the highest
   version to which the server is conformant and
   whose major version is less than or equal to the one received in the
   request.  A server &MUST-NOT; send a version to which it is not
   conformant.  A server &MAY; send a <x:ref>505 (HTTP Version Not
   Supported)</x:ref> response if it cannot send a response using the
   major version used in the client's request.
</t>
<t>
   A server &MAY; send an HTTP/1.0 response to a request
   if it is known or suspected that the client incorrectly implements the
   HTTP specification and is incapable of correctly processing later
   version responses, such as when a client fails to parse the version
   number correctly or when an intermediary is known to blindly forward
   the HTTP-version even when it doesn't conform to the given minor
   version of the protocol. Such protocol downgrades &SHOULD-NOT; be
   performed unless triggered by specific client attributes, such as when
   one or more of the request header fields (e.g., <x:ref>User-Agent</x:ref>)
   uniquely match the values sent by a client known to be in error.
</t>
<t>
   The intention of HTTP's versioning design is that the major number
   will only be incremented if an incompatible message syntax is
   introduced, and that the minor number will only be incremented when
   changes made to the protocol have the effect of adding to the message
   semantics or implying additional capabilities of the sender.  However,
   the minor version was not incremented for the changes introduced between
   <xref target="RFC2068"/> and <xref target="RFC2616"/>, and this revision
   has specifically avoided any such changes to the protocol.
</t>
<t>
   When an HTTP message is received with a major version number that the
   recipient implements, but a higher minor version number than what the
   recipient implements, the recipient &SHOULD; process the message as if it
   were in the highest minor version within that major version to which the
   recipient is conformant. A recipient can assume that a message with a
   higher minor version, when sent to a recipient that has not yet indicated
   support for that higher version, is sufficiently backwards-compatible to be
   safely processed by any implementation of the same major version.
</t>
</section>

<section title="Uniform Resource Identifiers" anchor="uri">
<iref primary="true" item="resource"/>
<t>
   Uniform Resource Identifiers (URIs) <xref target="RFC3986"/> are used
   throughout HTTP as the means for identifying resources (&resource;).
   URI references are used to target requests, indicate redirects, and define
   relationships.
</t>
  <x:anchor-alias value="URI-reference"/>
  <x:anchor-alias value="absolute-URI"/>
  <x:anchor-alias value="relative-part"/>
  <x:anchor-alias value="authority"/>
  <x:anchor-alias value="uri-host"/>
  <x:anchor-alias value="port"/>
  <x:anchor-alias value="path-abempty"/>
  <x:anchor-alias value="segment"/>
  <x:anchor-alias value="query"/>
  <x:anchor-alias value="fragment"/>
  <x:anchor-alias value="absolute-path"/>
  <x:anchor-alias value="partial-URI"/>
<t>
   This specification adopts the definitions of "URI-reference",
   "absolute-URI", "relative-part", "authority", "port", "host",
   "path-abempty", "segment", "query", and "fragment" from the
   URI generic syntax.
   In addition, we define an "absolute-path" rule (that differs from 
   RFC 3986's "path-absolute" in that it allows a leading "//")
   and a "partial-URI" rule for protocol elements
   that allow a relative URI but not a fragment.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="URI-reference"><!--exported production--></iref><iref primary="true" item="Grammar" subitem="absolute-URI"/><iref primary="true" item="Grammar" subitem="authority"/><iref primary="true" item="Grammar" subitem="absolute-path"/><iref primary="true" item="Grammar" subitem="port"/><iref primary="true" item="Grammar" subitem="query"/><iref primary="true" item="Grammar" subitem="fragment"/><iref primary="true" item="Grammar" subitem="segment"/><iref primary="true" item="Grammar" subitem="uri-host"/><iref primary="true" item="Grammar" subitem="partial-URI"><!--exported production--></iref>
  <x:ref>URI-reference</x:ref> = &lt;URI-reference, defined in <xref target="RFC3986" x:fmt="," x:sec="4.1"/>&gt;
  <x:ref>absolute-URI</x:ref>  = &lt;absolute-URI, defined in <xref target="RFC3986" x:fmt="," x:sec="4.3"/>&gt;
  <x:ref>relative-part</x:ref> = &lt;relative-part, defined in <xref target="RFC3986" x:fmt="," x:sec="4.2"/>&gt;
  <x:ref>authority</x:ref>     = &lt;authority, defined in <xref target="RFC3986" x:fmt="," x:sec="3.2"/>&gt;
  <x:ref>uri-host</x:ref>      = &lt;host, defined in <xref target="RFC3986" x:fmt="," x:sec="3.2.2"/>&gt;
  <x:ref>port</x:ref>          = &lt;port, defined in <xref target="RFC3986" x:fmt="," x:sec="3.2.3"/>&gt;
  <x:ref>path-abempty</x:ref>  = &lt;path-abempty, defined in <xref target="RFC3986" x:fmt="," x:sec="3.3"/>&gt;
  <x:ref>segment</x:ref>       = &lt;segment, defined in <xref target="RFC3986" x:fmt="," x:sec="3.3"/>&gt;
  <x:ref>query</x:ref>         = &lt;query, defined in <xref target="RFC3986" x:fmt="," x:sec="3.4"/>&gt;
  <x:ref>fragment</x:ref>      = &lt;fragment, defined in <xref target="RFC3986" x:fmt="," x:sec="3.5"/>&gt;
  
  <x:ref>absolute-path</x:ref> = 1*( "/" segment )
  <x:ref>partial-URI</x:ref>   = relative-part [ "?" query ]
</artwork></figure>
<t>
   Each protocol element in HTTP that allows a URI reference will indicate
   in its ABNF production whether the element allows any form of reference
   (URI-reference), only a URI in absolute form (absolute-URI), only the
   path and optional query components, or some combination of the above.
   Unless otherwise indicated, URI references are parsed
   relative to the effective request URI
   (<xref target="effective.request.uri"/>).
</t>

<section title="http URI scheme" anchor="http.uri">
  <x:anchor-alias value="http-URI"/>
  <iref item="http URI scheme" primary="true"/>
  <iref item="URI scheme" subitem="http" primary="true"/>
<t>
   The "http" URI scheme is hereby defined for the purpose of minting
   identifiers according to their association with the hierarchical
   namespace governed by a potential HTTP origin server listening for
   TCP (<xref target="RFC0793"/>) connections on a given port.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="http-URI"><!--terminal production--></iref>
  <x:ref>http-URI</x:ref> = "http:" "//" <x:ref>authority</x:ref> <x:ref>path-abempty</x:ref> [ "?" <x:ref>query</x:ref> ]
             [ "#" <x:ref>fragment</x:ref> ]
</artwork></figure>
<t>
   The HTTP origin server is identified by the generic syntax's 
   <x:ref>authority</x:ref> component, which includes a host identifier
   and optional TCP port (<xref target="RFC3986" x:fmt="," x:sec="3.2.2"/>).
   The remainder of the URI, consisting of both the hierarchical path
   component and optional query component, serves as an identifier for
   a potential resource within that origin server's name space.
</t>
<t>
   If the host identifier is provided as an IP address,
   then the origin server is any listener on the indicated TCP port at
   that IP address. If host is a registered name, then that name is
   considered an indirect identifier and the recipient might use a name
   resolution service, such as DNS, to find the address of a listener
   for that host.
   The host &MUST-NOT; be empty; if an "http" URI is received with an
   empty host, then it &MUST; be rejected as invalid. 
   If the port subcomponent is empty or not given, then TCP port 80 is
   assumed (the default reserved port for WWW services).
</t>
<t>
   Regardless of the form of host identifier, access to that host is not
   implied by the mere presence of its name or address. The host might or might
   not exist and, even when it does exist, might or might not be running an
   HTTP server or listening to the indicated port. The "http" URI scheme
   makes use of the delegated nature of Internet names and addresses to
   establish a naming authority (whatever entity has the ability to place
   an HTTP server at that Internet name or address) and allows that
   authority to determine which names are valid and how they might be used.
</t>
<t>
   When an "http" URI is used within a context that calls for access to the
   indicated resource, a client &MAY; attempt access by resolving
   the host to an IP address, establishing a TCP connection to that address
   on the indicated port, and sending an HTTP request message
   (<xref target="http.message"/>) containing the URI's identifying data
   (<xref target="message.routing"/>) to the server.
   If the server responds to that request with a non-interim HTTP response
   message, as described in &status-codes;, then that response
   is considered an authoritative answer to the client's request.
</t>
<t>
   Although HTTP is independent of the transport protocol, the "http"
   scheme is specific to TCP-based services because the name delegation
   process depends on TCP for establishing authority.
   An HTTP service based on some other underlying connection protocol
   would presumably be identified using a different URI scheme, just as
   the "https" scheme (below) is used for resources that require an
   end-to-end secured connection. Other protocols might also be used to
   provide access to "http" identified resources &mdash; it is only the
   authoritative interface that is specific to TCP.
</t>
<t>
   The URI generic syntax for authority also includes a deprecated
   userinfo subcomponent (<xref target="RFC3986" x:fmt="," x:sec="3.2.1"/>)
   for including user authentication information in the URI.  Some
   implementations make use of the userinfo component for internal
   configuration of authentication information, such as within command
   invocation options, configuration files, or bookmark lists, even
   though such usage might expose a user identifier or password.
   Senders &MUST; exclude the userinfo subcomponent (and its "@"
   delimiter) when an "http" URI is transmitted within a message as a
   request target or header field value.
   Recipients of an "http" URI reference &SHOULD; parse for userinfo and
   treat its presence as an error, since it is likely being used to obscure
   the authority for the sake of phishing attacks.
</t>
</section>

<section title="https URI scheme" anchor="https.uri">
   <x:anchor-alias value="https-URI"/>
   <iref item="https URI scheme"/>
   <iref item="URI scheme" subitem="https"/>
<t>
   The "https" URI scheme is hereby defined for the purpose of minting
   identifiers according to their association with the hierarchical
   namespace governed by a potential HTTP origin server listening to a
   given TCP port for TLS-secured connections
   (<xref target="RFC0793"/>, <xref target="RFC5246"/>).
</t>
<t>
   All of the requirements listed above for the "http" scheme are also
   requirements for the "https" scheme, except that a default TCP port
   of 443 is assumed if the port subcomponent is empty or not given,
   and the TCP connection &MUST; be secured, end-to-end, through the
   use of strong encryption prior to sending the first HTTP request.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="https-URI"><!--terminal production--></iref>
  <x:ref>https-URI</x:ref> = "https:" "//" <x:ref>authority</x:ref> <x:ref>path-abempty</x:ref> [ "?" <x:ref>query</x:ref> ]
              [ "#" <x:ref>fragment</x:ref> ]
</artwork></figure>
<t>
   Note that the "https" URI scheme depends on both TLS and TCP for
   establishing authority.
   Resources made available via the "https" scheme have no shared
   identity with the "http" scheme even if their resource identifiers
   indicate the same authority (the same host listening to the same
   TCP port).  They are distinct name spaces and are considered to be
   distinct origin servers.  However, an extension to HTTP that is
   defined to apply to entire host domains, such as the Cookie protocol 
   <xref target="RFC6265"/>, can allow information
   set by one service to impact communication with other services
   within a matching group of host domains.
</t>
<t>
   The process for authoritative access to an "https" identified
   resource is defined in <xref target="RFC2818"/>.
</t>
</section>

<section title="http and https URI Normalization and Comparison" anchor="uri.comparison">
<t>
   Since the "http" and "https" schemes conform to the URI generic syntax,
   such URIs are normalized and compared according to the algorithm defined
   in <xref target="RFC3986" x:fmt="," x:sec="6"/>, using the defaults
   described above for each scheme.
</t>
<t>
   If the port is equal to the default port for a scheme, the normal form is
   to omit the port subcomponent. When not being used in absolute form as the
   request target of an OPTIONS request, an empty path component is equivalent
   to an absolute path of "/", so the normal form is to provide a path of "/"
   instead. The scheme and host are case-insensitive and normally provided in
   lowercase; all other components are compared in a case-sensitive manner.
   Characters other than those in the "reserved" set are equivalent to their
   percent-encoded octets (see <xref target="RFC3986" x:fmt=","
   x:sec="2.1"/>): the normal form is to not encode them.
</t>
<t>
   For example, the following three URIs are equivalent:
</t>
<figure><artwork type="example">
   http://example.com:80/~smith/home.html
   http://EXAMPLE.com/%7Esmith/home.html
   http://EXAMPLE.com:/%7esmith/home.html
</artwork></figure>
</section>
</section>
</section>

<section title="Message Format" anchor="http.message">
<x:anchor-alias value="generic-message"/>
<x:anchor-alias value="message.types"/>
<x:anchor-alias value="HTTP-message"/>
<x:anchor-alias value="start-line"/>
<iref item="header section"/>
<iref item="headers"/>
<iref item="header field"/>
<t>
   All HTTP/1.1 messages consist of a start-line followed by a sequence of
   octets in a format similar to the Internet Message Format
   <xref target="RFC5322"/>: zero or more header fields (collectively
   referred to as the "headers" or the "header section"), an empty line
   indicating the end of the header section, and an optional message body.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="HTTP-message"><!--terminal production--></iref>
  <x:ref>HTTP-message</x:ref>   = <x:ref>start-line</x:ref>
                   *( <x:ref>header-field</x:ref> <x:ref>CRLF</x:ref> )
                   <x:ref>CRLF</x:ref>
                   [ <x:ref>message-body</x:ref> ]
</artwork></figure>
<t>
   The normal procedure for parsing an HTTP message is to read the
   start-line into a structure, read each header field into a hash
   table by field name until the empty line, and then use the parsed
   data to determine if a message body is expected.  If a message body
   has been indicated, then it is read as a stream until an amount
   of octets equal to the message body length is read or the connection
   is closed.
</t>
<t>
   Recipients &MUST; parse an HTTP message as a sequence of octets in an
   encoding that is a superset of US-ASCII <xref target="USASCII"/>.
   Parsing an HTTP message as a stream of Unicode characters, without regard
   for the specific encoding, creates security vulnerabilities due to the
   varying ways that string processing libraries handle invalid multibyte
   character sequences that contain the octet LF (%x0A).  String-based
   parsers can only be safely used within protocol elements after the element
   has been extracted from the message, such as within a header field-value
   after message parsing has delineated the individual fields.
</t>
<t>
   An HTTP message can be parsed as a stream for incremental processing or
   forwarding downstream.  However, recipients cannot rely on incremental
   delivery of partial messages, since some implementations will buffer or
   delay message forwarding for the sake of network efficiency, security
   checks, or payload transformations.
</t>
<t>
   A sender &MUST-NOT; send whitespace between the start-line and
   the first header field.
   A recipient that receives whitespace between the start-line and
   the first header field &MUST; either reject the message as invalid or
   consume each whitespace-preceded line without further processing of it
   (i.e., ignore the entire line, along with any subsequent lines preceded
   by whitespace, until a properly formed header field is received or the
   header block is terminated).
</t>
<t>
   The presence of such whitespace in a request
   might be an attempt to trick a server into ignoring that field or
   processing the line after it as a new request, either of which might
   result in a security vulnerability if other implementations within
   the request chain interpret the same message differently.
   Likewise, the presence of such whitespace in a response might be
   ignored by some clients or cause others to cease parsing.
</t>

<section title="Start Line" anchor="start.line">
  <x:anchor-alias value="Start-Line"/>
<t>
   An HTTP message can either be a request from client to server or a
   response from server to client.  Syntactically, the two types of message
   differ only in the start-line, which is either a request-line (for requests)
   or a status-line (for responses), and in the algorithm for determining
   the length of the message body (<xref target="message.body"/>).
</t>
<t>
   In theory, a client could receive requests and a server could receive
   responses, distinguishing them by their different start-line formats,
   but in practice servers are implemented to only expect a request
   (a response is interpreted as an unknown or invalid request method)
   and clients are implemented to only expect a response.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="start-line"/>
  <x:ref>start-line</x:ref>     = <x:ref>request-line</x:ref> / <x:ref>status-line</x:ref>
</artwork></figure>

<section title="Request Line" anchor="request.line">
  <x:anchor-alias value="Request"/>
  <x:anchor-alias value="request-line"/>
<t>
   A request-line begins with a method token, followed by a single
   space (SP), the request-target, another single space (SP), the
   protocol version, and ending with CRLF.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="request-line"/>
  <x:ref>request-line</x:ref>   = <x:ref>method</x:ref> <x:ref>SP</x:ref> <x:ref>request-target</x:ref> <x:ref>SP</x:ref> <x:ref>HTTP-version</x:ref> <x:ref>CRLF</x:ref>
</artwork></figure>
<iref primary="true" item="method"/>
<t anchor="method">
   The method token indicates the request method to be performed on the
   target resource. The request method is case-sensitive.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="method"/>
  <x:ref>method</x:ref>         = <x:ref>token</x:ref>
</artwork></figure>
<t>
   The methods defined by this specification can be found in
   &methods;, along with information regarding the HTTP method registry
   and considerations for defining new methods.
</t>
<iref item="request-target"/>
<t>
   The request-target identifies the target resource upon which to apply
   the request, as defined in <xref target="request-target"/>.
</t>
<t>
   Recipients typically parse the request-line into its component parts by
   splitting on whitespace (see <xref target="message.robustness"/>), since
   no whitespace is allowed in the three components.
   Unfortunately, some user agents fail to properly encode or exclude
   whitespace found in hypertext references, resulting in those disallowed
   characters being sent in a request-target.
</t>
<t>
   Recipients of an invalid request-line &SHOULD; respond with either a
   <x:ref>400 (Bad Request)</x:ref> error or a <x:ref>301 (Moved Permanently)</x:ref>
   redirect with the request-target properly encoded.  Recipients &SHOULD-NOT;
   attempt to autocorrect and then process the request without a redirect,
   since the invalid request-line might be deliberately crafted to bypass
   security filters along the request chain.
</t>
<t>
   HTTP does not place a pre-defined limit on the length of a request-line.
   A server that receives a method longer than any that it implements
   &SHOULD; respond with a <x:ref>501 (Not Implemented)</x:ref> status code.
   A server &MUST; be prepared to receive URIs of unbounded length and
   respond with the <x:ref>414 (URI Too Long)</x:ref> status code if the received
   request-target would be longer than the server wishes to handle
   (see &status-414;).
</t>
<t>
   Various ad-hoc limitations on request-line length are found in practice.
   It is &RECOMMENDED; that all HTTP senders and recipients support, at a
   minimum, request-line lengths of 8000 octets.
</t>
</section>

<section title="Status Line" anchor="status.line">
  <x:anchor-alias value="response"/>
  <x:anchor-alias value="status-line"/>
  <x:anchor-alias value="status-code"/>
  <x:anchor-alias value="reason-phrase"/>
<t>
   The first line of a response message is the status-line, consisting
   of the protocol version, a space (SP), the status code, another space,
   a possibly-empty textual phrase describing the status code, and
   ending with CRLF.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="status-line"/>
  <x:ref>status-line</x:ref> = <x:ref>HTTP-version</x:ref> <x:ref>SP</x:ref> <x:ref>status-code</x:ref> <x:ref>SP</x:ref> <x:ref>reason-phrase</x:ref> <x:ref>CRLF</x:ref>
</artwork></figure>
<t>
   The status-code element is a 3-digit integer code describing the
   result of the server's attempt to understand and satisfy the client's
   corresponding request. The rest of the response message is to be
   interpreted in light of the semantics defined for that status code.
   See &status-codes; for information about the semantics of status codes,
   including the classes of status code (indicated by the first digit),
   the status codes defined by this specification, considerations for the
   definition of new status codes, and the IANA registry.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="status-code"/>
  <x:ref>status-code</x:ref>    = 3<x:ref>DIGIT</x:ref>
</artwork></figure>
<t>   
   The reason-phrase element exists for the sole purpose of providing a
   textual description associated with the numeric status code, mostly
   out of deference to earlier Internet application protocols that were more
   frequently used with interactive text clients. A client &SHOULD; ignore
   the reason-phrase content.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="reason-phrase"/>
  <x:ref>reason-phrase</x:ref>  = *( <x:ref>HTAB</x:ref> / <x:ref>SP</x:ref> / <x:ref>VCHAR</x:ref> / <x:ref>obs-text</x:ref> )
</artwork></figure>
</section>
</section>

<section title="Header Fields" anchor="header.fields">
  <x:anchor-alias value="header-field"/>
  <x:anchor-alias value="field-content"/>
  <x:anchor-alias value="field-name"/>
  <x:anchor-alias value="field-value"/>
  <x:anchor-alias value="obs-fold"/>
<t>
   Each HTTP header field consists of a case-insensitive field name
   followed by a colon (":"), optional leading whitespace, the field value,
   and optional trailing whitespace.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="header-field"/><iref primary="true" item="Grammar" subitem="field-name"/><iref primary="true" item="Grammar" subitem="field-value"/><iref primary="true" item="Grammar" subitem="field-content"/><iref primary="true" item="Grammar" subitem="obs-fold"/>
  <x:ref>header-field</x:ref>   = <x:ref>field-name</x:ref> ":" <x:ref>OWS</x:ref> <x:ref>field-value</x:ref> <x:ref>OWS</x:ref>
  <x:ref>field-name</x:ref>     = <x:ref>token</x:ref>
  <x:ref>field-value</x:ref>    = *( <x:ref>field-content</x:ref> / <x:ref>obs-fold</x:ref> )
  <x:ref>field-content</x:ref>  = *( <x:ref>HTAB</x:ref> / <x:ref>SP</x:ref> / <x:ref>VCHAR</x:ref> / <x:ref>obs-text</x:ref> )
  <x:ref>obs-fold</x:ref>       = <x:ref>CRLF</x:ref> ( <x:ref>SP</x:ref> / <x:ref>HTAB</x:ref> )
                 ; obsolete line folding
                 ; see <xref target="field.parsing"/>
</artwork></figure>
<t>
   The field-name token labels the corresponding field-value as having the
   semantics defined by that header field.  For example, the <x:ref>Date</x:ref>
   header field is defined in &header-date; as containing the origination
   timestamp for the message in which it appears.
</t>

<section title="Field Extensibility" anchor="field.extensibility">
<t>
   HTTP header fields are fully extensible: there is no limit on the
   introduction of new field names, each presumably defining new semantics,
   nor on the number of header fields used in a given message.  Existing
   fields are defined in each part of this specification and in many other
   specifications outside the core standard.
   New header fields can be introduced without changing the protocol version
   if their defined semantics allow them to be safely ignored by recipients
   that do not recognize them.
</t>
<t>
   New HTTP header fields ought to be registered with IANA in the
   Message Header Field Registry, as described in &iana-header-registry;.
   A proxy &MUST; forward unrecognized header fields unless the
   field-name is listed in the <x:ref>Connection</x:ref> header field
   (<xref target="header.connection"/>) or the proxy is specifically
   configured to block, or otherwise transform, such fields.
   Other recipients &SHOULD; ignore unrecognized header fields.
</t>
</section>

<section title="Field Order" anchor="field.order">
<t>
   The order in which header fields with differing field names are
   received is not significant. However, it is "good practice" to send
   header fields that contain control data first, such as <x:ref>Host</x:ref>
   on requests and <x:ref>Date</x:ref> on responses, so that implementations
   can decide when not to handle a message as early as possible.  A server
   &MUST; wait until the entire header section is received before interpreting
   a request message, since later header fields might include conditionals,
   authentication credentials, or deliberately misleading duplicate
   header fields that would impact request processing.
</t>
<t>
   A sender &MUST-NOT; generate multiple header fields with the same field
   name in a message unless either the entire field value for that
   header field is defined as a comma-separated list [i.e., #(values)]
   or the header field is a well-known exception (as noted below).
</t>
<t>
   Multiple header fields with the same field name can be combined into
   one "field-name: field-value" pair, without changing the semantics of the
   message, by appending each subsequent field value to the combined
   field value in order, separated by a comma. The order in which
   header fields with the same field name are received is therefore
   significant to the interpretation of the combined field value;
   a proxy &MUST-NOT; change the order of these field values when
   forwarding a message.
</t>
<x:note>
  <t>
   &Note; In practice, the "Set-Cookie" header field (<xref target="RFC6265"/>)
   often appears multiple times in a response message and does not use the
   list syntax, violating the above requirements on multiple header fields
   with the same name. Since it cannot be combined into a single field-value,
   recipients ought to handle "Set-Cookie" as a special case while processing
   header fields. (See Appendix A.2.3 of <xref target="Kri2001"/> for details.)
  </t>
</x:note>
</section>

<section title="Whitespace" anchor="whitespace">
<t anchor="rule.LWS">
   This specification uses three rules to denote the use of linear
   whitespace: OWS (optional whitespace), RWS (required whitespace), and
   BWS ("bad" whitespace). 
</t>
<t anchor="rule.OWS">
   The OWS rule is used where zero or more linear whitespace octets might
   appear. For protocol elements where optional whitespace is preferred to
   improve readability, a sender &SHOULD; generate the optional whitespace
   as a single SP; otherwise, a sender &SHOULD-NOT; generate optional
   whitespace except as needed to white-out invalid or unwanted protocol
   elements during in-place message filtering.
</t>
<t anchor="rule.RWS">
   The RWS rule is used when at least one linear whitespace octet is required
   to separate field tokens. A sender &SHOULD; generate RWS as a single SP.
</t>
<t anchor="rule.BWS">
   The BWS rule is used where the grammar allows optional whitespace only for
   historical reasons. A sender &MUST-NOT; generate BWS in messages.
   A recipient &MUST; parse for such bad whitespace and remove it before
   interpreting the protocol element.
</t>
<t anchor="rule.whitespace">
  <x:anchor-alias value="BWS"/>
  <x:anchor-alias value="OWS"/>
  <x:anchor-alias value="RWS"/>
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="OWS"/><iref primary="true" item="Grammar" subitem="RWS"/><iref primary="true" item="Grammar" subitem="BWS"/>
  <x:ref>OWS</x:ref>            = *( <x:ref>SP</x:ref> / <x:ref>HTAB</x:ref> )
                 ; optional whitespace
  <x:ref>RWS</x:ref>            = 1*( <x:ref>SP</x:ref> / <x:ref>HTAB</x:ref> )
                 ; required whitespace
  <x:ref>BWS</x:ref>            = <x:ref>OWS</x:ref>
                 ; "bad" whitespace
</artwork></figure>
</section>

<section title="Field Parsing" anchor="field.parsing">
<t>
   No whitespace is allowed between the header field-name and colon.
   In the past, differences in the handling of such whitespace have led to
   security vulnerabilities in request routing and response handling.
   A server &MUST; reject any received request message that contains
   whitespace between a header field-name and colon with a response code of
   <x:ref>400 (Bad Request)</x:ref>. A proxy &MUST; remove any such whitespace
   from a response message before forwarding the message downstream.
</t>
<t>
   A field value is preceded by optional whitespace (OWS); a single SP is
   preferred. The field value does not include any leading or trailing white
   space: OWS occurring before the first non-whitespace octet of the field
   value or after the last non-whitespace octet of the field value ought to be
   excluded by parsers when extracting the field value from a header field.
</t>
<t>
   A recipient of field-content containing multiple sequential octets of
   optional (OWS) or required (RWS) whitespace &SHOULD; either replace the
   sequence with a single SP or transform any non-SP octets in the sequence to
   SP octets before interpreting the field value or forwarding the message
   downstream.
</t>
<t>
   Historically, HTTP header field values could be extended over multiple
   lines by preceding each extra line with at least one space or horizontal
   tab (obs-fold). This specification deprecates such line folding except
   within the message/http media type
   (<xref target="internet.media.type.message.http"/>).
   Senders &MUST-NOT; generate messages that include line folding
   (i.e., that contain any field-value that contains a match to the
   <x:ref>obs-fold</x:ref> rule) unless the message is intended for packaging
   within the message/http media type.
</t>
<t>
   A server that receives an <x:ref>obs-fold</x:ref> in a request message that
   is not within a message/http container &MUST; either reject the message by
   sending a <x:ref>400 (Bad Request)</x:ref>, preferably with a
   representation explaining that obsolete line folding is unacceptable, or
   replace each received <x:ref>obs-fold</x:ref> with one or more
   <x:ref>SP</x:ref> octets prior to interpreting the field value or
   forwarding the message downstream.
</t>
<t>
   A proxy or gateway that receives an <x:ref>obs-fold</x:ref> in a response
   message that is not within a message/http container &MUST; either discard
   the message and replace it with a <x:ref>502 (Bad Gateway)</x:ref>
   response, preferably with a representation explaining that unacceptable
   line folding was received, or replace each received <x:ref>obs-fold</x:ref>
   with one or more <x:ref>SP</x:ref> octets prior to interpreting the field
   value or forwarding the message downstream.
</t>
<t>
   A user agent that receives an <x:ref>obs-fold</x:ref> in a response message
   that is not within a message/http container &MUST; replace each received
   <x:ref>obs-fold</x:ref> with one or more <x:ref>SP</x:ref> octets prior to
   interpreting the field value.
</t>
<t>
   Historically, HTTP has allowed field content with text in the ISO-8859-1
   <xref target="ISO-8859-1"/> charset, supporting other charsets only
   through use of <xref target="RFC2047"/> encoding.
   In practice, most HTTP header field values use only a subset of the
   US-ASCII charset <xref target="USASCII"/>. Newly defined
   header fields &SHOULD; limit their field values to US-ASCII octets.
   Recipients &SHOULD; treat other octets in field content (obs-text) as
   opaque data.
</t>
</section>

<section title="Field Limits" anchor="field.limits">
<t>
   HTTP does not place a pre-defined limit on the length of each header field
   or on the length of the header block as a whole.  Various ad-hoc
   limitations on individual header field length are found in practice,
   often depending on the specific field semantics.
</t>
<t>
   A server &MUST; be prepared to receive request header fields of unbounded
   length and respond with an appropriate <x:ref>4xx (Client Error)</x:ref>
   status code if the received header field(s) are larger than the server
   wishes to process.
</t>
<t>
   A client &MUST; be prepared to receive response header fields of unbounded
   length. A client &MAY; discard or truncate received header fields that are
   larger than the client wishes to process if the field semantics are such
   that the dropped value(s) can be safely ignored without changing the
   response semantics.
</t>
</section>

<section title="Field value components" anchor="field.components">
<t anchor="rule.token.separators">
  <x:anchor-alias value="tchar"/>
  <x:anchor-alias value="token"/>
  <x:anchor-alias value="special"/>
  <x:anchor-alias value="word"/>
   Many HTTP header field values consist of words (token or quoted-string)
   separated by whitespace or special characters. These special characters
   &MUST; be in a quoted string to be used within a parameter value (as defined
   in <xref target="transfer.codings"/>).
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="word"/><iref primary="true" item="Grammar" subitem="token"/><iref primary="true" item="Grammar" subitem="tchar"/><iref primary="true" item="Grammar" subitem="special"><!--unused production--></iref>
  <x:ref>word</x:ref>           = <x:ref>token</x:ref> / <x:ref>quoted-string</x:ref>

  <x:ref>token</x:ref>          = 1*<x:ref>tchar</x:ref>
<!--
  IMPORTANT: when editing "tchar" make sure that "special" is updated accordingly!!!
 -->
  <x:ref>tchar</x:ref>          = "!" / "#" / "$" / "%" / "&amp;" / "'" / "*"
                 / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~" 
                 / <x:ref>DIGIT</x:ref> / <x:ref>ALPHA</x:ref>
                 ; any <x:ref>VCHAR</x:ref>, except <x:ref>special</x:ref>

  <x:ref>special</x:ref>        = "(" / ")" / "&lt;" / ">" / "@" / ","
                 / ";" / ":" / "\" / DQUOTE / "/" / "[" 
                 / "]" / "?" / "=" / "{" / "}"
</artwork></figure>
<t anchor="rule.quoted-string">
  <x:anchor-alias value="quoted-string"/>
  <x:anchor-alias value="qdtext"/>
  <x:anchor-alias value="obs-text"/>
   A string of text is parsed as a single word if it is quoted using
   double-quote marks.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="quoted-string"/><iref primary="true" item="Grammar" subitem="qdtext"/><iref primary="true" item="Grammar" subitem="obs-text"/>
  <x:ref>quoted-string</x:ref>  = <x:ref>DQUOTE</x:ref> *( <x:ref>qdtext</x:ref> / <x:ref>quoted-pair</x:ref> ) <x:ref>DQUOTE</x:ref>
  <x:ref>qdtext</x:ref>         = <x:ref>HTAB</x:ref> / <x:ref>SP</x:ref> /%x21 / %x23-5B / %x5D-7E / <x:ref>obs-text</x:ref>
  <x:ref>obs-text</x:ref>       = %x80-FF
</artwork></figure>
<t anchor="rule.quoted-pair">
  <x:anchor-alias value="quoted-pair"/>
   The backslash octet ("\") can be used as a single-octet
   quoting mechanism within quoted-string constructs:
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="quoted-pair"/>
  <x:ref>quoted-pair</x:ref>    = "\" ( <x:ref>HTAB</x:ref> / <x:ref>SP</x:ref> / <x:ref>VCHAR</x:ref> / <x:ref>obs-text</x:ref> ) 
</artwork></figure>
<t>
   Recipients that process the value of a quoted-string &MUST; handle a
   quoted-pair as if it were replaced by the octet following the backslash. 
</t>
<t>
   Senders &SHOULD-NOT; generate a quoted-pair in a quoted-string except where
   necessary to quote DQUOTE and backslash octets occurring within that string.
</t>
<t anchor="rule.comment">
  <x:anchor-alias value="comment"/>
  <x:anchor-alias value="ctext"/>
   Comments can be included in some HTTP header fields by surrounding
   the comment text with parentheses. Comments are only allowed in
   fields containing "comment" as part of their field value definition.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="comment"/><iref primary="true" item="Grammar" subitem="ctext"/>
  <x:ref>comment</x:ref>        = "(" *( <x:ref>ctext</x:ref> / <x:ref>quoted-cpair</x:ref> / <x:ref>comment</x:ref> ) ")"
  <x:ref>ctext</x:ref>          = <x:ref>HTAB</x:ref> / <x:ref>SP</x:ref> / %x21-27 / %x2A-5B / %x5D-7E / <x:ref>obs-text</x:ref>
</artwork></figure>
<t anchor="rule.quoted-cpair">
  <x:anchor-alias value="quoted-cpair"/>
   The backslash octet ("\") can be used as a single-octet
   quoting mechanism within comment constructs:
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="quoted-cpair"/>
  <x:ref>quoted-cpair</x:ref>   = "\" ( <x:ref>HTAB</x:ref> / <x:ref>SP</x:ref> / <x:ref>VCHAR</x:ref> / <x:ref>obs-text</x:ref> ) 
</artwork></figure>
<t>
   Senders &SHOULD-NOT; escape octets in comments that do not require escaping
   (i.e., other than the backslash octet "\" and the parentheses "(" and ")").
</t>
</section>

</section>

<section title="Message Body" anchor="message.body">
  <x:anchor-alias value="message-body"/>
<t>
   The message body (if any) of an HTTP message is used to carry the
   payload body of that request or response.  The message body is
   identical to the payload body unless a transfer coding has been
   applied, as described in <xref target="header.transfer-encoding"/>.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="message-body"/>
  <x:ref>message-body</x:ref> = *OCTET
</artwork></figure>
<t>
   The rules for when a message body is allowed in a message differ for
   requests and responses.
</t>
<t>
   The presence of a message body in a request is signaled by a
   <x:ref>Content-Length</x:ref> or <x:ref>Transfer-Encoding</x:ref> header
   field. Request message framing is independent of method semantics,
   even if the method does not define any use for a message body.
</t>
<t>
   The presence of a message body in a response depends on both
   the request method to which it is responding and the response
   status code (<xref target="status.line"/>).
   Responses to the HEAD request method never include a message body
   because the associated response header fields (e.g.,
   <x:ref>Transfer-Encoding</x:ref>, <x:ref>Content-Length</x:ref>, etc.),
   if present, indicate only what their values would have been if the request
   method had been GET (&HEAD;).
   <x:ref>2xx (Successful)</x:ref> responses to CONNECT switch to tunnel
   mode instead of having a message body (&CONNECT;).
   All <x:ref>1xx (Informational)</x:ref>, <x:ref>204 (No Content)</x:ref>, and
   <x:ref>304 (Not Modified)</x:ref> responses do not include a message body.
   All other responses do include a message body, although the body
   might be of zero length.
</t>

<section title="Transfer-Encoding" anchor="header.transfer-encoding">
  <iref primary="true" item="Transfer-Encoding header field" x:for-anchor=""/>
  <iref item="chunked (Coding Format)"/>
  <x:anchor-alias value="Transfer-Encoding"/>
<t>
   The Transfer-Encoding header field lists the transfer coding names
   corresponding to the sequence of transfer codings that have been
   (or will be) applied to the payload body in order to form the message body.
   Transfer codings are defined in <xref target="transfer.codings"/>.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Transfer-Encoding"/>
  <x:ref>Transfer-Encoding</x:ref> = 1#<x:ref>transfer-coding</x:ref>
</artwork></figure>
<t>
   Transfer-Encoding is analogous to the Content-Transfer-Encoding field of
   MIME, which was designed to enable safe transport of binary data over a
   7-bit transport service (<xref target="RFC2045" x:fmt="," x:sec="6"/>).
   However, safe transport has a different focus for an 8bit-clean transfer
   protocol. In HTTP's case, Transfer-Encoding is primarily intended to
   accurately delimit a dynamically generated payload and to distinguish
   payload encodings that are only applied for transport efficiency or
   security from those that are characteristics of the selected resource.
</t>
<t>
   All HTTP/1.1 recipients &MUST; implement the chunked transfer coding
   (<xref target="chunked.encoding"/>) because it plays a crucial role in
   framing messages when the payload body size is not known in advance.
   If chunked is applied to a payload body, the sender &MUST-NOT; apply
   chunked more than once (i.e., chunking an already chunked message is not
   allowed).
   If any transfer coding is applied to a request payload body, the
   sender &MUST; apply chunked as the final transfer coding to ensure that
   the message is properly framed.
   If any transfer coding is applied to a response payload body, the
   sender &MUST; either apply chunked as the final transfer coding or
   terminate the message by closing the connection.
</t>
<figure><preamble>
   For example,
</preamble><artwork type="example">
  Transfer-Encoding: gzip, chunked
</artwork><postamble>
   indicates that the payload body has been compressed using the gzip
   coding and then chunked using the chunked coding while forming the
   message body.
</postamble></figure>
<t>
   Unlike <x:ref>Content-Encoding</x:ref> (&content-codings;),
   Transfer-Encoding is a property of the message, not of the representation, and
   any recipient along the request/response chain &MAY; decode the received
   transfer coding(s) or apply additional transfer coding(s) to the message
   body, assuming that corresponding changes are made to the Transfer-Encoding
   field-value. Additional information about the encoding parameters &MAY; be
   provided by other header fields not defined by this specification.
</t>
<t>
   Transfer-Encoding &MAY; be sent in a response to a HEAD request or in a
   <x:ref>304 (Not Modified)</x:ref> response (&status-304;) to a GET request,
   neither of which includes a message body,
   to indicate that the origin server would have applied a transfer coding
   to the message body if the request had been an unconditional GET.
   This indication is not required, however, because any recipient on
   the response chain (including the origin server) can remove transfer
   codings when they are not needed.
</t>
<t>
   Transfer-Encoding was added in HTTP/1.1.  It is generally assumed that
   implementations advertising only HTTP/1.0 support will not understand
   how to process a transfer-encoded payload.
   A client &MUST-NOT; send a request containing Transfer-Encoding unless it
   knows the server will handle HTTP/1.1 (or later) requests; such knowledge
   might be in the form of specific user configuration or by remembering the
   version of a prior received response.
   A server &MUST-NOT; send a response containing Transfer-Encoding unless
   the corresponding request indicates HTTP/1.1 (or later).
</t>
<t>
   A server that receives a request message with a transfer coding it does
   not understand &SHOULD; respond with <x:ref>501 (Not Implemented)</x:ref>.
</t>
</section>

<section title="Content-Length" anchor="header.content-length">
  <iref primary="true" item="Content-Length header field" x:for-anchor=""/>
  <x:anchor-alias value="Content-Length"/>
<t>
   When a message does not have a <x:ref>Transfer-Encoding</x:ref> header
   field, a Content-Length header field can provide the anticipated size,
   as a decimal number of octets, for a potential payload body.
   For messages that do include a payload body, the Content-Length field-value
   provides the framing information necessary for determining where the body
   (and message) ends.  For messages that do not include a payload body, the
   Content-Length indicates the size of the selected representation
   (&representation;).
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Content-Length"/>
  <x:ref>Content-Length</x:ref> = 1*<x:ref>DIGIT</x:ref>
</artwork></figure>
<t>
   An example is
</t>
<figure><artwork type="example">
  Content-Length: 3495
</artwork></figure>
<t>
   A sender &MUST-NOT; send a Content-Length header field in any message that
   contains a <x:ref>Transfer-Encoding</x:ref> header field.
</t>
<t>
   A user agent &SHOULD; send a Content-Length in a request message when no
   <x:ref>Transfer-Encoding</x:ref> is sent and the request method defines
   a meaning for an enclosed payload body. For example, a Content-Length
   header field is normally sent in a POST request even when the value is
   0 (indicating an empty payload body).  A user agent &SHOULD-NOT; send a
   Content-Length header field when the request message does not contain a
   payload body and the method semantics do not anticipate such a body.
</t>
<t>
   A server &MAY; send a Content-Length header field in a response to a HEAD
   request (&HEAD;); a server &MUST-NOT; send Content-Length in such a
   response unless its field-value equals the decimal number of octets that
   would have been sent in the payload body of a response if the same
   request had used the GET method.
</t>
<t>
   A server &MAY; send a Content-Length header field in a
   <x:ref>304 (Not Modified)</x:ref> response to a conditional GET request
   (&status-304;); a server &MUST-NOT; send Content-Length in such a
   response unless its field-value equals the decimal number of octets that
   would have been sent in the payload body of a <x:ref>200 (OK)</x:ref>
   response to the same request.
</t>
<t>
   A server &MUST-NOT; send a Content-Length header field in any response
   with a status code of
   <x:ref>1xx (Informational)</x:ref> or <x:ref>204 (No Content)</x:ref>.
   A server &SHOULD-NOT; send a Content-Length header field in any
   <x:ref>2xx (Successful)</x:ref> response to a CONNECT request (&CONNECT;).
</t>
<t>
   Aside from the cases defined above, in the absence of Transfer-Encoding,
   an origin server &SHOULD; send a Content-Length header field when the
   payload body size is known prior to sending the complete header block.
   This will allow downstream recipients to measure transfer progress,
   know when a received message is complete, and potentially reuse the
   connection for additional requests.
</t>
<t>
   Any Content-Length field value greater than or equal to zero is valid.
   Since there is no predefined limit to the length of a payload,
   recipients &SHOULD; anticipate potentially large decimal numerals and
   prevent parsing errors due to integer conversion overflows
   (<xref target="attack.protocol.element.size.overflows"/>).
</t>
<t>
   If a message is received that has multiple Content-Length header fields
   with field-values consisting of the same decimal value, or a single
   Content-Length header field with a field value containing a list of
   identical decimal values (e.g., "Content-Length: 42, 42"), indicating that
   duplicate Content-Length header fields have been generated or combined by an
   upstream message processor, then the recipient &MUST; either reject the
   message as invalid or replace the duplicated field-values with a single
   valid Content-Length field containing that decimal value prior to
   determining the message body length.
</t>
<x:note>
  <t>
   &Note; HTTP's use of Content-Length for message framing differs
   significantly from the same field's use in MIME, where it is an optional
   field used only within the "message/external-body" media-type.
  </t>
</x:note>
</section>

<section title="Message Body Length" anchor="message.body.length">
  <iref item="chunked (Coding Format)"/>
<t>
   The length of a message body is determined by one of the following
   (in order of precedence):
</t>
<t>
  <list style="numbers">
    <x:lt><t>
     Any response to a HEAD request and any response with a 
     <x:ref>1xx (Informational)</x:ref>, <x:ref>204 (No Content)</x:ref>, or
     <x:ref>304 (Not Modified)</x:ref> status code is always
     terminated by the first empty line after the header fields, regardless of
     the header fields present in the message, and thus cannot contain a
     message body.
    </t></x:lt>
    <x:lt><t>
     Any <x:ref>2xx (Successful)</x:ref> response to a CONNECT request implies that the
     connection will become a tunnel immediately after the empty line that
     concludes the header fields.  A client &MUST; ignore any
     <x:ref>Content-Length</x:ref> or <x:ref>Transfer-Encoding</x:ref> header
     fields received in such a message.
    </t></x:lt>
    <x:lt><t>
     If a <x:ref>Transfer-Encoding</x:ref> header field is present
     and the chunked transfer coding (<xref target="chunked.encoding"/>)
     is the final encoding, the message body length is determined by reading
     and decoding the chunked data until the transfer coding indicates the
     data is complete.
    </t>
    <t>
     If a <x:ref>Transfer-Encoding</x:ref> header field is present in a
     response and the chunked transfer coding is not the final encoding, the
     message body length is determined by reading the connection until it is
     closed by the server.
     If a <x:ref>Transfer-Encoding</x:ref> header field is present in a request and the
     chunked transfer coding is not the final encoding, the message body
     length cannot be determined reliably; the server &MUST; respond with
     the <x:ref>400 (Bad Request)</x:ref> status code and then close the connection.
    </t>
    <t>
     If a message is received with both a <x:ref>Transfer-Encoding</x:ref>
     and a <x:ref>Content-Length</x:ref> header field, the Transfer-Encoding
     overrides the Content-Length. Such a message might indicate an attempt
     to perform request or response smuggling (bypass of security-related
     checks on message routing or content) and thus ought to be handled as
     an error.  A sender &MUST; remove the received Content-Length field
     prior to forwarding such a message downstream.
    </t></x:lt>
    <x:lt><t>
     If a message is received without <x:ref>Transfer-Encoding</x:ref> and with
     either multiple <x:ref>Content-Length</x:ref> header fields having
     differing field-values or a single Content-Length header field having an
     invalid value, then the message framing is invalid and &MUST; be treated
     as an error to prevent request or response smuggling.
     If this is a request message, the server &MUST; respond with
     a <x:ref>400 (Bad Request)</x:ref> status code and then close the connection.
     If this is a response message received by a proxy, the proxy
     &MUST; close the connection to the server, discard the received response,
     and send a <x:ref>502 (Bad Gateway)</x:ref> response to the client.
     If this is a response message received by a user agent, it &MUST; be
     treated as an error by discarding the message and closing the connection.
    </t></x:lt>
    <x:lt><t>
     If a valid <x:ref>Content-Length</x:ref> header field is present without
     <x:ref>Transfer-Encoding</x:ref>, its decimal value defines the
     expected message body length in octets.
     If the sender closes the connection or the recipient times out before the
     indicated number of octets are received, the recipient &MUST; consider
     the message to be incomplete and close the connection.
    </t></x:lt>
    <x:lt><t>
     If this is a request message and none of the above are true, then the
     message body length is zero (no message body is present).
    </t></x:lt>
    <x:lt><t>
     Otherwise, this is a response message without a declared message body
     length, so the message body length is determined by the number of octets
     received prior to the server closing the connection.
    </t></x:lt>
  </list>
</t>
<t>
   Since there is no way to distinguish a successfully completed,
   close-delimited message from a partially-received message interrupted
   by network failure, a server &SHOULD; use encoding or
   length-delimited messages whenever possible.  The close-delimiting
   feature exists primarily for backwards compatibility with HTTP/1.0.
</t>
<t>
   A server &MAY; reject a request that contains a message body but
   not a <x:ref>Content-Length</x:ref> by responding with
   <x:ref>411 (Length Required)</x:ref>.
</t>
<t>
   Unless a transfer coding other than chunked has been applied,
   a client that sends a request containing a message body &SHOULD;
   use a valid <x:ref>Content-Length</x:ref> header field if the message body
   length is known in advance, rather than the chunked transfer coding, since some
   existing services respond to chunked with a <x:ref>411 (Length Required)</x:ref>
   status code even though they understand the chunked transfer coding.  This
   is typically because such services are implemented via a gateway that
   requires a content-length in advance of being called and the server
   is unable or unwilling to buffer the entire request before processing.
</t>
<t>
   A user agent that sends a request containing a message body &MUST; send a
   valid <x:ref>Content-Length</x:ref> header field if it does not know the
   server will handle HTTP/1.1 (or later) requests; such knowledge can be in
   the form of specific user configuration or by remembering the version of a
   prior received response.
</t>
<t>
   If the final response to the last request on a connection has been
   completely received and there remains additional data to read, a user agent
   &MAY; discard the remaining data or attempt to determine if that data
   belongs as part of the prior response body, which might be the case if the
   prior message's Content-Length value is incorrect. A client &MUST-NOT;
   process, cache, or forward such extra data as a separate response, since
   such behavior would be vulnerable to cache poisoning.
</t>
</section>
</section>

<section anchor="incomplete.messages" title="Handling Incomplete Messages">
<t>
   A server that receives an incomplete request message, usually due to a
   canceled request or a triggered time-out exception, &MAY; send an error
   response prior to closing the connection.
</t>
<t>
   A client that receives an incomplete response message, which can occur
   when a connection is closed prematurely or when decoding a supposedly
   chunked transfer coding fails, &MUST; record the message as incomplete.
   Cache requirements for incomplete responses are defined in
   &cache-incomplete;.
</t>
<t>
   If a response terminates in the middle of the header block (before the
   empty line is received) and the status code might rely on header fields to
   convey the full meaning of the response, then the client cannot assume
   that meaning has been conveyed; the client might need to repeat the
   request in order to determine what action to take next.
</t>
<t>
   A message body that uses the chunked transfer coding is
   incomplete if the zero-sized chunk that terminates the encoding has not
   been received.  A message that uses a valid <x:ref>Content-Length</x:ref> is
   incomplete if the size of the message body received (in octets) is less than
   the value given by Content-Length.  A response that has neither chunked
   transfer coding nor Content-Length is terminated by closure of the
   connection, and thus is considered complete regardless of the number of
   message body octets received, provided that the header block was received
   intact.
</t>
</section>

<section title="Message Parsing Robustness" anchor="message.robustness">
<t>
   Older HTTP/1.0 user agent implementations might send an extra CRLF
   after a POST request as a workaround for some early server
   applications that failed to read message body content that was
   not terminated by a line-ending. An HTTP/1.1 user agent &MUST-NOT;
   preface or follow a request with an extra CRLF.  If terminating
   the request message body with a line-ending is desired, then the
   user agent &MUST; count the terminating CRLF octets as part of the
   message body length. 
</t>
<t>
   In the interest of robustness, servers &SHOULD; ignore at least one
   empty line received where a request-line is expected. In other words, if
   a server is reading the protocol stream at the beginning of a
   message and receives a CRLF first, the server &SHOULD; ignore the CRLF.
</t>
<t>
   Although the line terminator for the start-line and header
   fields is the sequence CRLF, recipients &MAY; recognize a
   single LF as a line terminator and ignore any preceding CR.
</t>
<t>
   Although the request-line and status-line grammar rules require that each
   of the component elements be separated by a single SP octet, recipients
   &MAY; instead parse on whitespace-delimited word boundaries and, aside
   from the CRLF terminator, treat any form of whitespace as the SP separator
   while ignoring preceding or trailing whitespace;
   such whitespace includes one or more of the following octets:
   SP, HTAB, VT (%x0B), FF (%x0C), or bare CR. 
</t>
<t>
   When a server listening only for HTTP request messages, or processing
   what appears from the start-line to be an HTTP request message,
   receives a sequence of octets that does not match the HTTP-message
   grammar aside from the robustness exceptions listed above, the
   server &SHOULD; respond with a <x:ref>400 (Bad Request)</x:ref> response.  
</t>
</section>
</section>

<section title="Transfer Codings" anchor="transfer.codings">
  <x:anchor-alias value="transfer-coding"/>
  <x:anchor-alias value="transfer-extension"/>
<t>
   Transfer coding names are used to indicate an encoding
   transformation that has been, can be, or might need to be applied to a
   payload body in order to ensure "safe transport" through the network.
   This differs from a content coding in that the transfer coding is a
   property of the message rather than a property of the representation
   that is being transferred.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="transfer-coding"/><iref primary="true" item="Grammar" subitem="transfer-extension"/>
  <x:ref>transfer-coding</x:ref>    = "chunked" ; <xref target="chunked.encoding"/>
                     / "compress" ; <xref target="compress.coding"/>
                     / "deflate" ; <xref target="deflate.coding"/>
                     / "gzip" ; <xref target="gzip.coding"/>
                     / <x:ref>transfer-extension</x:ref>
  <x:ref>transfer-extension</x:ref> = <x:ref>token</x:ref> *( <x:ref>OWS</x:ref> ";" <x:ref>OWS</x:ref> <x:ref>transfer-parameter</x:ref> )
</artwork></figure>
<t anchor="rule.parameter">
  <x:anchor-alias value="attribute"/>
  <x:anchor-alias value="transfer-parameter"/>
  <x:anchor-alias value="value"/>
   Parameters are in the form of attribute/value pairs.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="transfer-parameter"/><iref primary="true" item="Grammar" subitem="attribute"/><iref primary="true" item="Grammar" subitem="value"/><iref primary="true" item="Grammar" subitem="date2"/><iref primary="true" item="Grammar" subitem="date3"/>
  <x:ref>transfer-parameter</x:ref> = <x:ref>attribute</x:ref> <x:ref>BWS</x:ref> "=" <x:ref>BWS</x:ref> <x:ref>value</x:ref>
  <x:ref>attribute</x:ref>          = <x:ref>token</x:ref>
  <x:ref>value</x:ref>              = <x:ref>word</x:ref>
</artwork></figure>
<t>
   All transfer-coding names are case-insensitive and ought to be registered
   within the HTTP Transfer Coding registry, as defined in
   <xref target="transfer.coding.registry"/>.
   They are used in the <x:ref>TE</x:ref> (<xref target="header.te"/>) and
   <x:ref>Transfer-Encoding</x:ref> (<xref target="header.transfer-encoding"/>)
   header fields.
</t>

<section title="Chunked Transfer Coding" anchor="chunked.encoding">
  <iref primary="true" item="chunked (Coding Format)"/>
  <x:anchor-alias value="chunk"/>
  <x:anchor-alias value="chunked-body"/>
  <x:anchor-alias value="chunk-data"/>
  <x:anchor-alias value="chunk-ext"/>
  <x:anchor-alias value="chunk-ext-name"/>
  <x:anchor-alias value="chunk-ext-val"/>
  <x:anchor-alias value="chunk-size"/>
  <x:anchor-alias value="last-chunk"/>
  <x:anchor-alias value="trailer-part"/>
  <x:anchor-alias value="quoted-str-nf"/>
  <x:anchor-alias value="qdtext-nf"/>
<t>
   The chunked transfer coding modifies the body of a message in order to
   transfer it as a series of chunks, each with its own size indicator,
   followed by an &OPTIONAL; trailer containing header fields. This
   allows dynamically generated content to be transferred along with the
   information necessary for the recipient to verify that it has
   received the full message.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="chunked-body"><!--terminal production--></iref><iref primary="true" item="Grammar" subitem="chunk"/><iref primary="true" item="Grammar" subitem="chunk-size"/><iref primary="true" item="Grammar" subitem="last-chunk"/><iref primary="true" item="Grammar" subitem="chunk-ext"/><iref primary="true" item="Grammar" subitem="chunk-ext-name"/><iref primary="true" item="Grammar" subitem="chunk-ext-val"/><iref primary="true" item="Grammar" subitem="chunk-data"/><iref primary="true" item="Grammar" subitem="trailer-part"/><iref primary="true" item="Grammar" subitem="quoted-str-nf"/><iref primary="true" item="Grammar" subitem="qdtext-nf"/>
  <x:ref>chunked-body</x:ref>   = *<x:ref>chunk</x:ref>
                   <x:ref>last-chunk</x:ref>
                   <x:ref>trailer-part</x:ref>
                   <x:ref>CRLF</x:ref>
  
  <x:ref>chunk</x:ref>          = <x:ref>chunk-size</x:ref> [ <x:ref>chunk-ext</x:ref> ] <x:ref>CRLF</x:ref>
                   <x:ref>chunk-data</x:ref> <x:ref>CRLF</x:ref>
  <x:ref>chunk-size</x:ref>     = 1*<x:ref>HEXDIG</x:ref>
  <x:ref>last-chunk</x:ref>     = 1*("0") [ <x:ref>chunk-ext</x:ref> ] <x:ref>CRLF</x:ref>
  
  <x:ref>chunk-ext</x:ref>      = *( ";" <x:ref>chunk-ext-name</x:ref> [ "=" <x:ref>chunk-ext-val</x:ref> ] )
  <x:ref>chunk-ext-name</x:ref> = <x:ref>token</x:ref>
  <x:ref>chunk-ext-val</x:ref>  = <x:ref>token</x:ref> / <x:ref>quoted-str-nf</x:ref>
  <x:ref>chunk-data</x:ref>     = 1*<x:ref>OCTET</x:ref> ; a sequence of chunk-size octets
  <x:ref>trailer-part</x:ref>   = *( <x:ref>header-field</x:ref> <x:ref>CRLF</x:ref> )
  
  <x:ref>quoted-str-nf</x:ref>  = <x:ref>DQUOTE</x:ref> *( <x:ref>qdtext-nf</x:ref> / <x:ref>quoted-pair</x:ref> ) <x:ref>DQUOTE</x:ref>
                 ; like <x:ref>quoted-string</x:ref>, but disallowing line folding
  <x:ref>qdtext-nf</x:ref>      = <x:ref>HTAB</x:ref> / <x:ref>SP</x:ref> / %x21 / %x23-5B / %x5D-7E / <x:ref>obs-text</x:ref>
</artwork></figure>
<t>
   Chunk extensions within the chunked transfer coding are deprecated.
   Senders &SHOULD-NOT; send chunk-ext.
   Definition of new chunk extensions is discouraged. 
</t>
<t>
   The chunk-size field is a string of hex digits indicating the size of
   the chunk-data in octets. The chunked transfer coding is complete when a
   chunk with a chunk-size of zero is received, possibly followed by a
   trailer, and finally terminated by an empty line.
</t>

<section title="Trailer" anchor="header.trailer">
  <iref primary="true" item="Trailer header field" x:for-anchor=""/>
  <x:anchor-alias value="Trailer"/>
<t>
   A trailer allows the sender to include additional fields at the end of a
   chunked message in order to supply metadata that might be dynamically
   generated while the message body is sent, such as a message integrity
   check, digital signature, or post-processing status.
   The trailer &MUST-NOT; contain fields that need to be known before a
   recipient processes the body, such as <x:ref>Transfer-Encoding</x:ref>,
   <x:ref>Content-Length</x:ref>, and <x:ref>Trailer</x:ref>.
</t>
<t>
   When a message includes a message body encoded with the chunked
   transfer coding and the sender desires to send metadata in the form of
   trailer fields at the end of the message, the sender &SHOULD; send a
   <x:ref>Trailer</x:ref> header field before the message body to indicate
   which fields will be present in the trailers. This allows the recipient
   to prepare for receipt of that metadata before it starts processing the body,
   which is useful if the message is being streamed and the recipient wishes
   to confirm an integrity check on the fly.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Trailer"/>
  <x:ref>Trailer</x:ref> = 1#<x:ref>field-name</x:ref>
</artwork></figure>
<t>
   If no <x:ref>Trailer</x:ref> header field is present, the sender of a
   chunked message body &SHOULD; send an empty trailer.
</t>
<t>
   A server &MUST; send an empty trailer with the chunked transfer coding
   unless at least one of the following is true:
  <list style="numbers">
    <t>the request included a <x:ref>TE</x:ref> header field that indicates
    "trailers" is acceptable in the transfer coding of the response, as
    described in <xref target="header.te"/>; or,</t>
     
    <t>the trailer fields consist entirely of optional metadata and the
    recipient could use the message (in a manner acceptable to the server where
    the field originated) without receiving that metadata. In other words,
    the server that generated the header field is willing to accept the
    possibility that the trailer fields might be silently discarded along
    the path to the client.</t>
  </list>
</t>
<t>
   The above requirement prevents the need for an infinite buffer when a
   message is being received by an HTTP/1.1 (or later) proxy and forwarded to
   an HTTP/1.0 recipient.
</t>
</section>

<section title="Decoding chunked" anchor="decoding.chunked">
<t>
   A process for decoding the chunked transfer coding
   can be represented in pseudo-code as:
</t>
<figure><artwork type="code">
  length := 0
  read chunk-size, chunk-ext (if any), and CRLF
  while (chunk-size &gt; 0) {
     read chunk-data and CRLF
     append chunk-data to decoded-body
     length := length + chunk-size
     read chunk-size, chunk-ext (if any), and CRLF
  }
  read header-field
  while (header-field not empty) {
     append header-field to existing header fields
     read header-field
  }
  Content-Length := length
  Remove "chunked" from Transfer-Encoding
  Remove Trailer from existing header fields
</artwork></figure>
<t>
   All recipients &MUST; be able to receive and decode the
   chunked transfer coding and &MUST; ignore chunk-ext extensions
   they do not understand.
</t>
</section>
</section>

<section title="Compression Codings" anchor="compression.codings">
<t>
   The codings defined below can be used to compress the payload of a
   message.
</t>

<section title="Compress Coding" anchor="compress.coding">
<iref item="compress (Coding Format)"/>
<t>
   The "compress" coding is an adaptive Lempel-Ziv-Welch (LZW) coding
   <xref target="Welch"/> that is commonly produced by the UNIX file
   compression program "compress".
   Recipients &SHOULD; consider "x-compress" to be equivalent to "compress".
</t>
</section>

<section title="Deflate Coding" anchor="deflate.coding">
<iref item="deflate (Coding Format)"/>
<t>
   The "deflate" coding is a "zlib" data format <xref target="RFC1950"/>
   containing a "deflate" compressed data stream <xref target="RFC1951"/>
   that uses a combination of the Lempel-Ziv (LZ77) compression algorithm and
   Huffman coding.
</t>
<x:note>
  <t>
    &Note; Some incorrect implementations send the "deflate" 
    compressed data without the zlib wrapper.
   </t>
</x:note>
</section>

<section title="Gzip Coding" anchor="gzip.coding">
<iref item="gzip (Coding Format)"/>
<t>
   The "gzip" coding is an LZ77 coding with a 32 bit CRC that is commonly
   produced by the gzip file compression program <xref target="RFC1952"/>.
   Recipients &SHOULD; consider "x-gzip" to be equivalent to "gzip".
</t>
</section>

</section>

<section title="TE" anchor="header.te">
  <iref primary="true" item="TE header field" x:for-anchor=""/>
  <x:anchor-alias value="TE"/>
  <x:anchor-alias value="t-codings"/>
  <x:anchor-alias value="t-ranking"/>
  <x:anchor-alias value="rank"/>
<t>
   The "TE" header field in a request indicates what transfer codings,
   besides chunked, the client is willing to accept in response, and
   whether or not the client is willing to accept trailer fields in a
   chunked transfer coding.
</t>
<t>
   The TE field-value consists of a comma-separated list of transfer coding
   names, each allowing for optional parameters (as described in
   <xref target="transfer.codings"/>), and/or the keyword "trailers".
   Clients &MUST-NOT; send the chunked transfer coding name in TE;
   chunked is always acceptable for HTTP/1.1 recipients.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="TE"/><iref primary="true" item="Grammar" subitem="t-codings"/><iref primary="true" item="Grammar" subitem="t-ranking"/><iref primary="true" item="Grammar" subitem="rank"/>
  <x:ref>TE</x:ref>        = #<x:ref>t-codings</x:ref>
  <x:ref>t-codings</x:ref> = "trailers" / ( <x:ref>transfer-coding</x:ref> [ <x:ref>t-ranking</x:ref> ] )
  <x:ref>t-ranking</x:ref> = <x:ref>OWS</x:ref> ";" <x:ref>OWS</x:ref> "q=" <x:ref>rank</x:ref>
  <x:ref>rank</x:ref>      = ( "0" [ "." 0*3<x:ref>DIGIT</x:ref> ] )
             / ( "1" [ "." 0*3("0") ] )
</artwork></figure>
<t>
   Three examples of TE use are below.
</t>
<figure><artwork type="example">
  TE: deflate
  TE:
  TE: trailers, deflate;q=0.5
</artwork></figure>
<t>
   The presence of the keyword "trailers" indicates that the client is willing
   to accept trailer fields in a chunked transfer coding, as defined in
   <xref target="chunked.encoding"/>, on behalf of itself and any downstream
   clients. For requests from an intermediary, this implies that either:
   (a) all downstream clients are willing to accept trailer fields in the
   forwarded response; or,
   (b) the intermediary will attempt to buffer the response on behalf of
   downstream recipients.
   Note that HTTP/1.1 does not define any means to limit the size of a
   chunked response such that an intermediary can be assured of buffering the
   entire response.
</t>
<t>
   When multiple transfer codings are acceptable, the client &MAY; rank the
   codings by preference using a case-insensitive "q" parameter (similar to
   the qvalues used in content negotiation fields, &qvalue;). The rank value
   is a real number in the range 0 through 1, where 0.001 is the least
   preferred and 1 is the most preferred; a value of 0 means "not acceptable".
</t>
<t>
   If the TE field-value is empty or if no TE field is present, the only
   acceptable transfer coding is chunked. A message with no transfer coding
   is always acceptable.
</t>
<t>
   Since the TE header field only applies to the immediate connection,
   a sender of TE &MUST; also send a "TE" connection option within the
   <x:ref>Connection</x:ref> header field (<xref target="header.connection"/>)
   in order to prevent the TE field from being forwarded by intermediaries
   that do not support its semantics.
</t>
</section>
</section>

<section title="Message Routing" anchor="message.routing">
<t>
   HTTP request message routing is determined by each client based on the
   target resource, the client's proxy configuration, and
   establishment or reuse of an inbound connection.  The corresponding
   response routing follows the same connection chain back to the client.
</t>

<section title="Identifying a Target Resource" anchor="target-resource">
  <iref primary="true" item="target resource"/>
  <iref primary="true" item="target URI"/>
  <x:anchor-alias value="target resource"/>
  <x:anchor-alias value="target URI"/>
<t>
   HTTP is used in a wide variety of applications, ranging from
   general-purpose computers to home appliances.  In some cases,
   communication options are hard-coded in a client's configuration.
   However, most HTTP clients rely on the same resource identification
   mechanism and configuration techniques as general-purpose Web browsers.
</t>
<t>
   HTTP communication is initiated by a user agent for some purpose.
   The purpose is a combination of request semantics, which are defined in
   <xref target="Part2"/>, and a target resource upon which to apply those
   semantics.  A URI reference (<xref target="uri"/>) is typically used as
   an identifier for the "<x:dfn>target resource</x:dfn>", which a user agent
   would resolve to its absolute form in order to obtain the
   "<x:dfn>target URI</x:dfn>".  The target URI
   excludes the reference's fragment component, if any,
   since fragment identifiers are reserved for client-side processing
   (<xref target="RFC3986" x:fmt="," x:sec="3.5"/>).
</t>
</section>

<section title="Connecting Inbound" anchor="connecting.inbound">
<t>
   Once the target URI is determined, a client needs to decide whether
   a network request is necessary to accomplish the desired semantics and,
   if so, where that request is to be directed.
</t>
<t>
   If the client has a cache <xref target="Part6"/> and the request can be
   satisfied by it, then the request is
   usually directed there first.
</t>
<t>
   If the request is not satisfied by a cache, then a typical client will
   check its configuration to determine whether a proxy is to be used to
   satisfy the request.  Proxy configuration is implementation-dependent,
   but is often based on URI prefix matching, selective authority matching,
   or both, and the proxy itself is usually identified by an "http" or
   "https" URI.  If a proxy is applicable, the client connects inbound by 
   establishing (or reusing) a connection to that proxy.
</t>
<t>
   If no proxy is applicable, a typical client will invoke a handler routine,
   usually specific to the target URI's scheme, to connect directly
   to an authority for the target resource.  How that is accomplished is
   dependent on the target URI scheme and defined by its associated
   specification, similar to how this specification defines origin server
   access for resolution of the "http" (<xref target="http.uri"/>) and
   "https" (<xref target="https.uri"/>) schemes.
</t>
<t>
   HTTP requirements regarding connection management are defined in
   <xref target="connection.management"/>.
</t>
</section>

<section title="Request Target" anchor="request-target">
<t>
   Once an inbound connection is obtained,
   the client sends an HTTP request message (<xref target="http.message"/>)
   with a request-target derived from the target URI.
   There are four distinct formats for the request-target, depending on both
   the method being requested and whether the request is to a proxy.
</t>   
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="request-target"/><iref primary="true" item="Grammar" subitem="origin-form"/><iref primary="true" item="Grammar" subitem="absolute-form"/><iref primary="true" item="Grammar" subitem="authority-form"/><iref primary="true" item="Grammar" subitem="asterisk-form"/>
  <x:ref>request-target</x:ref> = <x:ref>origin-form</x:ref>
                 / <x:ref>absolute-form</x:ref>
                 / <x:ref>authority-form</x:ref>
                 / <x:ref>asterisk-form</x:ref>

  <x:ref>origin-form</x:ref>    = <x:ref>absolute-path</x:ref> [ "?" <x:ref>query</x:ref> ]
  <x:ref>absolute-form</x:ref>  = <x:ref>absolute-URI</x:ref>
  <x:ref>authority-form</x:ref> = <x:ref>authority</x:ref>
  <x:ref>asterisk-form</x:ref>  = "*"
</artwork></figure>
<t anchor="origin-form"><iref item="origin-form (of request-target)"/>
  <x:h>origin-form</x:h>
</t>
<t>
   The most common form of request-target is the <x:dfn>origin-form</x:dfn>.
   When making a request directly to an origin server, other than a CONNECT
   or server-wide OPTIONS request (as detailed below),
   a client &MUST; send only the absolute path and query components of
   the target URI as the request-target.
   If the target URI's path component is empty, then the client &MUST; send
   "/" as the path within the origin-form of request-target.
   A <x:ref>Host</x:ref> header field is also sent, as defined in
   <xref target="header.host"/>, containing the target URI's
   authority component (excluding any userinfo).
</t>
<t>
   For example, a client wishing to retrieve a representation of the resource
   identified as
</t>
<figure><artwork x:indent-with="  " type="example">
http://www.example.org/where?q=now
</artwork></figure>
<t>
   directly from the origin server would open (or reuse) a TCP connection
   to port 80 of the host "www.example.org" and send the lines:
</t>
<figure><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
GET /where?q=now HTTP/1.1
Host: www.example.org
</artwork></figure>
<t>
   followed by the remainder of the request message.
</t>
<t anchor="absolute-form"><iref item="absolute-form (of request-target)"/>
  <x:h>absolute-form</x:h>
</t>
<t>
   When making a request to a proxy, other than a CONNECT or server-wide
   OPTIONS request (as detailed below), a client &MUST; send the target URI
   in <x:dfn>absolute-form</x:dfn> as the request-target.
   The proxy is requested to either service that request from a valid cache,
   if possible, or make the same request on the client's behalf to either
   the next inbound proxy server or directly to the origin server indicated
   by the request-target.  Requirements on such "forwarding" of messages are
   defined in <xref target="message.forwarding"/>.
</t>
<t>
   An example absolute-form of request-line would be:
</t>
<figure><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
GET http://www.example.org/pub/WWW/TheProject.html HTTP/1.1
</artwork></figure>
<t>
   To allow for transition to the absolute-form for all requests in some
   future version of HTTP, HTTP/1.1 servers &MUST; accept the absolute-form
   in requests, even though HTTP/1.1 clients will only send them in requests
   to proxies.
</t>
<t anchor="authority-form"><iref item="authority-form (of request-target)"/>
  <x:h>authority-form</x:h>
</t>
<t>
   The <x:dfn>authority-form</x:dfn> of request-target is only used for CONNECT requests
   (&CONNECT;).  When making a CONNECT request to establish a tunnel through
   one or more proxies, a client &MUST; send only the target URI's
   authority component (excluding any userinfo) as the request-target.
   For example,
</t>
<figure><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
CONNECT www.example.com:80 HTTP/1.1
</artwork></figure>
<t anchor="asterisk-form"><iref item="asterisk-form (of request-target)"/>
  <x:h>asterisk-form</x:h>
</t>
<t>
   The <x:dfn>asterisk-form</x:dfn> of request-target is only used for a server-wide
   OPTIONS request (&OPTIONS;).  When a client wishes to request OPTIONS
   for the server as a whole, as opposed to a specific named resource of
   that server, the client &MUST; send only "*" (%x2A) as the request-target.
   For example,
</t>
<figure><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
OPTIONS * HTTP/1.1
</artwork></figure>
<t>
   If a proxy receives an OPTIONS request with an absolute-form of
   request-target in which the URI has an empty path and no query component,
   then the last proxy on the request chain &MUST; send a request-target
   of "*" when it forwards the request to the indicated origin server.
</t>
<figure><preamble>   
   For example, the request
</preamble><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
OPTIONS http://www.example.org:8001 HTTP/1.1
</artwork></figure>
<figure><preamble>   
  would be forwarded by the final proxy as
</preamble><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
OPTIONS * HTTP/1.1
Host: www.example.org:8001
</artwork>
<postamble>
   after connecting to port 8001 of host "www.example.org".
</postamble>
</figure>
</section>

<section title="Host" anchor="header.host">
  <iref primary="true" item="Host header field" x:for-anchor=""/>
  <x:anchor-alias value="Host"/>
<t>
   The "Host" header field in a request provides the host and port
   information from the target URI, enabling the origin
   server to distinguish among resources while servicing requests
   for multiple host names on a single IP address.  Since the Host
   field-value is critical information for handling a request, it
   &SHOULD; be sent as the first header field following the request-line.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Host"/>
  <x:ref>Host</x:ref> = <x:ref>uri-host</x:ref> [ ":" <x:ref>port</x:ref> ] ; <xref target="http.uri"/>
</artwork></figure>
<t>
   A client &MUST; send a Host header field in all HTTP/1.1 request
   messages.  If the target URI includes an authority component, then
   the Host field-value &MUST; be identical to that authority component
   after excluding any userinfo (<xref target="http.uri"/>).
   If the authority component is missing or undefined for the target URI,
   then the Host header field &MUST; be sent with an empty field-value.
</t>
<t>
   For example, a GET request to the origin server for
   &lt;http://www.example.org/pub/WWW/&gt; would begin with:
</t>
<figure><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
GET /pub/WWW/ HTTP/1.1
Host: www.example.org
</artwork></figure>
<t>
   The Host header field &MUST; be sent in an HTTP/1.1 request even
   if the request-target is in the absolute-form, since this
   allows the Host information to be forwarded through ancient HTTP/1.0
   proxies that might not have implemented Host.
</t>
<t>
   When a proxy receives a request with an absolute-form of
   request-target, the proxy &MUST; ignore the received
   Host header field (if any) and instead replace it with the host
   information of the request-target.  If the proxy forwards the request,
   it &MUST; generate a new Host field-value based on the received
   request-target rather than forward the received Host field-value.
</t>
<t>
   Since the Host header field acts as an application-level routing
   mechanism, it is a frequent target for malware seeking to poison
   a shared cache or redirect a request to an unintended server.
   An interception proxy is particularly vulnerable if it relies on
   the Host field-value for redirecting requests to internal
   servers, or for use as a cache key in a shared cache, without
   first verifying that the intercepted connection is targeting a
   valid IP address for that host.
</t>
<t>
   A server &MUST; respond with a <x:ref>400 (Bad Request)</x:ref> status code
   to any HTTP/1.1 request message that lacks a Host header field and
   to any request message that contains more than one Host header field
   or a Host header field with an invalid field-value.
</t>
</section>

<section title="Effective Request URI" anchor="effective.request.uri">
  <iref primary="true" item="effective request URI"/>
  <x:anchor-alias value="effective request URI"/>
<t>
   A server that receives an HTTP request message &MUST; reconstruct
   the user agent's original target URI, based on the pieces of information
   learned from the request-target, <x:ref>Host</x:ref> header field, and
   connection context, in order to identify the intended target resource and
   properly service the request. The URI derived from this reconstruction
   process is referred to as the "<x:dfn>effective request URI</x:dfn>".
</t>
<t>
   For a user agent, the effective request URI is the target URI.
</t>
<t>
   If the request-target is in absolute-form, then the effective request URI
   is the same as the request-target.  Otherwise, the effective request URI
   is constructed as follows.
</t>
<t>
   If the request is received over a TLS-secured TCP connection,
   then the effective request URI's scheme is "https"; otherwise, the
   scheme is "http".
</t>
<t>
   If the request-target is in authority-form, then the effective
   request URI's authority component is the same as the request-target.
   Otherwise, if a <x:ref>Host</x:ref> header field is supplied with a
   non-empty field-value, then the authority component is the same as the
   Host field-value. Otherwise, the authority component is the concatenation of
   the default host name configured for the server, a colon (":"), and the
   connection's incoming TCP port number in decimal form.
</t>
<t>
   If the request-target is in authority-form or asterisk-form, then the
   effective request URI's combined path and query component is empty.
   Otherwise, the combined path and query component is the same as the
   request-target.
</t>
<t>
   The components of the effective request URI, once determined as above,
   can be combined into absolute-URI form by concatenating the scheme,
   "://", authority, and combined path and query component.
</t>
<figure>
<preamble>
   Example 1: the following message received over an insecure TCP connection
</preamble> 
<artwork type="example" x:indent-with="  ">
GET /pub/WWW/TheProject.html HTTP/1.1
Host: www.example.org:8080
</artwork>
</figure>
<figure>
<preamble>
  has an effective request URI of
</preamble>
<artwork type="example" x:indent-with="  ">
http://www.example.org:8080/pub/WWW/TheProject.html
</artwork>
</figure>
<figure>
<preamble>
   Example 2: the following message received over a TLS-secured TCP connection
</preamble> 
<artwork type="example" x:indent-with="  ">
OPTIONS * HTTP/1.1
Host: www.example.org
</artwork>
</figure>
<figure>
<preamble>
  has an effective request URI of
</preamble>
<artwork type="example" x:indent-with="  ">
https://www.example.org
</artwork>
</figure>
<t>
   An origin server that does not allow resources to differ by requested
   host &MAY; ignore the <x:ref>Host</x:ref> field-value and instead replace it
   with a configured server name when constructing the effective request URI.
</t>
<t>
   Recipients of an HTTP/1.0 request that lacks a <x:ref>Host</x:ref> header
   field &MAY; attempt to use heuristics (e.g., examination of the URI path for
   something unique to a particular host) in order to guess the
   effective request URI's authority component.
</t>
</section>

<section title="Associating a Response to a Request" anchor="associating.response.to.request">
<t>
   HTTP does not include a request identifier for associating a given
   request message with its corresponding one or more response messages.
   Hence, it relies on the order of response arrival to correspond exactly
   to the order in which requests are made on the same connection.
   More than one response message per request only occurs when one or more
   informational responses (<x:ref>1xx</x:ref>, see &status-1xx;) precede a
   final response to the same request.
</t>
<t>
   A client that has more than one outstanding request on a connection &MUST;
   maintain a list of outstanding requests in the order sent and &MUST;
   associate each received response message on that connection to the highest
   ordered request that has not yet received a final (non-<x:ref>1xx</x:ref>)
   response.
</t>
</section>

<section title="Message Forwarding" anchor="message.forwarding">
<t>
   As described in <xref target="intermediaries"/>, intermediaries can serve
   a variety of roles in the processing of HTTP requests and responses.
   Some intermediaries are used to improve performance or availability.
   Others are used for access control or to filter content.
   Since an HTTP stream has characteristics similar to a pipe-and-filter
   architecture, there are no inherent limits to the extent an intermediary
   can enhance (or interfere) with either direction of the stream.
</t>
<t>
   Intermediaries that forward a message &MUST; implement the
   <x:ref>Connection</x:ref> header field, as specified in
   <xref target="header.connection"/>, to exclude fields that are only
   intended for the incoming connection.
</t>
<t>
   In order to avoid request loops, a proxy that forwards requests to other
   proxies &MUST; be able to recognize and exclude all of its own server
   names, including any aliases, local variations, or literal IP addresses.
</t>

<section title="Via" anchor="header.via">
  <iref primary="true" item="Via header field" x:for-anchor=""/>
  <x:anchor-alias value="pseudonym"/>
  <x:anchor-alias value="received-by"/>
  <x:anchor-alias value="received-protocol"/>
  <x:anchor-alias value="Via"/>
<t>
   The "Via" header field indicates the presence of intermediate protocols and
   recipients between the user agent and the server (on requests) or between
   the origin server and the client (on responses), similar to the
   "Received" header field in email
   (<xref target="RFC5322" x:fmt="of" x:sec="3.6.7"/>).
   Via can be used for tracking message forwards,
   avoiding request loops, and identifying the protocol capabilities of
   senders along the request/response chain.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Via"/><iref primary="true" item="Grammar" subitem="received-protocol"/><iref primary="true" item="Grammar" subitem="protocol-name"/><iref primary="true" item="Grammar" subitem="protocol-version"/><iref primary="true" item="Grammar" subitem="received-by"/><iref primary="true" item="Grammar" subitem="pseudonym"/>
  <x:ref>Via</x:ref> = 1#( <x:ref>received-protocol</x:ref> <x:ref>RWS</x:ref> <x:ref>received-by</x:ref> [ <x:ref>RWS</x:ref> <x:ref>comment</x:ref> ] )

  <x:ref>received-protocol</x:ref> = [ <x:ref>protocol-name</x:ref> "/" ] <x:ref>protocol-version</x:ref>
                      ; see <xref target="header.upgrade"/>
  <x:ref>received-by</x:ref>       = ( <x:ref>uri-host</x:ref> [ ":" <x:ref>port</x:ref> ] ) / <x:ref>pseudonym</x:ref>
  <x:ref>pseudonym</x:ref>         = <x:ref>token</x:ref>
</artwork></figure>
<t>
   Multiple Via field values represent each proxy or gateway that has
   forwarded the message. Each intermediary appends its own information
   about how the message was received, such that the end result is ordered
   according to the sequence of forwarding recipients.
</t>
<t>
   A proxy &MUST; send an appropriate Via header field, as described below, in
   each message that it forwards.
   An HTTP-to-HTTP gateway &MUST; send an appropriate Via header field in
   each inbound request message and &MAY; send a Via header field in
   forwarded response messages.
</t>
<t>
   For each intermediary, the received-protocol indicates the protocol and
   protocol version used by the upstream sender of the message. Hence, the
   Via field value records the advertised protocol capabilities of the
   request/response chain such that they remain visible to downstream
   recipients; this can be useful for determining what backwards-incompatible
   features might be safe to use in response, or within a later request, as
   described in <xref target="http.version"/>. For brevity, the protocol-name
   is omitted when the received protocol is HTTP.
</t>
<t>
   The received-by field is normally the host and optional port number of a
   recipient server or client that subsequently forwarded the message.
   However, if the real host is considered to be sensitive information, it
   &MAY; be replaced by a pseudonym. If the port is not given, it &MAY; be
   assumed to be the default port of the received-protocol.
</t>
<t>
   Comments &MAY; be used in the Via header field to identify the software
   of each recipient, analogous to the <x:ref>User-Agent</x:ref> and
   <x:ref>Server</x:ref> header fields. However, all comments in the Via field
   are optional and &MAY; be removed by any recipient prior to forwarding the
   message.
</t>
<t>
   For example, a request message could be sent from an HTTP/1.0 user
   agent to an internal proxy code-named "fred", which uses HTTP/1.1 to
   forward the request to a public proxy at p.example.net, which completes
   the request by forwarding it to the origin server at www.example.com.
   The request received by www.example.com would then have the following
   Via header field:
</t>
<figure><artwork type="example">
  Via: 1.0 fred, 1.1 p.example.net
</artwork></figure>
<t>
   A proxy or gateway used as a portal through a network firewall
   &SHOULD-NOT; forward the names and ports of hosts within the firewall
   region unless it is explicitly enabled to do so. If not enabled, the
   received-by host of any host behind the firewall &SHOULD; be replaced
   by an appropriate pseudonym for that host.
</t>
<t>
   A proxy or gateway &MAY; combine an ordered subsequence of Via header
   field entries into a single such entry if the entries have identical
   received-protocol values. For example,
</t>
<figure><artwork type="example">
  Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy
</artwork></figure>
<t>
  could be collapsed to
</t>
<figure><artwork type="example">
  Via: 1.0 ricky, 1.1 mertz, 1.0 lucy
</artwork></figure>
<t>
   Senders &SHOULD-NOT; combine multiple entries unless they are all
   under the same organizational control and the hosts have already been
   replaced by pseudonyms. Senders &MUST-NOT; combine entries that
   have different received-protocol values.
</t>
</section>

<section title="Transformations" anchor="message.transformations">
<t>
   Some intermediaries include features for transforming messages and their
   payloads.  A transforming proxy might, for example, convert between image
   formats in order to save cache space or to reduce the amount of traffic on
   a slow link. However, operational problems might occur when these
   transformations are applied to payloads intended for critical applications,
   such as medical imaging or scientific data analysis, particularly when
   integrity checks or digital signatures are used to ensure that the payload
   received is identical to the original.
</t>
<t>
   If a proxy receives a request-target with a host name that is not a
   fully qualified domain name, it &MAY; add its own domain to the host name
   it received when forwarding the request.  A proxy &MUST-NOT; change the
   host name if it is a fully qualified domain name.
</t>
<t>
   A proxy &MUST-NOT; modify the "absolute-path" and "query" parts of the
   received request-target when forwarding it to the next inbound server,
   except as noted above to replace an empty path with "/" or "*".
</t>
<t>
   A proxy &MUST-NOT; modify header fields that provide information about the
   end points of the communication chain, the resource state, or the selected
   representation. A proxy &MAY; change the message body through application
   or removal of a transfer coding (<xref target="transfer.codings"/>).
</t>
<t>
   A non-transforming proxy &MUST-NOT; modify the message payload (&payload;).
   A transforming proxy &MUST-NOT; modify the payload of a message that
   contains the no-transform cache-control directive.
</t>
<t>
   A transforming proxy &MAY; transform the payload of a message
   that does not contain the no-transform cache-control directive;
   if the payload is transformed, the transforming proxy &MUST; add a
   Warning header field with the warn-code of 214 ("Transformation Applied")
   if one does not already appear in the message (see &header-warning;).
   If the payload of a <x:ref>200 (OK)</x:ref> response is transformed, the
   transforming proxy can also inform downstream recipients that a
   transformation has been applied by changing the response status code to
   <x:ref>203 (Non-Authoritative Information)</x:ref> (&status-203;).
</t>
</section>
</section>
</section>

<section title="Connection Management" anchor="connection.management">
<t>
   HTTP messaging is independent of the underlying transport or
   session-layer connection protocol(s).  HTTP only presumes a reliable
   transport with in-order delivery of requests and the corresponding
   in-order delivery of responses.  The mapping of HTTP request and
   response structures onto the data units of an underlying transport
   protocol is outside the scope of this specification.
</t>
<t>
   As described in <xref target="connecting.inbound"/>, the specific
   connection protocols to be used for an HTTP interaction are determined by
   client configuration and the <x:ref>target URI</x:ref>.
   For example, the "http" URI scheme
   (<xref target="http.uri"/>) indicates a default connection of TCP
   over IP, with a default TCP port of 80, but the client might be
   configured to use a proxy via some other connection, port, or protocol.
</t>
<t>
   HTTP implementations are expected to engage in connection management,
   which includes maintaining the state of current connections, 
   establishing a new connection or reusing an existing connection,
   processing messages received on a connection, detecting connection
   failures, and closing each connection.
   Most clients maintain multiple connections in parallel, including
   more than one connection per server endpoint.
   Most servers are designed to maintain thousands of concurrent connections,
   while controlling request queues to enable fair use and detect
   denial of service attacks.
</t>

<section title="Connection" anchor="header.connection">
  <iref primary="true" item="Connection header field" x:for-anchor=""/>
  <iref primary="true" item="close" x:for-anchor=""/>
  <x:anchor-alias value="Connection"/>
  <x:anchor-alias value="connection-option"/>
  <x:anchor-alias value="close"/>
<t>
   The "Connection" header field allows the sender to indicate desired
   control options for the current connection.  In order to avoid confusing
   downstream recipients, a proxy or gateway &MUST; remove or replace any
   received connection options before forwarding the message.
</t>
<t>
   When a header field aside from Connection is used to supply control
   information for or about the current connection, the sender &MUST; list
   the corresponding field-name within the "Connection" header field.
   A proxy or gateway &MUST; parse a received Connection
   header field before a message is forwarded and, for each
   connection-option in this field, remove any header field(s) from
   the message with the same name as the connection-option, and then
   remove the Connection header field itself (or replace it with the
   intermediary's own connection options for the forwarded message).
</t>
<t>
   Hence, the Connection header field provides a declarative way of
   distinguishing header fields that are only intended for the
   immediate recipient ("hop-by-hop") from those fields that are
   intended for all recipients on the chain ("end-to-end"), enabling the
   message to be self-descriptive and allowing future connection-specific
   extensions to be deployed without fear that they will be blindly
   forwarded by older intermediaries.
</t>
<t>
   The Connection header field's value has the following grammar:
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Connection"/><iref primary="true" item="Grammar" subitem="connection-option"/>
  <x:ref>Connection</x:ref>        = 1#<x:ref>connection-option</x:ref>
  <x:ref>connection-option</x:ref> = <x:ref>token</x:ref>
</artwork></figure>
<t>
   Connection options are case-insensitive.
</t>
<t>
   A sender &MUST-NOT; send a connection option corresponding to a header
   field that is intended for all recipients of the payload.
   For example, <x:ref>Cache-Control</x:ref> is never appropriate as a
   connection option (&header-cache-control;).
</t>
<t>
   The connection options do not have to correspond to a header field
   present in the message, since a connection-specific header field
   might not be needed if there are no parameters associated with that
   connection option.  Recipients that trigger certain connection
   behavior based on the presence of connection options &MUST; do so
   based on the presence of the connection-option rather than only the
   presence of the optional header field.  In other words, if the
   connection option is received as a header field but not indicated
   within the Connection field-value, then the recipient &MUST; ignore
   the connection-specific header field because it has likely been
   forwarded by an intermediary that is only partially conformant.
</t>
<t>
   When defining new connection options, specifications ought to
   carefully consider existing deployed header fields and ensure
   that the new connection option does not share the same name as
   an unrelated header field that might already be deployed.
   Defining a new connection option essentially reserves that potential
   field-name for carrying additional information related to the
   connection option, since it would be unwise for senders to use
   that field-name for anything else.
</t>
<t>
   The "<x:dfn>close</x:dfn>" connection option is defined for a
   sender to signal that this connection will be closed after completion of
   the response. For example,
</t>
<figure><artwork type="example">
  Connection: close
</artwork></figure>
<t>
   in either the request or the response header fields indicates that
   the connection &MUST; be closed after the current request/response
   is complete (<xref target="persistent.tear-down"/>).
</t>
<t>
   A client that does not support <x:ref>persistent connections</x:ref> &MUST;
   send the "close" connection option in every request message.
</t>
<t>
   A server that does not support <x:ref>persistent connections</x:ref> &MUST;
   send the "close" connection option in every response message that
   does not have a <x:ref>1xx (Informational)</x:ref> status code.
</t>
</section>

<section title="Establishment" anchor="persistent.establishment">
<t>
   It is beyond the scope of this specification to describe how connections
   are established via various transport or session-layer protocols.
   Each connection applies to only one transport link.
</t>
</section>

<section title="Persistence" anchor="persistent.connections">
   <x:anchor-alias value="persistent connections"/>
<t>
   HTTP/1.1 defaults to the use of "<x:dfn>persistent connections</x:dfn>",
   allowing multiple requests and responses to be carried over a single
   connection. The "<x:ref>close</x:ref>" connection-option is used to signal
   that a connection will not persist after the current request/response.
   HTTP implementations &SHOULD; support persistent connections.
</t>
<t>
   A recipient determines whether a connection is persistent or not based on
   the most recently received message's protocol version and
   <x:ref>Connection</x:ref> header field (if any):
   <list style="symbols">
     <t>If the <x:ref>close</x:ref> connection option is present, the
        connection will not persist after the current response; else,</t>
     <t>If the received protocol is HTTP/1.1 (or later), the connection will
        persist after the current response; else,</t>
     <t>If the received protocol is HTTP/1.0, the "keep-alive"
        connection option is present, the recipient is not a proxy, and
        the recipient wishes to honor the HTTP/1.0 "keep-alive" mechanism,
        the connection will persist after the current response; otherwise,</t>
     <t>The connection will close after the current response.</t>
   </list>
</t>
<t>
   A server &MAY; assume that an HTTP/1.1 client intends to maintain a
   persistent connection until a <x:ref>close</x:ref> connection option
   is received in a request.
</t>
<t>
   A client &MAY; reuse a persistent connection until it sends or receives
   a <x:ref>close</x:ref> connection option or receives an HTTP/1.0 response
   without a "keep-alive" connection option.
</t>
<t>
   In order to remain persistent, all messages on a connection &MUST;
   have a self-defined message length (i.e., one not defined by closure
   of the connection), as described in <xref target="message.body"/>.
   A server &MUST; read the entire request message body or close
   the connection after sending its response, since otherwise the
   remaining data on a persistent connection would be misinterpreted
   as the next request.  Likewise,
   a client &MUST; read the entire response message body if it intends
   to reuse the same connection for a subsequent request.
</t>
<t>
   A proxy server &MUST-NOT; maintain a persistent connection with an
   HTTP/1.0 client (see <xref x:sec="19.7.1" x:fmt="of" target="RFC2068"/> for
   information and discussion of the problems with the Keep-Alive header field
   implemented by many HTTP/1.0 clients).
</t>
<t>
   Clients and servers &SHOULD-NOT; assume that a persistent connection is
   maintained for HTTP versions less than 1.1 unless it is explicitly
   signaled.
   See <xref target="compatibility.with.http.1.0.persistent.connections"/>
   for more information on backward compatibility with HTTP/1.0 clients.
</t>

<section title="Retrying Requests" anchor="persistent.retrying.requests">
<t>
   Connections can be closed at any time, with or without intention.
   Implementations ought to anticipate the need to recover
   from asynchronous close events.
</t>
<t>
   When an inbound connection is closed prematurely, a client &MAY; open a new
   connection and automatically retransmit an aborted sequence of requests if
   all of those requests have idempotent methods (&idempotent-methods;).
   A proxy &MUST-NOT; automatically retry non-idempotent requests.
</t>
<t>
   A user agent &MUST-NOT; automatically retry a request with a non-idempotent
   method unless it has some means to know that the request semantics are
   actually idempotent, regardless of the method, or some means to detect that
   the original request was never applied. For example, a user agent that
   knows (through design or configuration) that a POST request to a given
   resource is safe can repeat that request automatically.
   Likewise, a user agent designed specifically to operate on a version
   control repository might be able to recover from partial failure conditions
   by checking the target resource revision(s) after a failed connection,
   reverting or fixing any changes that were partially applied, and then
   automatically retrying the requests that failed.
</t>
<t>
   An automatic retry &SHOULD-NOT; be repeated if it fails.
</t>
</section>

<section title="Pipelining" anchor="pipelining">
   <x:anchor-alias value="pipeline"/>
<t>
   A client that supports persistent connections &MAY; "<x:dfn>pipeline</x:dfn>"
   its requests (i.e., send multiple requests without waiting for each
   response). A server &MAY; process a sequence of pipelined requests in
   parallel if they all have safe methods (&safe-methods;), but &MUST; send
   the corresponding responses in the same order that the requests were
   received.
</t>
<t>
   A client that pipelines requests &MUST; be prepared to retry those
   requests if the connection closes before it receives all of the
   corresponding responses. A client that assumes a persistent connection and
   pipelines immediately after connection establishment &MUST-NOT; pipeline
   on a retry connection until it knows the connection is persistent.
</t>
<t>
   Idempotent methods (&idempotent-methods;) are significant to pipelining
   because they can be automatically retried after a connection failure.
   A user agent &SHOULD-NOT; pipeline requests after a non-idempotent method
   until the final response status code for that method has been received,
   unless the user agent has a means to detect and recover from partial
   failure conditions involving the pipelined sequence.
</t>
<t>
   An intermediary that receives pipelined requests &MAY; pipeline those
   requests when forwarding them inbound, since it can rely on the outbound
   user agent(s) to determine what requests can be safely pipelined. If the
   inbound connection fails before receiving a response, the pipelining
   intermediary &MAY; attempt to retry a sequence of requests that have yet
   to receive a response if the requests all have idempotent methods;
   otherwise, the pipelining intermediary &SHOULD; forward any received
   responses and then close the corresponding outbound connection(s) so that
   the outbound user agent(s) can recover accordingly.
</t>
</section>
</section>
   
<section title="Concurrency" anchor="persistent.concurrency">
<t>
   Clients &SHOULD; limit the number of simultaneous
   connections that they maintain to a given server.
</t>
<t>
   Previous revisions of HTTP gave a specific number of connections as a
   ceiling, but this was found to be impractical for many applications. As a
   result, this specification does not mandate a particular maximum number of
   connections, but instead encourages clients to be conservative when opening
   multiple connections.
</t>
<t>
   Multiple connections are typically used to avoid the "head-of-line
   blocking" problem, wherein a request that takes significant server-side
   processing and/or has a large payload blocks subsequent requests on the
   same connection. However, each connection consumes server resources.
   Furthermore, using multiple connections can cause undesirable side effects
   in congested networks. 
</t>
<t>
   Note that servers might reject traffic that they deem abusive, including an
   excessive number of connections from a client.
</t>
</section>

<section title="Failures and Time-outs" anchor="persistent.failures">
<t>
   Servers will usually have some time-out value beyond which they will
   no longer maintain an inactive connection. Proxy servers might make
   this a higher value since it is likely that the client will be making
   more connections through the same server. The use of persistent
   connections places no requirements on the length (or existence) of
   this time-out for either the client or the server.
</t>
<t>
   When a client or server wishes to time-out it &SHOULD; issue a graceful
   close on the transport connection. Clients and servers &SHOULD; both
   constantly watch for the other side of the transport close, and
   respond to it as appropriate. If a client or server does not detect
   the other side's close promptly it could cause unnecessary resource
   drain on the network.
</t>
<t>
   A client, server, or proxy &MAY; close the transport connection at any
   time. For example, a client might have started to send a new request
   at the same time that the server has decided to close the "idle"
   connection. From the server's point of view, the connection is being
   closed while it was idle, but from the client's point of view, a
   request is in progress.
</t>
<t>
   Servers &SHOULD; maintain persistent connections and allow the underlying
   transport's flow control mechanisms to resolve temporary overloads, rather
   than terminate connections with the expectation that clients will retry.
   The latter technique can exacerbate network congestion.
</t>
<t>
   A client sending a message body &SHOULD; monitor
   the network connection for an error response while it is transmitting
   the request. If the client sees an error response, it &SHOULD;
   immediately cease transmitting the body and close the connection.
</t>
</section>
   
<section title="Tear-down" anchor="persistent.tear-down">
  <iref primary="false" item="Connection header field" x:for-anchor=""/>
  <iref primary="false" item="close" x:for-anchor=""/>
<t>
   The <x:ref>Connection</x:ref> header field
   (<xref target="header.connection"/>) provides a "<x:ref>close</x:ref>"
   connection option that a sender &SHOULD; send when it wishes to close
   the connection after the current request/response pair.
</t>
<t>
   A client that sends a <x:ref>close</x:ref> connection option &MUST-NOT;
   send further requests on that connection (after the one containing
   <x:ref>close</x:ref>) and &MUST; close the connection after reading the
   final response message corresponding to this request.
</t>
<t>
   A server that receives a <x:ref>close</x:ref> connection option &MUST;
   initiate a close of the connection (see below) after it sends the
   final response to the request that contained <x:ref>close</x:ref>.
   The server &SHOULD; send a <x:ref>close</x:ref> connection option
   in its final response on that connection. The server &MUST-NOT; process
   any further requests received on that connection.
</t>
<t>
   A server that sends a <x:ref>close</x:ref> connection option &MUST;
   initiate a close of the connection (see below) after it sends the
   response containing <x:ref>close</x:ref>. The server &MUST-NOT; process
   any further requests received on that connection.
</t>
<t>
   A client that receives a <x:ref>close</x:ref> connection option &MUST;
   cease sending requests on that connection and close the connection
   after reading the response message containing the close; if additional
   pipelined requests had been sent on the connection, the client &SHOULD-NOT;
   assume that they will be processed by the server.
</t>
<t>
   If a server performs an immediate close of a TCP connection, there is a
   significant risk that the client will not be able to read the last HTTP
   response.  If the server receives additional data from the client on a
   fully-closed connection, such as another request that was sent by the
   client before receiving the server's response, the server's TCP stack will
   send a reset packet to the client; unfortunately, the reset packet might
   erase the client's unacknowledged input buffers before they can be read
   and interpreted by the client's HTTP parser.
</t>
<t>
   To avoid the TCP reset problem, servers typically close a connection in
   stages. First, the server performs a half-close by closing only the write
   side of the read/write connection. The server then continues to read from
   the connection until it receives a corresponding close by the client, or
   until the server is reasonably certain that its own TCP stack has received
   the client's acknowledgement of the packet(s) containing the server's last
   response. Finally, the server fully closes the connection.
</t>
<t>
   It is unknown whether the reset problem is exclusive to TCP or might also
   be found in other transport connection protocols.
</t>
</section>

<section title="Upgrade" anchor="header.upgrade">
  <iref primary="true" item="Upgrade header field" x:for-anchor=""/>
  <x:anchor-alias value="Upgrade"/>
  <x:anchor-alias value="protocol"/>
  <x:anchor-alias value="protocol-name"/>
  <x:anchor-alias value="protocol-version"/>
<t>
   The "Upgrade" header field is intended to provide a simple mechanism
   for transitioning from HTTP/1.1 to some other protocol on the same
   connection.  A client &MAY; send a list of protocols in the Upgrade
   header field of a request to invite the server to switch to one or
   more of those protocols, in order of descending preference, before sending
   the final response. A server &MAY; ignore a received Upgrade header field
   if it wishes to continue using the current protocol on that connection.
</t>
<figure><artwork type="abnf2616"><iref primary="true" item="Grammar" subitem="Upgrade"/>
  <x:ref>Upgrade</x:ref>          = 1#<x:ref>protocol</x:ref>

  <x:ref>protocol</x:ref>         = <x:ref>protocol-name</x:ref> ["/" <x:ref>protocol-version</x:ref>]
  <x:ref>protocol-name</x:ref>    = <x:ref>token</x:ref>
  <x:ref>protocol-version</x:ref> = <x:ref>token</x:ref>
</artwork></figure>
<t>
   A server that sends a <x:ref>101 (Switching Protocols)</x:ref> response
   &MUST; send an Upgrade header field to indicate the new protocol(s) to
   which the connection is being switched; if multiple protocol layers are
   being switched, the new protocols &MUST; be listed in layer-ascending
   order. A server &MUST-NOT; switch to a protocol that was not indicated by
   the client in the corresponding request's Upgrade header field.
   A server &MAY; choose to ignore the order of preference indicated by the
   client and select the new protocol(s) based on other factors, such as the
   nature of the request or the current load on the server.
</t>
<t>
   A server that sends a <x:ref>426 (Upgrade Required)</x:ref> response
   &MUST; send an Upgrade header field to indicate the acceptable protocols,
   in order of descending preference.
</t>
<t>
   A server &MAY; send an Upgrade header field in any other response to
   advertise that it implements support for upgrading to the listed protocols,
   in order of descending preference, when appropriate for a future request.
</t>
<figure><preamble>
   The following is a hypothetical example sent by a client:
</preamble><artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
GET /hello.txt HTTP/1.1
Host: www.example.com
Connection: upgrade
Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11

</artwork></figure>
<t>
   Upgrade cannot be used to insist on a protocol change; its acceptance and
   use by the server is optional. The capabilities and nature of the
   application-level communication after the protocol change is entirely
   dependent upon the new protocol(s) chosen, although the first action
   after changing the protocol &MUST; be a response to the initial HTTP
   request that contained the Upgrade header field.
</t>
<t>
   For example, if the Upgrade header field is received in a GET request
   and the server decides to switch protocols, it first responds
   with a <x:ref>101 (Switching Protocols)</x:ref> message in HTTP/1.1 and
   then immediately follows that with the new protocol's equivalent of a
   response to a GET on the target resource.  This allows a connection to be
   upgraded to protocols with the same semantics as HTTP without the
   latency cost of an additional round-trip.  A server &MUST-NOT; switch
   protocols unless the received message semantics can be honored by the new
   protocol; an OPTIONS request can be honored by any protocol.
</t>
<figure><preamble>
   The following is an example response to the above hypothetical request:
</preamble><artwork type="message/http; msgtype=&#34;response&#34;" x:indent-with="  ">
HTTP/1.1 101 Switching Protocols
Connection: upgrade
Upgrade: HTTP/2.0

[... data stream switches to HTTP/2.0 with an appropriate response
(as defined by new protocol) to the "GET /hello.txt" request ...]
</artwork></figure>
<t>
   When Upgrade is sent, the sender &MUST; also send a 
   <x:ref>Connection</x:ref> header field (<xref target="header.connection"/>)
   that contains an "upgrade" connection option, in order to prevent Upgrade
   from being accidentally forwarded by intermediaries that might not implement
   the listed protocols.  A server &MUST; ignore an Upgrade header field that
   is received in an HTTP/1.0 request.
</t>
<t>
   The Upgrade header field only applies to switching protocols on top of the
   existing connection; it cannot be used to switch the underlying connection
   (transport) protocol, nor to switch the existing communication to a
   different connection. For those purposes, it is more appropriate to use a
   <x:ref>3xx (Redirection)</x:ref> response (&status-3xx;).
</t>
<t>
   This specification only defines the protocol name "HTTP" for use by
   the family of Hypertext Transfer Protocols, as defined by the HTTP
   version rules of <xref target="http.version"/> and future updates to this
   specification. Additional tokens ought to be registered with IANA using the
   registration procedure defined in <xref target="upgrade.token.registry"/>.
</t>
</section>
</section>

<section title="IANA Considerations" anchor="IANA.considerations">

<section title="Header Field Registration" anchor="header.field.registration">
<t>
   HTTP header fields are registered within the Message Header Field Registry
   maintained at
   <eref target="http://www.iana.org/assignments/message-headers/message-header-index.html"/>.
</t>
<t>
   This document defines the following HTTP header fields, so their
   associated registry entries shall be updated according to the permanent
   registrations below (see <xref target="BCP90"/>):
</t>
<?BEGININC p1-messaging.iana-headers ?>
<!--AUTOGENERATED FROM extract-header-defs.xslt, do not edit manually-->
<texttable align="left" suppress-title="true" anchor="iana.header.registration.table">
   <ttcol>Header Field Name</ttcol>
   <ttcol>Protocol</ttcol>
   <ttcol>Status</ttcol>
   <ttcol>Reference</ttcol>

   <c>Connection</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.connection"/>
   </c>
   <c>Content-Length</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.content-length"/>
   </c>
   <c>Host</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.host"/>
   </c>
   <c>TE</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.te"/>
   </c>
   <c>Trailer</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.trailer"/>
   </c>
   <c>Transfer-Encoding</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.transfer-encoding"/>
   </c>
   <c>Upgrade</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.upgrade"/>
   </c>
   <c>Via</c>
   <c>http</c>
   <c>standard</c>
   <c>
      <xref target="header.via"/>
   </c>
</texttable>
<!--(END)-->
<?ENDINC p1-messaging.iana-headers ?>
<t>
   Furthermore, the header field-name "Close" shall be registered as
   "reserved", since using that name as an HTTP header field might
   conflict with the "close" connection option of the "<x:ref>Connection</x:ref>"
   header field (<xref target="header.connection"/>).
</t>
<texttable align="left" suppress-title="true">
   <ttcol>Header Field Name</ttcol>
   <ttcol>Protocol</ttcol>
   <ttcol>Status</ttcol>
   <ttcol>Reference</ttcol>

   <c>Close</c>
   <c>http</c>
   <c>reserved</c>
   <c>
      <xref target="header.field.registration"/>
   </c>
</texttable>
<t>
   The change controller is: "IETF (iesg@ietf.org) - Internet Engineering Task Force".
</t>
</section>

<section title="URI Scheme Registration" anchor="uri.scheme.registration">
<t>
   IANA maintains the registry of URI Schemes <xref target="BCP115"/> at
   <eref target="http://www.iana.org/assignments/uri-schemes.html"/>.
</t>
<t>
   This document defines the following URI schemes, so their
   associated registry entries shall be updated according to the permanent
   registrations below:
</t>
<texttable align="left" suppress-title="true">
   <ttcol>URI Scheme</ttcol>
   <ttcol>Description</ttcol>
   <ttcol>Reference</ttcol>

   <c>http</c>
   <c>Hypertext Transfer Protocol</c>
   <c><xref target="http.uri"/></c>

   <c>https</c>
   <c>Hypertext Transfer Protocol Secure</c>
   <c><xref target="https.uri"/></c>
</texttable>
</section>

<section title="Internet Media Type Registration" anchor="internet.media.type.http">
<t>
   This document serves as the specification for the Internet media types
   "message/http" and "application/http". The following is to be registered with
   IANA (see <xref target="BCP13"/>).
</t>
<section title="Internet Media Type message/http" anchor="internet.media.type.message.http">
<iref item="Media Type" subitem="message/http" primary="true"/>
<iref item="message/http Media Type" primary="true"/>
<t>
   The message/http type can be used to enclose a single HTTP request or
   response message, provided that it obeys the MIME restrictions for all
   "message" types regarding line length and encodings.
</t>
<t>
  <list style="hanging" x:indent="12em">
    <t hangText="Type name:">
      message
    </t>
    <t hangText="Subtype name:">
      http
    </t>
    <t hangText="Required parameters:">
      none
    </t>
    <t hangText="Optional parameters:">
      version, msgtype
      <list style="hanging">
        <t hangText="version:">
          The HTTP-version number of the enclosed message
          (e.g., "1.1"). If not present, the version can be
          determined from the first line of the body.
        </t>
        <t hangText="msgtype:">
          The message type &mdash; "request" or "response". If not
          present, the type can be determined from the first
          line of the body.
        </t>
      </list>
    </t>
    <t hangText="Encoding considerations:">
      only "7bit", "8bit", or "binary" are permitted
    </t>
    <t hangText="Security considerations:">
      none
    </t>
    <t hangText="Interoperability considerations:">
      none
    </t>
    <t hangText="Published specification:">
      This specification (see <xref target="internet.media.type.message.http"/>).
    </t>
    <t hangText="Applications that use this media type:">
    </t>
    <t hangText="Additional information:">
      <list style="hanging">
        <t hangText="Magic number(s):">none</t>
        <t hangText="File extension(s):">none</t>
        <t hangText="Macintosh file type code(s):">none</t>
      </list>
    </t>
    <t hangText="Person and email address to contact for further information:">
      See Authors Section.
    </t>
    <t hangText="Intended usage:">
      COMMON
    </t>
    <t hangText="Restrictions on usage:">
      none
    </t>
    <t hangText="Author:">
      See Authors Section.
    </t>
    <t hangText="Change controller:">
      IESG
    </t>
  </list>
</t>
</section>
<section title="Internet Media Type application/http" anchor="internet.media.type.application.http">
<iref item="Media Type" subitem="application/http" primary="true"/>
<iref item="application/http Media Type" primary="true"/>
<t>
   The application/http type can be used to enclose a pipeline of one or more
   HTTP request or response messages (not intermixed).
</t>
<t>
  <list style="hanging" x:indent="12em">
    <t hangText="Type name:">
      application
    </t>
    <t hangText="Subtype name:">
      http
    </t>
    <t hangText="Required parameters:">
      none
    </t>
    <t hangText="Optional parameters:">
      version, msgtype
      <list style="hanging">
        <t hangText="version:">
          The HTTP-version number of the enclosed messages
          (e.g., "1.1"). If not present, the version can be
          determined from the first line of the body.
        </t>
        <t hangText="msgtype:">
          The message type &mdash; "request" or "response". If not
          present, the type can be determined from the first
          line of the body.
        </t>
      </list>
    </t>
    <t hangText="Encoding considerations:">
      HTTP messages enclosed by this type
      are in "binary" format; use of an appropriate
      Content-Transfer-Encoding is required when
      transmitted via E-mail.
    </t>
    <t hangText="Security considerations:">
      none
    </t>
    <t hangText="Interoperability considerations:">
      none
    </t>
    <t hangText="Published specification:">
      This specification (see <xref target="internet.media.type.application.http"/>).
    </t>
    <t hangText="Applications that use this media type:">
    </t>
    <t hangText="Additional information:">
      <list style="hanging">
        <t hangText="Magic number(s):">none</t>
        <t hangText="File extension(s):">none</t>
        <t hangText="Macintosh file type code(s):">none</t>
      </list>
    </t>
    <t hangText="Person and email address to contact for further information:">
      See Authors Section.
    </t>
    <t hangText="Intended usage:">
      COMMON
    </t>
    <t hangText="Restrictions on usage:">
      none
    </t>
    <t hangText="Author:">
      See Authors Section.
    </t>
    <t hangText="Change controller:">
      IESG
    </t>
  </list>
</t>
</section>
</section>

<section title="Transfer Coding Registry" anchor="transfer.coding.registry">
<t>
   The HTTP Transfer Coding Registry defines the name space for transfer
   coding names. It is maintained at <eref target="http://www.iana.org/assignments/http-parameters"/>.
</t>

<section title="Procedure" anchor="transfer.coding.registry.procedure">
<t>
   Registrations &MUST; include the following fields:
   <list style="symbols">
     <t>Name</t>
     <t>Description</t>
     <t>Pointer to specification text</t>
   </list>
</t>
<t>
   Names of transfer codings &MUST-NOT; overlap with names of content codings
   (&content-codings;) unless the encoding transformation is identical, as
   is the case for the compression codings defined in
   <xref target="compression.codings"/>.
</t>
<t>
   Values to be added to this name space require IETF Review (see
   <xref target="RFC5226" x:fmt="of" x:sec="4.1"/>), and &MUST;
   conform to the purpose of transfer coding defined in this specification.
</t>
<t>
   Use of program names for the identification of encoding formats
   is not desirable and is discouraged for future encodings.
</t>
</section>

<section title="Registration" anchor="transfer.coding.registration">
<t>
   The HTTP Transfer Coding Registry shall be updated with the registrations
   below:
</t>
<texttable align="left" suppress-title="true" anchor="iana.transfer.coding.registration.table">
   <ttcol>Name</ttcol>
   <ttcol>Description</ttcol>
   <ttcol>Reference</ttcol>
   <c>chunked</c>
   <c>Transfer in a series of chunks</c>
   <c>
      <xref target="chunked.encoding"/>
   </c>
   <c>compress</c>
   <c>UNIX "compress" data format <xref target="Welch"/></c>
   <c>
      <xref target="compress.coding"/>
   </c>
   <c>deflate</c>
   <c>"deflate" compressed data (<xref target="RFC1951"/>) inside
   the "zlib" data format (<xref target="RFC1950"/>)
   </c>
   <c>
      <xref target="deflate.coding"/>
   </c>
   <c>gzip</c>
   <c>GZIP file format <xref target="RFC1952"/></c>
   <c>
      <xref target="gzip.coding"/>
   </c>
   <c>x-compress</c>
   <c>Deprecated (alias for compress)</c>
   <c>
      <xref target="compress.coding"/>
   </c>
   <c>x-gzip</c>
   <c>Deprecated (alias for gzip)</c>
   <c>
      <xref target="gzip.coding"/>
   </c>
</texttable>
</section>
</section>

<section title="Upgrade Token Registry" anchor="upgrade.token.registry">
<t>
   The HTTP Upgrade Token Registry defines the name space for protocol-name
   tokens used to identify protocols in the <x:ref>Upgrade</x:ref> header
   field. The registry is maintained at <eref target="http://www.iana.org/assignments/http-upgrade-tokens"/>.
</t>

<section title="Procedure" anchor="upgrade.token.registry.procedure">   
<t>
   Each registered protocol name is associated with contact information
   and an optional set of specifications that details how the connection
   will be processed after it has been upgraded.
</t>
<t>
   Registrations happen on a "First Come First Served" basis (see
   <xref target="RFC5226" x:sec="4.1" x:fmt="of"/>) and are subject to the
   following rules:
  <list style="numbers">
    <t>A protocol-name token, once registered, stays registered forever.</t>
    <t>The registration &MUST; name a responsible party for the
       registration.</t>
    <t>The registration &MUST; name a point of contact.</t>
    <t>The registration &MAY; name a set of specifications associated with
       that token. Such specifications need not be publicly available.</t>
    <t>The registration &SHOULD; name a set of expected "protocol-version"
       tokens associated with that token at the time of registration.</t>
    <t>The responsible party &MAY; change the registration at any time.
       The IANA will keep a record of all such changes, and make them
       available upon request.</t>
    <t>The IESG &MAY; reassign responsibility for a protocol token.
       This will normally only be used in the case when a
       responsible party cannot be contacted.</t>
  </list>
</t>
<t>
   This registration procedure for HTTP Upgrade Tokens replaces that
   previously defined in <xref target="RFC2817" x:fmt="of" x:sec="7.2"/>.
</t>
</section>

<section title="Upgrade Token Registration" anchor="upgrade.token.registration">
<t>
   The HTTP Upgrade Token Registry shall be updated with the registration
   below:
</t>
<texttable align="left" suppress-title="true">
   <ttcol>Value</ttcol>
   <ttcol>Description</ttcol>
   <ttcol>Expected Version Tokens</ttcol>
   <ttcol>Reference</ttcol>

   <c>HTTP</c>
   <c>Hypertext Transfer Protocol</c>
   <c>any DIGIT.DIGIT (e.g, "2.0")</c>
   <c><xref target="http.version"/></c>
</texttable>
<t>
   The responsible party is: "IETF (iesg@ietf.org) - Internet Engineering Task Force".
</t>
</section>
</section>

</section>

<section title="Security Considerations" anchor="security.considerations">
<t>
   This section is meant to inform developers, information providers, and
   users of known security concerns relevant to HTTP/1.1 message syntax,
   parsing, and routing.
</t>

<section title="DNS-related Attacks" anchor="dns.related.attacks">
<t>
   HTTP clients rely heavily on the Domain Name Service (DNS), and are thus
   generally prone to security attacks based on the deliberate misassociation
   of IP addresses and DNS names not protected by DNSSEC. Clients need to be
   cautious in assuming the validity of an IP number/DNS name association unless
   the response is protected by DNSSEC (<xref target="RFC4033"/>).
</t>
</section>

<section title="Intermediaries and Caching" anchor="attack.intermediaries">
<t>
   By their very nature, HTTP intermediaries are men-in-the-middle, and
   represent an opportunity for man-in-the-middle attacks. Compromise of
   the systems on which the intermediaries run can result in serious security
   and privacy problems. Intermediaries have access to security-related
   information, personal information about individual users and
   organizations, and proprietary information belonging to users and
   content providers. A compromised intermediary, or an intermediary
   implemented or configured without regard to security and privacy
   considerations, might be used in the commission of a wide range of
   potential attacks.
</t>
<t>
   Intermediaries that contain a shared cache are especially vulnerable
   to cache poisoning attacks.
</t>
<t>
   Implementers need to consider the privacy and security
   implications of their design and coding decisions, and of the
   configuration options they provide to operators (especially the
   default configuration).
</t>
<t>
   Users need to be aware that intermediaries are no more trustworthy than
   the people who run them; HTTP itself cannot solve this problem.
</t>
</section>

<section title="Buffer Overflows" anchor="attack.protocol.element.size.overflows">
<t>
   Because HTTP uses mostly textual, character-delimited fields, attackers can
   overflow buffers in implementations, and/or perform a Denial of Service
   against implementations that accept fields with unlimited lengths.
</t>
<t>
   To promote interoperability, this specification makes specific
   recommendations for minimum size limits on request-line
   (<xref target="request.line"/>)
   and blocks of header fields (<xref target="header.fields"/>). These are
   minimum recommendations, chosen to be supportable even by implementations
   with limited resources; it is expected that most implementations will
   choose substantially higher limits.
</t>
<t>
   This specification also provides a way for servers to reject messages that
   have request-targets that are too long (&status-414;) or request entities
   that are too large (&status-4xx;). Additional status codes related to
   capacity limits have been defined by extensions to HTTP
   <xref target="RFC6585"/>.
</t>
<t>
   Recipients &SHOULD; carefully limit the extent to which they read other
   fields, including (but not limited to) request methods, response status
   phrases, header field-names, and body chunks, so as to avoid denial of
   service attacks without impeding interoperability.
</t>
</section>

<section title="Message Integrity" anchor="message.integrity">
<t>
   HTTP does not define a specific mechanism for ensuring message integrity,
   instead relying on the error-detection ability of underlying transport
   protocols and the use of length or chunk-delimited framing to detect
   completeness. Additional integrity mechanisms, such as hash functions or
   digital signatures applied to the content, can be selectively added to
   messages via extensible metadata header fields. Historically, the lack of
   a single integrity mechanism has been justified by the informal nature of
   most HTTP communication.  However, the prevalence of HTTP as an information
   access mechanism has resulted in its increasing use within environments
   where verification of message integrity is crucial.
</t>
<t>
   User agents are encouraged to implement configurable means for detecting
   and reporting failures of message integrity such that those means can be
   enabled within environments for which integrity is necessary. For example,
   a browser being used to view medical history or drug interaction
   information needs to indicate to the user when such information is detected
   by the protocol to be incomplete, expired, or corrupted during transfer.
   Such mechanisms might be selectively enabled via user agent extensions or
   the presence of message integrity metadata in a response.
   At a minimum, user agents ought to provide some indication that allows a
   user to distinguish between a complete and incomplete response message
   (<xref target="incomplete.messages"/>) when such verification is desired.
</t>
</section>

<section title="Server Log Information" anchor="abuse.of.server.log.information">
<t>
   A server is in the position to save personal data about a user's requests
   over time, which might identify their reading patterns or subjects of
   interest.  In particular, log information gathered at an intermediary
   often contains a history of user agent interaction, across a multitude
   of sites, that can be traced to individual users.
</t>
<t>
   HTTP log information is confidential in nature; its handling is often
   constrained by laws and regulations.  Log information needs to be securely
   stored and appropriate guidelines followed for its analysis.
   Anonymization of personal information within individual entries helps,
   but is generally not sufficient to prevent real log traces from being
   re-identified based on correlation with other access characteristics.
   As such, access traces that are keyed to a specific client should not
   be published even if the key is pseudonymous.
</t>
<t>
   To minimize the risk of theft or accidental publication, log information
   should be purged of personally identifiable information, including
   user identifiers, IP addresses, and user-provided query parameters,
   as soon as that information is no longer necessary to support operational
   needs for security, auditing, or fraud control.
</t>
</section>
</section>

<section title="Acknowledgments" anchor="acks">
<t>
   This edition of HTTP/1.1 builds on the many contributions that went into
   <xref target="RFC1945" format="none">RFC 1945</xref>,
   <xref target="RFC2068" format="none">RFC 2068</xref>,
   <xref target="RFC2145" format="none">RFC 2145</xref>, and
   <xref target="RFC2616" format="none">RFC 2616</xref>, including 
   substantial contributions made by the previous authors, editors, and
   working group chairs: Tim Berners-Lee, Ari Luotonen, Roy T. Fielding,
   Henrik Frystyk Nielsen, Jim Gettys, Jeffrey C. Mogul, Larry Masinter,
   and Paul J. Leach. Mark Nottingham oversaw this effort as working group chair. 
</t>
<t>
   Since 1999, the following contributors have helped improve the HTTP
   specification by reporting bugs, asking smart questions, drafting or
   reviewing text, and evaluating open issues:
</t>
<?BEGININC acks ?>
<t>Adam Barth,
Adam Roach,
Addison Phillips,
Adrian Chadd,
Adrien W. de Croy,
Alan Ford,
Alan Ruttenberg,
Albert Lunde,
Alek Storm,
Alex Rousskov,
Alexandre Morgaut,
Alexey Melnikov,
Alisha Smith,
Amichai Rothman,
Amit Klein,
Amos Jeffries,
Andreas Maier,
Andreas Petersson,
Anil Sharma,
Anne van Kesteren,
Anthony Bryan,
Asbjorn Ulsberg,
Ashok Kumar,
Balachander Krishnamurthy,
Barry Leiba,
Ben Laurie,
Benjamin Carlyle,
Benjamin Niven-Jenkins,
Bil Corry,
Bill Burke,
Bjoern Hoehrmann,
Bob Scheifler,
Boris Zbarsky,
Brett Slatkin,
Brian Kell,
Brian McBarron,
Brian Pane,
Brian Raymor,
Brian Smith,
Bryce Nesbitt,
Cameron Heavon-Jones,
Carl Kugler,
Carsten Bormann,
Charles Fry,
Chris Newman,
Cyrus Daboo,
Dale Robert Anderson,
Dan Wing,
Dan Winship,
Daniel Stenberg,
Darrel Miller,
Dave Cridland,
Dave Crocker,
Dave Kristol,
Dave Thaler,
David Booth,
David Singer,
David W. Morris,
Diwakar Shetty,
Dmitry Kurochkin,
Drummond Reed,
Duane Wessels,
Edward Lee,
Eitan Adler,
Eliot Lear,
Eran Hammer-Lahav,
Eric D. Williams,
Eric J. Bowman,
Eric Lawrence,
Eric Rescorla,
Erik Aronesty,
Evan Prodromou,
Felix Geisendoerfer,
Florian Weimer,
Frank Ellermann,
Fred Akalin,
Fred Bohle,
Frederic Kayser,
Gabor Molnar,
Gabriel Montenegro,
Geoffrey Sneddon,
Gervase Markham,
Gili Tzabari,
Grahame Grieve,
Greg Wilkins,
Grzegorz Calkowski,
Harald Tveit Alvestrand,
Harry Halpin,
Helge Hess,
Henrik Nordstrom,
Henry S. Thompson,
Henry Story,
Herbert van de Sompel,
Herve Ruellan,
Howard Melman,
Hugo Haas,
Ian Fette,
Ian Hickson,
Ido Safruti,
Ilari Liusvaara,
Ilya Grigorik,
Ingo Struck,
J. Ross Nicoll,
James Cloos,
James H. Manger,
James Lacey,
James M. Snell,
Jamie Lokier,
Jan Algermissen,
Jeff Hodges (who came up with the term 'effective Request-URI'),
Jeff Pinner,
Jeff Walden,
Jim Luther,
Jitu Padhye,
Joe D. Williams,
Joe Gregorio,
Joe Orton,
John C. Klensin,
John C. Mallery,
John Cowan,
John Kemp,
John Panzer,
John Schneider,
John Stracke,
John Sullivan,
Jonas Sicking,
Jonathan A. Rees,
Jonathan Billington,
Jonathan Moore,
Jonathan Silvera,
Jordi Ros,
Joris Dobbelsteen,
Josh Cohen,
Julien Pierre,
Jungshik Shin,
Justin Chapweske,
Justin Erenkrantz,
Justin James,
Kalvinder Singh,
Karl Dubost,
Keith Hoffman,
Keith Moore,
Ken Murchison,
Koen Holtman,
Konstantin Voronkov,
Kris Zyp,
Lisa Dusseault,
Maciej Stachowiak,
Manu Sporny,
Marc Schneider,
Marc Slemko,
Mark Baker,
Mark Pauley,
Mark Watson,
Markus Isomaki,
Markus Lanthaler,
Martin J. Duerst,
Martin Musatov,
Martin Nilsson,
Martin Thomson,
Matt Lynch,
Matthew Cox,
Max Clark,
Michael Burrows,
Michael Hausenblas,
Michael Sweet,
Mike Amundsen,
Mike Belshe,
Mike Bishop,
Mike Kelly,
Mike Schinkel,
Miles Sabin,
Murray S. Kucherawy,
Mykyta Yevstifeyev,
Nathan Rixham,
Nicholas Shanks,
Nico Williams,
Nicolas Alvarez,
Nicolas Mailhot,
Noah Slater,
Osama Mazahir,
Pablo Castro,
Pat Hayes,
Patrick R. McManus,
Paul E. Jones,
Paul Hoffman,
Paul Marquess,
Peter Lepeska,
Peter Occil,
Peter Saint-Andre,
Peter Watkins,
Phil Archer,
Philippe Mougin,
Phillip Hallam-Baker,
Piotr Dobrogost,
Poul-Henning Kamp,
Preethi Natarajan,
Rajeev Bector,
Ray Polk,
Reto Bachmann-Gmuer,
Richard Cyganiak,
Robby Simpson,
Robert Brewer,
Robert Collins,
Robert Mattson,
Robert O'Callahan,
Robert Olofsson,
Robert Sayre,
Robert Siemer,
Robert de Wilde,
Roberto Javier Godoy,
Roberto Peon,
Roland Zink,
Ronny Widjaja,
S. Mike Dierken,
Salvatore Loreto,
Sam Johnston,
Sam Pullara,
Sam Ruby,
Scott Lawrence (who maintained the original issues list),
Sean B. Palmer,
Shane McCarron,
Shigeki Ohtsu,
Stefan Eissing,
Stefan Tilkov,
Stefanos Harhalakis,
Stephane Bortzmeyer,
Stephen Farrell,
Stephen Ludin,
Stuart Williams,
Subbu Allamaraju,
Sylvain Hellegouarch,
Tapan Divekar,
Tatsuya Hayashi,
Ted Hardie,
Thomas Broyer,
Thomas Fossati,
Thomas Maslen,
Thomas Nordin,
Thomas Roessler,
Tim Bray,
Tim Morgan,
Tim Olsen,
Tom Zhou,
Travis Snoozy,
Tyler Close,
Vincent Murphy,
Wenbo Zhu,
Werner Baumann,
Wilbur Streett,
Wilfredo Sanchez Vega,
William A. Rowe Jr.,
William Chan,
Willy Tarreau,
Xiaoshu Wang,
Yaron Goland,
Yngve Nysaeter Pettersen,
Yoav Nir,
Yogesh Bang,
Yutaka Oiwa,
Yves Lafon (long-time member of the editor team),
Zed A. Shaw, and 
Zhong Yu.
</t>
<?ENDINC acks ?>
<t>
   See <xref target="RFC2616" x:fmt="of" x:sec="16"/> for additional
   acknowledgements from prior revisions.
</t>
</section>

</middle>
<back>

<references title="Normative References">

<reference anchor="Part2">
  <front>
    <title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p2-semantics-&ID-VERSION;"/>
  <x:source href="draft-ietf-httpbis-p2-semantics-23.xml" basename="draft-ietf-httpbis-p2-semantics-23">
    <x:defines>1xx (Informational)</x:defines>
    <x:defines>1xx</x:defines>
    <x:defines>100 (Continue)</x:defines>
    <x:defines>101 (Switching Protocols)</x:defines>
    <x:defines>2xx (Successful)</x:defines>
    <x:defines>2xx</x:defines>
    <x:defines>200 (OK)</x:defines>
    <x:defines>203 (Non-Authoritative Information)</x:defines>
    <x:defines>204 (No Content)</x:defines>
    <x:defines>3xx (Redirection)</x:defines>
    <x:defines>3xx</x:defines>
    <x:defines>301 (Moved Permanently)</x:defines>
    <x:defines>4xx (Client Error)</x:defines>
    <x:defines>4xx</x:defines>
    <x:defines>400 (Bad Request)</x:defines>
    <x:defines>411 (Length Required)</x:defines>
    <x:defines>414 (URI Too Long)</x:defines>
    <x:defines>417 (Expectation Failed)</x:defines>
    <x:defines>426 (Upgrade Required)</x:defines>
    <x:defines>501 (Not Implemented)</x:defines>
    <x:defines>502 (Bad Gateway)</x:defines>
    <x:defines>505 (HTTP Version Not Supported)</x:defines>
    <x:defines>Allow</x:defines>
    <x:defines>Content-Encoding</x:defines>
    <x:defines>Content-Location</x:defines>
    <x:defines>Content-Type</x:defines>
    <x:defines>Date</x:defines>
    <x:defines>Expect</x:defines>
    <x:defines>Location</x:defines>
    <x:defines>Server</x:defines>
    <x:defines>User-Agent</x:defines>
  </x:source>
</reference>

<reference anchor="Part4">
  <front>
    <title>Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</title>
    <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;" />
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p4-conditional-&ID-VERSION;" />
  <x:source basename="draft-ietf-httpbis-p4-conditional-23" href="draft-ietf-httpbis-p4-conditional-23.xml">
    <x:defines>304 (Not Modified)</x:defines>
    <x:defines>ETag</x:defines>
    <x:defines>Last-Modified</x:defines>
  </x:source>
</reference>

<reference anchor="Part5">
  <front>
    <title>Hypertext Transfer Protocol (HTTP/1.1): Range Requests</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
      <organization abbrev="W3C">World Wide Web Consortium</organization>
      <address><email>ylafon@w3.org</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p5-range-&ID-VERSION;"/>
  <x:source href="draft-ietf-httpbis-p5-range-23.xml" basename="draft-ietf-httpbis-p5-range-23">
    <x:defines>Content-Range</x:defines>
  </x:source>
</reference>

<reference anchor="Part6">
  <front>
    <title>Hypertext Transfer Protocol (HTTP/1.1): Caching</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="M." surname="Nottingham" fullname="Mark Nottingham" role="editor">
      <organization>Akamai</organization>
      <address><email>mnot@mnot.net</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p6-cache-&ID-VERSION;"/>
  <x:source href="draft-ietf-httpbis-p6-cache-23.xml" basename="draft-ietf-httpbis-p6-cache-23">
    <x:defines>Cache-Control</x:defines>
    <x:defines>Expires</x:defines>
  </x:source>
</reference>

<reference anchor="Part7">
  <front>
    <title>Hypertext Transfer Protocol (HTTP/1.1): Authentication</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
      <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
      <address><email>fielding@gbiv.com</email></address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address><email>julian.reschke@greenbytes.de</email></address>
    </author>
    <date month="&ID-MONTH;" year="&ID-YEAR;"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p7-auth-&ID-VERSION;"/>
  <x:source href="draft-ietf-httpbis-p7-auth-23.xml" basename="draft-ietf-httpbis-p7-auth-23">
    <x:defines>Proxy-Authenticate</x:defines>
    <x:defines>Proxy-Authorization</x:defines>
  </x:source>
</reference>

<reference anchor="RFC5234">
  <front>
    <title abbrev="ABNF for Syntax Specifications">Augmented BNF for Syntax Specifications: ABNF</title>
    <author initials="D." surname="Crocker" fullname="Dave Crocker" role="editor">
      <organization>Brandenburg InternetWorking</organization>
      <address>
        <email>dcrocker@bbiw.net</email>
      </address>  
    </author>
    <author initials="P." surname="Overell" fullname="Paul Overell">
      <organization>THUS plc.</organization>
      <address>
        <email>paul.overell@thus.net</email>
      </address>
    </author>
    <date month="January" year="2008"/>
  </front>
  <seriesInfo name="STD" value="68"/>
  <seriesInfo name="RFC" value="5234"/>
</reference>

<reference anchor="RFC2119">
  <front>
    <title>Key words for use in RFCs to Indicate Requirement Levels</title>
    <author initials="S." surname="Bradner" fullname="Scott Bradner">
      <organization>Harvard University</organization>
      <address><email>sob@harvard.edu</email></address>
    </author>
    <date month="March" year="1997"/>
  </front>
  <seriesInfo name="BCP" value="14"/>
  <seriesInfo name="RFC" value="2119"/>
</reference>

<reference anchor="RFC3986">
 <front>
  <title abbrev='URI Generic Syntax'>Uniform Resource Identifier (URI): Generic Syntax</title>
  <author initials='T.' surname='Berners-Lee' fullname='Tim Berners-Lee'>
    <organization abbrev="W3C/MIT">World Wide Web Consortium</organization>
    <address>
       <email>timbl@w3.org</email>
       <uri>http://www.w3.org/People/Berners-Lee/</uri>
    </address>
  </author>
  <author initials='R.' surname='Fielding' fullname='Roy T. Fielding'>
    <organization abbrev="Day Software">Day Software</organization>
    <address>
      <email>fielding@gbiv.com</email>
      <uri>http://roy.gbiv.com/</uri>
    </address>
  </author>
  <author initials='L.' surname='Masinter' fullname='Larry Masinter'>
    <organization abbrev="Adobe Systems">Adobe Systems Incorporated</organization>
    <address>
      <email>LMM@acm.org</email>
      <uri>http://larry.masinter.net/</uri>
    </address>
  </author>
  <date month='January' year='2005'></date>
 </front>
 <seriesInfo name="STD" value="66"/>
 <seriesInfo name="RFC" value="3986"/>
</reference>

<reference anchor="RFC0793">
  <front>
    <title>Transmission Control Protocol</title>
    <author initials='J.' surname='Postel' fullname='Jon Postel'>
      <organization>University of Southern California (USC)/Information Sciences Institute</organization>
    </author>
    <date year='1981' month='September' />
  </front>
  <seriesInfo name='STD' value='7' />
  <seriesInfo name='RFC' value='793' />
</reference>

<reference anchor="USASCII">
  <front>
    <title>Coded Character Set -- 7-bit American Standard Code for Information Interchange</title>
    <author>
      <organization>American National Standards Institute</organization>
    </author>
    <date year="1986"/>
  </front>
  <seriesInfo name="ANSI" value="X3.4"/>
</reference>

<reference anchor="RFC1950">
  <front>
    <title>ZLIB Compressed Data Format Specification version 3.3</title>
    <author initials="L.P." surname="Deutsch" fullname="L. Peter Deutsch">
      <organization>Aladdin Enterprises</organization>
      <address><email>ghost@aladdin.com</email></address>
    </author>
    <author initials="J-L." surname="Gailly" fullname="Jean-Loup Gailly"/>
    <date month="May" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="1950"/>
  <!--<annotation>
    RFC 1950 is an Informational RFC, thus it might be less stable than
    this specification. On the other hand, this downward reference was 
    present since the publication of <xref target="RFC2068" x:fmt="none">RFC 2068</xref> in 1997,
    therefore it is unlikely to cause problems in practice. See also
    <xref target="BCP97"/>.
  </annotation>-->
</reference>

<reference anchor="RFC1951">
  <front>
    <title>DEFLATE Compressed Data Format Specification version 1.3</title>
    <author initials="P." surname="Deutsch" fullname="L. Peter Deutsch">
      <organization>Aladdin Enterprises</organization>
      <address><email>ghost@aladdin.com</email></address>
    </author>
    <date month="May" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="1951"/>
  <!--<annotation>
    RFC 1951 is an Informational RFC, thus it might be less stable than
    this specification. On the other hand, this downward reference was 
    present since the publication of <xref target="RFC2068" x:fmt="none">RFC 2068</xref> in 1997,
    therefore it is unlikely to cause problems in practice. See also
    <xref target="BCP97"/>.
  </annotation>-->
</reference>

<reference anchor="RFC1952">
  <front>
    <title>GZIP file format specification version 4.3</title>
    <author initials="P." surname="Deutsch" fullname="L. Peter Deutsch">
      <organization>Aladdin Enterprises</organization>
      <address><email>ghost@aladdin.com</email></address>
    </author>
    <author initials="J-L." surname="Gailly" fullname="Jean-Loup Gailly">
      <address><email>gzip@prep.ai.mit.edu</email></address>
    </author>
    <author initials="M." surname="Adler" fullname="Mark Adler">
      <address><email>madler@alumni.caltech.edu</email></address>
    </author>
    <author initials="L.P." surname="Deutsch" fullname="L. Peter Deutsch">
      <address><email>ghost@aladdin.com</email></address>
    </author>
    <author initials="G." surname="Randers-Pehrson" fullname="Glenn Randers-Pehrson">
      <address><email>randeg@alumni.rpi.edu</email></address>
    </author>
    <date month="May" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="1952"/>
  <!--<annotation>
    RFC 1952 is an Informational RFC, thus it might be less stable than
    this specification. On the other hand, this downward reference was 
    present since the publication of <xref target="RFC2068" x:fmt="none">RFC 2068</xref> in 1997,
    therefore it is unlikely to cause problems in practice. See also
    <xref target="BCP97"/>.
  </annotation>-->
</reference>

<reference anchor="Welch">
  <front>
    <title>A Technique for High Performance Data Compression</title>
    <author initials="T.A." surname="Welch" fullname="Terry A. Welch"/>
    <date month="June" year="1984"/>
  </front>
  <seriesInfo name="IEEE Computer" value="17(6)"/>
</reference>

</references>

<references title="Informative References">

<reference anchor="ISO-8859-1">
  <front>
    <title>
     Information technology -- 8-bit single-byte coded graphic character sets -- Part 1: Latin alphabet No. 1
    </title>
    <author>
      <organization>International Organization for Standardization</organization>
    </author>
    <date year="1998"/>
  </front>
  <seriesInfo name="ISO/IEC" value="8859-1:1998"/>
</reference>

<reference anchor='RFC1919'>
  <front>
    <title>Classical versus Transparent IP Proxies</title>
    <author initials='M.' surname='Chatel' fullname='Marc Chatel'>
      <address><email>mchatel@pax.eunet.ch</email></address>
    </author>
    <date year='1996' month='March' />
  </front>
  <seriesInfo name='RFC' value='1919' />
</reference>

<reference anchor="RFC1945">
  <front>
    <title abbrev="HTTP/1.0">Hypertext Transfer Protocol -- HTTP/1.0</title>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization>MIT, Laboratory for Computer Science</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <author initials="R.T." surname="Fielding" fullname="Roy T. Fielding">
      <organization>University of California, Irvine, Department of Information and Computer Science</organization>
      <address><email>fielding@ics.uci.edu</email></address>
    </author>
    <author initials="H.F." surname="Nielsen" fullname="Henrik Frystyk Nielsen">
      <organization>W3 Consortium, MIT Laboratory for Computer Science</organization>
      <address><email>frystyk@w3.org</email></address>
    </author>
    <date month="May" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="1945"/>
</reference>

<reference anchor="RFC2045">
  <front>
    <title abbrev="Internet Message Bodies">Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</title>
    <author initials="N." surname="Freed" fullname="Ned Freed">
      <organization>Innosoft International, Inc.</organization>
      <address><email>ned@innosoft.com</email></address>
    </author>
    <author initials="N.S." surname="Borenstein" fullname="Nathaniel S. Borenstein">
      <organization>First Virtual Holdings</organization>
      <address><email>nsb@nsb.fv.com</email></address>
    </author>
    <date month="November" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="2045"/>
</reference>

<reference anchor="RFC2047">
  <front>
    <title abbrev="Message Header Extensions">MIME (Multipurpose Internet Mail Extensions) Part Three: Message Header Extensions for Non-ASCII Text</title>
    <author initials="K." surname="Moore" fullname="Keith Moore">
      <organization>University of Tennessee</organization>
      <address><email>moore@cs.utk.edu</email></address>
    </author>
    <date month="November" year="1996"/>
  </front>
  <seriesInfo name="RFC" value="2047"/>
</reference>

<reference anchor="RFC2068">
  <front>
    <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
    <author initials="R." surname="Fielding" fullname="Roy T. Fielding">
      <organization>University of California, Irvine, Department of Information and Computer Science</organization>
      <address><email>fielding@ics.uci.edu</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>jg@w3.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization>Digital Equipment Corporation, Western Research Laboratory</organization>
      <address><email>mogul@wrl.dec.com</email></address>
    </author>
    <author initials="H." surname="Nielsen" fullname="Henrik Frystyk Nielsen">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>frystyk@w3.org</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <date month="January" year="1997"/>
  </front>
  <seriesInfo name="RFC" value="2068"/>
</reference>

<reference anchor="RFC2145">
  <front>
    <title abbrev="HTTP Version Numbers">Use and Interpretation of HTTP Version Numbers</title>
    <author initials="J.C." surname="Mogul" fullname="Jeffrey C. Mogul">
      <organization>Western Research Laboratory</organization>
      <address><email>mogul@wrl.dec.com</email></address>
    </author>
    <author initials="R.T." surname="Fielding" fullname="Roy T. Fielding">
      <organization>Department of Information and Computer Science</organization>
      <address><email>fielding@ics.uci.edu</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="Jim Gettys">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>jg@w3.org</email></address>
    </author>
    <author initials="H.F." surname="Nielsen" fullname="Henrik Frystyk Nielsen">
      <organization>W3 Consortium</organization>
      <address><email>frystyk@w3.org</email></address>
    </author>
    <date month="May" year="1997"/>
  </front>
  <seriesInfo name="RFC" value="2145"/>
</reference>

<reference anchor="RFC2616">
  <front>
    <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
    <author initials="R." surname="Fielding" fullname="R. Fielding">
      <organization>University of California, Irvine</organization>
      <address><email>fielding@ics.uci.edu</email></address>
    </author>
    <author initials="J." surname="Gettys" fullname="J. Gettys">
      <organization>W3C</organization>
      <address><email>jg@w3.org</email></address>
    </author>
    <author initials="J." surname="Mogul" fullname="J. Mogul">
      <organization>Compaq Computer Corporation</organization>
      <address><email>mogul@wrl.dec.com</email></address>
    </author>
    <author initials="H." surname="Frystyk" fullname="H. Frystyk">
      <organization>MIT Laboratory for Computer Science</organization>
      <address><email>frystyk@w3.org</email></address>
    </author>
    <author initials="L." surname="Masinter" fullname="L. Masinter">
      <organization>Xerox Corporation</organization>
      <address><email>masinter@parc.xerox.com</email></address>
    </author>
    <author initials="P." surname="Leach" fullname="P. Leach">
      <organization>Microsoft Corporation</organization>
      <address><email>paulle@microsoft.com</email></address>
    </author>
    <author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee">
      <organization>W3C</organization>
      <address><email>timbl@w3.org</email></address>
    </author>
    <date month="June" year="1999"/>
  </front>
  <seriesInfo name="RFC" value="2616"/>
</reference>

<reference anchor='RFC2817'>
  <front>
    <title>Upgrading to TLS Within HTTP/1.1</title>
    <author initials='R.' surname='Khare' fullname='R. Khare'>
      <organization>4K Associates / UC Irvine</organization>
      <address><email>rohit@4K-associates.com</email></address>
    </author>
    <author initials='S.' surname='Lawrence' fullname='S. Lawrence'>
      <organization>Agranat Systems, Inc.</organization>
      <address><email>lawrence@agranat.com</email></address>
    </author>
    <date year='2000' month='May' />
  </front>
  <seriesInfo name='RFC' value='2817' />
</reference>

<reference anchor='RFC2818'>
  <front>
    <title>HTTP Over TLS</title>
    <author initials='E.' surname='Rescorla' fullname='Eric Rescorla'>
      <organization>RTFM, Inc.</organization>
      <address><email>ekr@rtfm.com</email></address>
    </author>
    <date year='2000' month='May' />
  </front>
  <seriesInfo name='RFC' value='2818' />
</reference>

<reference anchor='RFC3040'>
  <front>
    <title>Internet Web Replication and Caching Taxonomy</title>
    <author initials='I.' surname='Cooper' fullname='I. Cooper'>
      <organization>Equinix, Inc.</organization>
    </author>
    <author initials='I.' surname='Melve' fullname='I. Melve'>
      <organization>UNINETT</organization>
    </author>
    <author initials='G.' surname='Tomlinson' fullname='G. Tomlinson'>
      <organization>CacheFlow Inc.</organization>
    </author>
    <date year='2001' month='January' />
  </front>
  <seriesInfo name='RFC' value='3040' />
</reference>

<reference anchor='BCP90'>
  <front>
    <title>Registration Procedures for Message Header Fields</title>
    <author initials='G.' surname='Klyne' fullname='G. Klyne'>
      <organization>Nine by Nine</organization>
      <address><email>GK-IETF@ninebynine.org</email></address>
    </author>
    <author initials='M.' surname='Nottingham' fullname='M. Nottingham'>
      <organization>BEA Systems</organization>
      <address><email>mnot@pobox.com</email></address>
    </author>
    <author initials='J.' surname='Mogul' fullname='J. Mogul'>
      <organization>HP Labs</organization>
      <address><email>JeffMogul@acm.org</email></address>
    </author>
    <date year='2004' month='September' />
  </front>
  <seriesInfo name='BCP' value='90' />
  <seriesInfo name='RFC' value='3864' />
</reference>

<reference anchor='RFC4033'>
  <front>
    <title>DNS Security Introduction and Requirements</title>
    <author initials='R.' surname='Arends' fullname='R. Arends'/>
    <author initials='R.' surname='Austein' fullname='R. Austein'/>
    <author initials='M.' surname='Larson' fullname='M. Larson'/>
    <author initials='D.' surname='Massey' fullname='D. Massey'/>
    <author initials='S.' surname='Rose' fullname='S. Rose'/>
    <date year='2005' month='March' />
  </front>
  <seriesInfo name='RFC' value='4033' />
</reference>

<reference anchor="BCP13">
  <front>
    <title>Media Type Specifications and Registration Procedures</title>
    <author initials="N." surname="Freed" fullname="Ned Freed">
      <organization>Oracle</organization>
      <address>
        <email>ned+ietf@mrochek.com</email>
      </address>
    </author>
    <author initials="J." surname="Klensin" fullname="John C. Klensin">
      <address>
        <email>john+ietf@jck.com</email>
      </address>
    </author>
    <author initials="T." surname="Hansen" fullname="Tony Hansen">
      <organization>AT&amp;T Laboratories</organization>
      <address>
        <email>tony+mtsuffix@maillennium.att.com</email>
      </address>
    </author>
    <date year="2013" month="January"/>
  </front>
  <seriesInfo name="BCP" value="13"/>
  <seriesInfo name="RFC" value="6838"/>
</reference>

<reference anchor='BCP115'>
  <front>
    <title>Guidelines and Registration Procedures for New URI Schemes</title>
    <author initials='T.' surname='Hansen' fullname='T. Hansen'>
      <organization>AT&amp;T Laboratories</organization>
      <address>
        <email>tony+urireg@maillennium.att.com</email>
      </address>
    </author>
    <author initials='T.' surname='Hardie' fullname='T. Hardie'>
      <organization>Qualcomm, Inc.</organization>
      <address>
        <email>hardie@qualcomm.com</email>
      </address>
    </author>
    <author initials='L.' surname='Masinter' fullname='L. Masinter'>
      <organization>Adobe Systems</organization>
      <address>
        <email>LMM@acm.org</email>
      </address>
    </author>
    <date year='2006' month='February' />
  </front>
  <seriesInfo name='BCP' value='115' />
  <seriesInfo name='RFC' value='4395' />
</reference>

<reference anchor='RFC4559'>
  <front>
    <title>SPNEGO-based Kerberos and NTLM HTTP Authentication in Microsoft Windows</title>
    <author initials='K.' surname='Jaganathan' fullname='K. Jaganathan'/>
    <author initials='L.' surname='Zhu' fullname='L. Zhu'/>
    <author initials='J.' surname='Brezak' fullname='J. Brezak'/>
    <date year='2006' month='June' />
  </front>
  <seriesInfo name='RFC' value='4559' />
</reference>

<reference anchor='RFC5226'>
  <front>
    <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
    <author initials='T.' surname='Narten' fullname='T. Narten'>
      <organization>IBM</organization>
      <address><email>narten@us.ibm.com</email></address>
    </author>
    <author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'>
      <organization>Google</organization>
      <address><email>Harald@Alvestrand.no</email></address>
    </author>
    <date year='2008' month='May' />
  </front>
  <seriesInfo name='BCP' value='26' />
  <seriesInfo name='RFC' value='5226' />
</reference>

<reference anchor='RFC5246'>
   <front>
      <title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
      <author initials='T.' surname='Dierks' fullname='T. Dierks'>
         <organization />
      </author>
      <author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
         <organization>RTFM, Inc.</organization>
      </author>
      <date year='2008' month='August' />
   </front>
   <seriesInfo name='RFC' value='5246' />
</reference>

<reference anchor="RFC5322">
  <front>
    <title>Internet Message Format</title>
    <author initials="P." surname="Resnick" fullname="P. Resnick">
      <organization>Qualcomm Incorporated</organization>
    </author>
    <date year="2008" month="October"/>
  </front> 
  <seriesInfo name="RFC" value="5322"/>
</reference>

<reference anchor="RFC6265">
  <front>
    <title>HTTP State Management Mechanism</title>
    <author initials="A." surname="Barth" fullname="Adam Barth">
      <organization abbrev="U.C. Berkeley">
        University of California, Berkeley
      </organization>
      <address><email>abarth@eecs.berkeley.edu</email></address>
    </author>
    <date year="2011" month="April" />
  </front>
  <seriesInfo name="RFC" value="6265"/>
</reference>

<reference anchor='RFC6585'>
  <front>
    <title>Additional HTTP Status Codes</title>
    <author initials='M.' surname='Nottingham' fullname='M. Nottingham'>
      <organization>Rackspace</organization>
    </author>
    <author initials='R.' surname='Fielding' fullname='R. Fielding'>
      <organization>Adobe</organization>
    </author>
    <date year='2012' month='April' />
   </front>
   <seriesInfo name='RFC' value='6585' />
</reference>

<!--<reference anchor='BCP97'>
  <front>
    <title>Handling Normative References to Standards-Track Documents</title>
    <author initials='J.' surname='Klensin' fullname='J. Klensin'>
      <address>
        <email>klensin+ietf@jck.com</email>
      </address>
    </author>
    <author initials='S.' surname='Hartman' fullname='S. Hartman'>
      <organization>MIT</organization>
      <address>
        <email>hartmans-ietf@mit.edu</email>
      </address>
    </author>
    <date year='2007' month='June' />
  </front>
  <seriesInfo name='BCP' value='97' />
  <seriesInfo name='RFC' value='4897' />
</reference>-->

<reference anchor="Kri2001" target="http://arxiv.org/abs/cs.SE/0105018">
  <front>
    <title>HTTP Cookies: Standards, Privacy, and Politics</title>
    <author initials="D." surname="Kristol" fullname="David M. Kristol"/>
    <date year="2001" month="November"/>
  </front>
  <seriesInfo name="ACM Transactions on Internet Technology" value="1(2)"/>
</reference>

</references>


<section title="HTTP Version History" anchor="compatibility">
<t>
   HTTP has been in use by the World-Wide Web global information initiative
   since 1990. The first version of HTTP, later referred to as HTTP/0.9,
   was a simple protocol for hypertext data transfer across the Internet
   with only a single request method (GET) and no metadata.
   HTTP/1.0, as defined by <xref target="RFC1945"/>, added a range of request
   methods and MIME-like messaging that could include metadata about the data
   transferred and modifiers on the request/response semantics. However,
   HTTP/1.0 did not sufficiently take into consideration the effects of
   hierarchical proxies, caching, the need for persistent connections, or
   name-based virtual hosts. The proliferation of incompletely-implemented
   applications calling themselves "HTTP/1.0" further necessitated a
   protocol version change in order for two communicating applications
   to determine each other's true capabilities.
</t>
<t>
   HTTP/1.1 remains compatible with HTTP/1.0 by including more stringent
   requirements that enable reliable implementations, adding only
   those new features that will either be safely ignored by an HTTP/1.0
   recipient or only sent when communicating with a party advertising
   conformance with HTTP/1.1.
</t>
<t>
   It is beyond the scope of a protocol specification to mandate
   conformance with previous versions. HTTP/1.1 was deliberately
   designed, however, to make supporting previous versions easy.
   We would expect a general-purpose HTTP/1.1 server to understand
   any valid request in the format of HTTP/1.0 and respond appropriately
   with an HTTP/1.1 message that only uses features understood (or
   safely ignored) by HTTP/1.0 clients.  Likewise, we would expect
   an HTTP/1.1 client to understand any valid HTTP/1.0 response.
</t>
<t>
   Since HTTP/0.9 did not support header fields in a request,
   there is no mechanism for it to support name-based virtual
   hosts (selection of resource by inspection of the <x:ref>Host</x:ref> header
   field).  Any server that implements name-based virtual hosts
   ought to disable support for HTTP/0.9.  Most requests that
   appear to be HTTP/0.9 are, in fact, badly constructed HTTP/1.x
   requests wherein a buggy client failed to properly encode
   linear whitespace found in a URI reference and placed in
   the request-target.
</t>

<section title="Changes from HTTP/1.0" anchor="changes.from.1.0">
<t>
   This section summarizes major differences between versions HTTP/1.0
   and HTTP/1.1.
</t>

<section title="Multi-homed Web Servers" anchor="changes.to.simplify.multi-homed.web.servers.and.conserve.ip.addresses">
<t>
   The requirements that clients and servers support the <x:ref>Host</x:ref>
   header field (<xref target="header.host"/>), report an error if it is
   missing from an HTTP/1.1 request, and accept absolute URIs (<xref target="request-target"/>)
   are among the most important changes defined by HTTP/1.1.
</t>
<t>
   Older HTTP/1.0 clients assumed a one-to-one relationship of IP
   addresses and servers; there was no other established mechanism for
   distinguishing the intended server of a request than the IP address
   to which that request was directed. The <x:ref>Host</x:ref> header field was
   introduced during the development of HTTP/1.1 and, though it was
   quickly implemented by most HTTP/1.0 browsers, additional requirements
   were placed on all HTTP/1.1 requests in order to ensure complete
   adoption.  At the time of this writing, most HTTP-based services
   are dependent upon the Host header field for targeting requests.
</t>
</section>

<section title="Keep-Alive Connections" anchor="compatibility.with.http.1.0.persistent.connections">
<t>
   In HTTP/1.0, each connection is established by the client prior to the
   request and closed by the server after sending the response. However, some
   implementations implement the explicitly negotiated ("Keep-Alive") version
   of persistent connections described in <xref x:sec="19.7.1" x:fmt="of"
   target="RFC2068"/>.
</t>
<t>
   Some clients and servers might wish to be compatible with these previous
   approaches to persistent connections, by explicitly negotiating for them
   with a "Connection: keep-alive" request header field. However, some
   experimental implementations of HTTP/1.0 persistent connections are faulty;
   for example, if an HTTP/1.0 proxy server doesn't understand
   <x:ref>Connection</x:ref>, it will erroneously forward that header field
   to the next inbound server, which would result in a hung connection.
</t>
<t>
   One attempted solution was the introduction of a Proxy-Connection header
   field, targeted specifically at proxies. In practice, this was also
   unworkable, because proxies are often deployed in multiple layers, bringing
   about the same problem discussed above.
</t>
<t>
   As a result, clients are encouraged not to send the Proxy-Connection header 
   field in any requests.
</t>
<t>
   Clients are also encouraged to consider the use of Connection: keep-alive
   in requests carefully; while they can enable persistent connections with
   HTTP/1.0 servers, clients using them will need to monitor the
   connection for "hung" requests (which indicate that the client ought stop
   sending the header field), and this mechanism ought not be used by clients
   at all when a proxy is being used.
</t>
</section>

<section title="Introduction of Transfer-Encoding" anchor="introduction.of.transfer-encoding">
<t>
   HTTP/1.1 introduces the <x:ref>Transfer-Encoding</x:ref> header field
   (<xref target="header.transfer-encoding"/>).
   Transfer codings need to be decoded prior to forwarding an HTTP message
   over a MIME-compliant protocol.
</t>
</section>

</section>

<section title="Changes from RFC 2616" anchor="changes.from.rfc.2616">
<t>
  HTTP's approach to error handling has been explained.
  (<xref target="conformance"/>)
</t>
<t>
  The expectation to support HTTP/0.9 requests has been removed.
</t>
<t>
  The term "Effective Request URI" has been introduced.
  (<xref target="effective.request.uri" />)
</t>
<t>
  HTTP messages can be (and often are) buffered by implementations; despite
  it sometimes being available as a stream, HTTP is fundamentally a
  message-oriented protocol.
  (<xref target="http.message" />)
</t>
<t>
  Minimum supported sizes for various protocol elements have been 
  suggested, to improve interoperability.
</t>
<t>
  Header fields that span multiple lines ("line folding") are deprecated.
  (<xref target="field.parsing" />)
</t>
<t>
  The HTTP-version ABNF production has been clarified to be case-sensitive.
  Additionally, version numbers has been restricted to single digits, due
  to the fact that implementations are known to handle multi-digit version
  numbers incorrectly.
  (<xref target="http.version"/>)
</t>
<t>
  The HTTPS URI scheme is now defined by this specification; previously,
  it was done in  <xref target="RFC2818" x:fmt="of" x:sec="2.4"/>.
  (<xref target="https.uri"/>)
</t>
<t>
  The HTTPS URI scheme implies end-to-end security.
  (<xref target="https.uri"/>)
</t>
<t>
  Userinfo (i.e., username and password) are now disallowed in HTTP and
  HTTPS URIs, because of security issues related to their transmission on the
  wire.
  (<xref target="http.uri" />)
</t>
<t>
  Invalid whitespace around field-names is now required to be rejected, 
  because accepting it represents a security vulnerability.
  (<xref target="header.fields"/>)
</t>
<t>
  The ABNF productions defining header fields now only list the field value.
  (<xref target="header.fields"/>)
</t>
<t>
  Rules about implicit linear whitespace between certain grammar productions
  have been removed; now whitespace is only allowed where specifically
  defined in the ABNF.
  (<xref target="whitespace"/>)
</t>
<t>  
  The NUL octet is no longer allowed in comment and quoted-string text, and
  handling of backslash-escaping in them has been clarified.
  (<xref target="field.components"/>)
</t>  
<t>
  The quoted-pair rule no longer allows escaping control characters other than
  HTAB.
  (<xref target="field.components"/>)
</t>
<t>
  Non-ASCII content in header fields and the reason phrase has been obsoleted
  and made opaque (the TEXT rule was removed). 
  (<xref target="field.components"/>)
</t>
<t>
  Bogus "<x:ref>Content-Length</x:ref>" header fields are now required to be
  handled as errors by recipients.
  (<xref target="header.content-length"/>)
</t>
<t>
  The "identity" transfer coding token has been removed.
  (Sections <xref format="counter" target="message.body"/> and
  <xref format="counter" target="transfer.codings"/>)
</t>
<t>
  The algorithm for determining the message body length has been clarified
  to indicate all of the special cases (e.g., driven by methods or status
  codes) that affect it, and that new protocol elements cannot define such
  special cases.
  (<xref target="message.body.length"/>)
</t>
<t>
  "multipart/byteranges" is no longer a way of determining message body length
  detection.
  (<xref target="message.body.length"/>)
</t>
<t>
  CONNECT is a new, special case in determining message body length.
  (<xref target="message.body.length"/>)
</t>
<t>
  Chunk length does not include the count of the octets in the
  chunk header and trailer.
  (<xref target="chunked.encoding"/>)
</t>
<t>
  Use of chunk extensions is deprecated, and line folding in them is 
  disallowed.
  (<xref target="chunked.encoding"/>)
</t>
<t>
  The segment + query components of RFC3986 have been used to define the
  request-target, instead of abs_path from RFC 1808.
  (<xref target="request-target"/>)
</t>
<t>
  The asterisk form of the request-target is only allowed in the OPTIONS
  method.
  (<xref target="request-target"/>)
</t>
<t>
  Exactly when "close" connection options have to be sent has been clarified.
  (<xref target="header.connection"/>)
</t>
<t>  
  "hop-by-hop" header fields are required to appear in the Connection header
  field; just because they're defined as hop-by-hop in this specification
  doesn't exempt them.
  (<xref target="header.connection"/>)
</t>
<t>
  The limit of two connections per server has been removed.
  (<xref target="persistent.connections"/>)
</t>
<t>
  An idempotent sequence of requests is no longer required to be retried.
  (<xref target="persistent.connections"/>)
</t>
<t>
  The requirement to retry requests under certain circumstances when the
  server prematurely closes the connection has been removed.
  (<xref target="persistent.connections"/>)
</t>
<t>
  Some extraneous requirements about when servers are allowed to close
  connections prematurely have been removed.
  (<xref target="persistent.connections"/>)
</t>
<t>
  The semantics of the <x:ref>Upgrade</x:ref> header field is now defined in
  responses other than 101 (this was incorporated from <xref
  target="RFC2817"/>).
  (<xref target="header.upgrade"/>)
</t>
<t>
  Registration of Transfer Codings now requires IETF Review
  (<xref target="transfer.coding.registry"/>)
</t>
<t>
  The meaning of the "deflate" content coding has been clarified.
  (<xref target="deflate.coding" />)
</t>
<t>
  This specification now defines the Upgrade Token Registry, previously
  defined in <xref target="RFC2817" x:fmt="of" x:sec="7.2"/>.
  (<xref target="upgrade.token.registry"/>)
</t>
<t>
  Issues with the Keep-Alive and Proxy-Connection header fields in requests
  are pointed out, with use of the latter being discouraged altogether.
  (<xref target="compatibility.with.http.1.0.persistent.connections" />)
</t>
<t>
  Empty list elements in list productions (e.g., a list header field containing 
  ", ,") have been deprecated.
  (<xref target="abnf.extension"/>)
</t>
</section>
</section>

<section title="ABNF list extension: #rule" anchor="abnf.extension">
<t>
  A #rule extension to the ABNF rules of <xref target="RFC5234"/> is used to
  improve readability in the definitions of some header field values.
</t>
<t>
  A construct "#" is defined, similar to "*", for defining comma-delimited
  lists of elements. The full form is "&lt;n&gt;#&lt;m&gt;element" indicating
  at least &lt;n&gt; and at most &lt;m&gt; elements, each separated by a single
  comma (",") and optional whitespace (OWS).   
</t>
<figure><preamble>
  Thus,
</preamble><artwork type="example">
  1#element =&gt; element *( OWS "," OWS element )
</artwork></figure>
<figure><preamble>
  and:
</preamble><artwork type="example">
  #element =&gt; [ 1#element ]
</artwork></figure>
<figure><preamble>
  and for n &gt;= 1 and m &gt; 1:
</preamble><artwork type="example">
  &lt;n&gt;#&lt;m&gt;element =&gt; element &lt;n-1&gt;*&lt;m-1&gt;( OWS "," OWS element )
</artwork></figure>
<t>
  For compatibility with legacy list rules, recipients &SHOULD; accept empty
  list elements. In other words, consumers would follow the list productions:
</t>
<figure><artwork type="example">
  #element =&gt; [ ( "," / element ) *( OWS "," [ OWS element ] ) ]
  
  1#element =&gt; *( "," OWS ) element *( OWS "," [ OWS element ] )
</artwork></figure>
<t>
  Note that empty elements do not contribute to the count of elements present,
  though.
</t>
<t>
  For example, given these ABNF productions: 
</t>
<figure><artwork type="example">
  example-list      = 1#example-list-elmt
  example-list-elmt = token ; see <xref target="field.components"/> 
</artwork></figure>
<t>
  Then these are valid values for example-list (not including the double
  quotes, which are present for delimitation only):
</t>
<figure><artwork type="example">
  "foo,bar"
  "foo ,bar,"
  "foo , ,bar,charlie   "
</artwork></figure>
<t>
  But these values would be invalid, as at least one non-empty element is
  required:
</t>
<figure><artwork type="example">
  ""
  ","
  ",   ,"
</artwork></figure>
<t>
  <xref target="collected.abnf"/> shows the collected ABNF, with the list rules
  expanded as explained above.
</t>
</section>

<?BEGININC p1-messaging.abnf-appendix ?>
<section xmlns:x="http://purl.org/net/xml2rfc/ext" title="Collected ABNF" anchor="collected.abnf">
<figure>
<artwork type="abnf" name="p1-messaging.parsed-abnf">
<x:ref>BWS</x:ref> = OWS

<x:ref>Connection</x:ref> = *( "," OWS ) connection-option *( OWS "," [ OWS
 connection-option ] )
<x:ref>Content-Length</x:ref> = 1*DIGIT

<x:ref>HTTP-message</x:ref> = start-line *( header-field CRLF ) CRLF [ message-body
 ]
<x:ref>HTTP-name</x:ref> = %x48.54.54.50 ; HTTP
<x:ref>HTTP-version</x:ref> = HTTP-name "/" DIGIT "." DIGIT
<x:ref>Host</x:ref> = uri-host [ ":" port ]

<x:ref>OWS</x:ref> = *( SP / HTAB )

<x:ref>RWS</x:ref> = 1*( SP / HTAB )

<x:ref>TE</x:ref> = [ ( "," / t-codings ) *( OWS "," [ OWS t-codings ] ) ]
<x:ref>Trailer</x:ref> = *( "," OWS ) field-name *( OWS "," [ OWS field-name ] )
<x:ref>Transfer-Encoding</x:ref> = *( "," OWS ) transfer-coding *( OWS "," [ OWS
 transfer-coding ] )

<x:ref>URI-reference</x:ref> = &lt;URI-reference, defined in [RFC3986], Section 4.1&gt;
<x:ref>Upgrade</x:ref> = *( "," OWS ) protocol *( OWS "," [ OWS protocol ] )

<x:ref>Via</x:ref> = *( "," OWS ) ( received-protocol RWS received-by [ RWS comment
 ] ) *( OWS "," [ OWS ( received-protocol RWS received-by [ RWS
 comment ] ) ] )

<x:ref>absolute-URI</x:ref> = &lt;absolute-URI, defined in [RFC3986], Section 4.3&gt;
<x:ref>absolute-form</x:ref> = absolute-URI
<x:ref>absolute-path</x:ref> = 1*( "/" segment )
<x:ref>asterisk-form</x:ref> = "*"
<x:ref>attribute</x:ref> = token
<x:ref>authority</x:ref> = &lt;authority, defined in [RFC3986], Section 3.2&gt;
<x:ref>authority-form</x:ref> = authority

<x:ref>chunk</x:ref> = chunk-size [ chunk-ext ] CRLF chunk-data CRLF
<x:ref>chunk-data</x:ref> = 1*OCTET
<x:ref>chunk-ext</x:ref> = *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
<x:ref>chunk-ext-name</x:ref> = token
<x:ref>chunk-ext-val</x:ref> = token / quoted-str-nf
<x:ref>chunk-size</x:ref> = 1*HEXDIG
<x:ref>chunked-body</x:ref> = *chunk last-chunk trailer-part CRLF
<x:ref>comment</x:ref> = "(" *( ctext / quoted-cpair / comment ) ")"
<x:ref>connection-option</x:ref> = token
<x:ref>ctext</x:ref> = HTAB / SP / %x21-27 ; '!'-'''
 / %x2A-5B ; '*'-'['
 / %x5D-7E ; ']'-'~'
 / obs-text

<x:ref>field-content</x:ref> = *( HTAB / SP / VCHAR / obs-text )
<x:ref>field-name</x:ref> = token
<x:ref>field-value</x:ref> = *( field-content / obs-fold )
<x:ref>fragment</x:ref> = &lt;fragment, defined in [RFC3986], Section 3.5&gt;

<x:ref>header-field</x:ref> = field-name ":" OWS field-value OWS
<x:ref>http-URI</x:ref> = "http://" authority path-abempty [ "?" query ] [ "#"
 fragment ]
<x:ref>https-URI</x:ref> = "https://" authority path-abempty [ "?" query ] [ "#"
 fragment ]

<x:ref>last-chunk</x:ref> = 1*"0" [ chunk-ext ] CRLF

<x:ref>message-body</x:ref> = *OCTET
<x:ref>method</x:ref> = token

<x:ref>obs-fold</x:ref> = CRLF ( SP / HTAB )
<x:ref>obs-text</x:ref> = %x80-FF
<x:ref>origin-form</x:ref> = absolute-path [ "?" query ]

<x:ref>partial-URI</x:ref> = relative-part [ "?" query ]
<x:ref>path-abempty</x:ref> = &lt;path-abempty, defined in [RFC3986], Section 3.3&gt;
<x:ref>port</x:ref> = &lt;port, defined in [RFC3986], Section 3.2.3&gt;
<x:ref>protocol</x:ref> = protocol-name [ "/" protocol-version ]
<x:ref>protocol-name</x:ref> = token
<x:ref>protocol-version</x:ref> = token
<x:ref>pseudonym</x:ref> = token

<x:ref>qdtext</x:ref> = HTAB / SP / "!" / %x23-5B ; '#'-'['
 / %x5D-7E ; ']'-'~'
 / obs-text
<x:ref>qdtext-nf</x:ref> = HTAB / SP / "!" / %x23-5B ; '#'-'['
 / %x5D-7E ; ']'-'~'
 / obs-text
<x:ref>query</x:ref> = &lt;query, defined in [RFC3986], Section 3.4&gt;
<x:ref>quoted-cpair</x:ref> = "\" ( HTAB / SP / VCHAR / obs-text )
<x:ref>quoted-pair</x:ref> = "\" ( HTAB / SP / VCHAR / obs-text )
<x:ref>quoted-str-nf</x:ref> = DQUOTE *( qdtext-nf / quoted-pair ) DQUOTE
<x:ref>quoted-string</x:ref> = DQUOTE *( qdtext / quoted-pair ) DQUOTE

<x:ref>rank</x:ref> = ( "0" [ "." *3DIGIT ] ) / ( "1" [ "." *3"0" ] )
<x:ref>reason-phrase</x:ref> = *( HTAB / SP / VCHAR / obs-text )
<x:ref>received-by</x:ref> = ( uri-host [ ":" port ] ) / pseudonym
<x:ref>received-protocol</x:ref> = [ protocol-name "/" ] protocol-version
<x:ref>relative-part</x:ref> = &lt;relative-part, defined in [RFC3986], Section 4.2&gt;
<x:ref>request-line</x:ref> = method SP request-target SP HTTP-version CRLF
<x:ref>request-target</x:ref> = origin-form / absolute-form / authority-form /
 asterisk-form

<x:ref>segment</x:ref> = &lt;segment, defined in [RFC3986], Section 3.3&gt;
<x:ref>special</x:ref> = "(" / ")" / "&lt;" / "&gt;" / "@" / "," / ";" / ":" / "\" /
 DQUOTE / "/" / "[" / "]" / "?" / "=" / "{" / "}"
<x:ref>start-line</x:ref> = request-line / status-line
<x:ref>status-code</x:ref> = 3DIGIT
<x:ref>status-line</x:ref> = HTTP-version SP status-code SP reason-phrase CRLF

<x:ref>t-codings</x:ref> = "trailers" / ( transfer-coding [ t-ranking ] )
<x:ref>t-ranking</x:ref> = OWS ";" OWS "q=" rank
<x:ref>tchar</x:ref> = "!" / "#" / "$" / "%" / "&amp;" / "'" / "*" / "+" / "-" / "." /
 "^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA
<x:ref>token</x:ref> = 1*tchar
<x:ref>trailer-part</x:ref> = *( header-field CRLF )
<x:ref>transfer-coding</x:ref> = "chunked" / "compress" / "deflate" / "gzip" /
 transfer-extension
<x:ref>transfer-extension</x:ref> = token *( OWS ";" OWS transfer-parameter )
<x:ref>transfer-parameter</x:ref> = attribute BWS "=" BWS value

<x:ref>uri-host</x:ref> = &lt;host, defined in [RFC3986], Section 3.2.2&gt;

<x:ref>value</x:ref> = word

<x:ref>word</x:ref> = token / quoted-string
</artwork>
</figure>
</section>
<?ENDINC p1-messaging.abnf-appendix ?>

<section title="Change Log (to be removed by RFC Editor before publication)" anchor="change.log">

<section title="Since RFC 2616">
<t>
  Changes up to the first Working Group Last Call draft are summarized
  in <eref target="http://trac.tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-21#appendix-D"/>.
</t>
</section>

<section title="Since draft-ietf-httpbis-p1-messaging-21" anchor="changes.since.21">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/128"/>:
      "Cite HTTPS URI scheme definition" (the spec now includes the HTTPs
      scheme definition and thus updates RFC 2818)
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/389"/>:
      "mention of 'proxies' in section about caches"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/390"/>:
      "use of ABNF terms from RFC 3986"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/391"/>:
      "transferring URIs with userinfo in payload"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/392"/>:
      "editorial improvements to message length definition"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/395"/>:
      "Connection header field MUST vs SHOULD"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/396"/>:
      "editorial improvements to persistent connections section"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/397"/>:
      "URI normalization vs empty path"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/408"/>:
      "p1 feedback"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/409"/>:
      "is parsing OBS-FOLD mandatory?"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/410"/>:
      "HTTPS and Shared Caching"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/411"/>:
      "Requirements for recipients of ws between start-line and first header field"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/412"/>:
      "SP and HT when being tolerant"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/414"/>:
      "Message Parsing Strictness"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/415"/>:
      "'Render'"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/418"/>:
      "No-Transform"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/419"/>:
      "p2 editorial feedback"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/420"/>:
      "Content-Length SHOULD be sent"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/431"/>:
      "origin-form does not allow path starting with "//""
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/433"/>:
      "ambiguity in part 1 example"
    </t>
  </list>
</t>
</section>

<section title="Since draft-ietf-httpbis-p1-messaging-22" anchor="changes.since.22">
<t>
  Closed issues:
  <list style="symbols">
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/435"/>:
      "Part1 should have a reference to TCP (RFC 793)"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/438"/>:
      "media type registration template issues"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/442"/>:
      "BWS" (vs conformance)
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/444"/>:
      "obs-fold language"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/445"/>:
      "Ordering in Upgrade"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/446"/>:
      "p1 editorial feedback"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/447"/>:
      "HTTP and TCP name delegation"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/449"/>:
      "Receiving a higher minor HTTP version number"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/451"/>:
      "HTTP(S) URIs and fragids"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/457"/>:
      "Registering x-gzip and x-deflate"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/460"/>:
      "Via and gateways"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/465"/>:
      "Mention 203 Non-Authoritative Information in p1"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/476"/>:
      "SHOULD and conformance"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/477"/>:
      "Pipelining language"
    </t>
    <t>
      <eref target="http://tools.ietf.org/wg/httpbis/trac/ticket/482"/>:
      "proxy handling of a really bad Content-Length"
    </t>
  </list>
</t>
</section>
</section>

</back>
</rfc>
