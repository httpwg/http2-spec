<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='lib/rfc2629.xslt' ?>

<!--<?rfc header="Documentation"?>-->
<!--?rfc private="RFC2629 through XSLT"?-->
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc linkmailto="no"?>
<?rfc editing="no"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-index="no" ?>
<!-- <?rfc topblock="no"?> -->
<!--<?rfc strict="no"?>-->

<rfc category="info"
    ipr="trust200902"
    docName="draft-ietf-httpbis-header-compression-01"
    >
    <front>
        <title abbrev="HPACK">HPACK</title>

        <author initials="R." surname="Peon" fullname="Roberto Peon">
            <organization>Google, Inc</organization>
            <address>
                <email>fenix@google.com</email>
            </address>
        </author>

        <author initials="H." surname="Ruellan" fullname="HervÃ© Ruellan">
            <organization>Canon CRF</organization>
            <address>
                <email>herve.ruellan@crf.canon.fr</email>
            </address>
        </author>

        <date month="July" year="2013"/>
        <area>Applications</area>
        <workgroup>HTTPbis Working Group</workgroup>
        <keyword>HTTP</keyword>
        <keyword>Header</keyword>
        <abstract>
            <t>
                This document describes HPACK, a format adapted to efficiently
                represent HTTP headers in the context of HTTP/2.0.
            </t>
        </abstract>
    </front>

    <middle>
        <section title="Introduction">

            <t>
                This document describes HPACK, a format adapted to efficiently
                represent HTTP headers in the context of HTTP/2.0.
            </t>
        </section>

        <section title="Overview" anchor="overview">
            <t>
                In HTTP/1.X, HTTP headers, which are necessary for the
                functioning of the protocol, are transmitted with no
                transformations. Unfortunately, the amount of redundancy in
                both the keys and the values of these headers is astonishingly
                high, and is the cause of increased latency on
                lower bandwidth links. This indicates that an alternate
                encoding for headers would be beneficial to latency, and that
                is what is proposed here.
            </t>

           <t>
                As shown by <xref target="SPDY">SPDY</xref>, Deflate
                compresses HTTP very effectively. However, the use of a
                compression scheme which allows for arbitrary matches against
                the previously encoded data (such as Deflate) exposes users to
                security issues.

                In particular, the compression of sensitive data, together
                with other data controlled by an attacker, may lead to leakage
                of that sensitive data, even when the resultant bytes are
                transmitted over an encrypted channel.
            </t>

            <t>
                Another consideration is that processing and memory costs of a
                compressor such as Deflate may also be too high for some
                classes of devices, for example when doing forward or reverse
                proxying.
            </t>

            <section title="Outline">
                <t>
                    The HTTP header representation described in this document
                    is based on indexing tables that store (name, value) pairs,
                    called header tables in the remainder of this document.
                    This scheme is believed to be safe for all known attacks
                    against the compression context today.  Header tables are
                    incrementally updated during the whole HTTP/2.0 session.
                    Two independent header tables are used during a HTTP/2.0
                    session, one for HTTP request headers and one for HTTP
                    response headers.
                </t>
                <t>
                    The encoder is responsible for deciding which headers to
                    insert as (name, value) pairs in the header table.  The
                    decoder then does exactly what the encoder prescribes,
                    ending in a state that exactly matches the encoder's
                    state.  This enables decoders to remain simple and
                    understand a wide variety of encoders.
                </t>
                <t>
                    As two consecutive sets of headers often have common
                    headers, each set of headers is coded as a difference from
                    the previous set of headers. The goal is to only encode
                    the changes (headers present in one of the set and not the
                    other) between the two sets of headers.
                </t>
                <t>
                    An example illustrating the use these different mechanisms
                    to represent headers is available in <xref
                        target="example"/>.
                </t>
            </section>
        </section>

        <section title="Header Encoding" anchor="header.encoding">
            <section title="Encoding Concepts" anchor="encoding.concepts">
                <t>
                    The encoding and decoding of headers relies on some
                    components and concepts. The set of components used form
                    an encoding context.
                    <list style="hanging">
                        <t hangText="Header Table:">
                            The header table (see <xref
                                target="header.table"/>) is a component used
                            to associate headers to index values.
                        </t>
                        <t hangText="Reference Set:">
                            The reference set (see <xref
                                target="reference.set"/>) is a component
                            containing a group of headers used as a reference
                            for the differential encoding of a new set of
                            headers.
                        </t>
                        <t hangText="Header Set:">
                            A header set is a group of headers that is encoded
                            jointly. A header set usually consists of all the
                            headers contained in an HTTP request or an HTTP
                            response.
                        </t>
                        <t hangText="Header Emission:">
                            When decoding a set of headers, some operations
                            emit a header (see <xref
                                target="header.emission"/>). An emitted header
                            is added to the set of headers. Once emitted, a
                            header can't be removed from the set of headers.
                        </t>
                        <t hangText="Header Representation:">
                            A header can be represented in encoded form either
                            as a literal or as an index (see <xref
                                target="header.representation"/>). The indexed
                            representation is based on the header table.
                        </t>
                    </list>
                </t>

                <section title="Encoding Context" anchor="encoding.context">
                    <t>
                        The set of components used to encode or decode a
                        header set form an encoding context. As such, an
                        encoding context contains a header table and a
                        reference set.
                    </t>
                    <t>
                        Using HTTP, messages are exchanged in the two
                        directions between a client and a server. As the
                        encoding of headers in each direction is independent
                        from the other direction, there is one encoding
                        context for each direction.
                    </t>
                    <t>
                        It should be noted that the headers contained in a
                        PUSH_PROMISE frame are encoded within the same context
                        as the headers contained in the HEADERS frame
                        corresponding to a response sent from the server to
                        the client.
                    </t>
                </section>

                <section title="Header Table" anchor="header.table">
                    <t>
                        A header table consists of an ordered list of (name,
                        value) pairs. The first entry of a header table is
                        assigned the index 0.
                    </t>
                    <t>
                        A header can be represented by an entry of the header
                        table if they match. A header and an entry match if
                        both their name and their value match. A header name
                        and an entry name match if they are equal using a
                        character-based, <spanx>case insensitive</spanx>
                        comparison (the case insensitive comparison is used
                        because HTTP header names are defined in a case
                        insensitive way). A header value and an entry value
                        match if they are equal using a character-based,
                        <spanx>case sensitive</spanx> comparison.
                    </t>
                    <t>
                        Generally, the header table will not contain duplicate
                        header (name, value) entries. However, implementations
                        MUST be prepared to accept duplicates without
                        signaling an error. If duplicates are added to the
                        table, they MUST be treated as distinct entries with
                        their own index positions.
                    </t>
                    <t>
                        Initialy, a header table contains a list of common
                        headers. Two initial lists of header are provided in
                        <xref target="initial.headers"/>. One list is for
                        headers transmitted from a client to a server, the
                        other for the reverse direction.
                    </t>
                    <t>
                        A header table is modified by either adding a new
                        entry at the end of the table, or by replacing an
                        existing entry.
                    </t>
                    <t>
                        The encoder decides how to update the header table and
                        as such can control how much memory is used by the
                        header table. To limit the memory requirements on the
                        decoder side, the header table size is bounded (see
                        the SETTINGS_MAX_BUFFER_SIZE in <xref
                            target="parameter.negotiation"/>).
                    </t>
                    <t>
                        The size of an entry is the sum of its name's length
                        in bytes (as defined in <xref
                            target="string.literal.representation" />), of its
                        value's length in bytes and of 32 bytes. The 32 bytes
                        are an accounting for the entry structure overhead.
                        For example, an entry structure using two 64-bits
                        pointers to reference the name and the value and the
                        entry, and two 64-bits integer for counting the number
                        of references to these name and value would use these
                        32 bytes.
                    </t>
                    <t>
                        The size of a header table is the sum of the sizes of
                        its entries.
                    </t>
                </section>

                <section title="Reference Set" anchor="reference.set">
                    <t>
                        A reference set is defined as an unordered set of
                        references to entries of the header table.
                    </t>
                    <t>
                        The initial reference set is the empty set.
                    </t>
                    <t>
                        The reference set is updated during the processing of
                        a set of headers.
                    </t>
                    <t>
                        Using the differential encoding, a header that is not
                        present in the reference set can be encoded either
                        with an indexed representation (if the header is
                        present in the header table), or with a literal
                        representation (if the header is not present in the
                        header table).
                    </t>
                    <t>
                        A header that is to be removed from the reference set
                        is encoded with an indexed representation.
                    </t>
                </section>

                <section title="Header Emission" anchor="header.emission">
                    <t>
                        The emission of header is the process of adding a
                        header to the current set of headers. Once an header
                        is emitted, it can't be removed from the current set
                        of headers.
                    </t>
                    <t>
                        The concept of header emission allows a decoder to
                        know when it can pass a header safely to a higher
                        level on the receiver side. This allows a decoder to
                        be implemented in a streaming way, and as such to only
                        keep in memory the header table and the reference set.
                        With such an implementation, the amount of memory used
                        by the decoder is bounded, even in presence of a very
                        large set of headers. The management of memory for
                        handling very large sets of headers can therefore be
                        deferred to the application.
                    </t>
                </section>

                <section title="Header Representation"
                    anchor="header.representation">
                    <t>
                        <list style="hanging">
                            <t hangText="Literal Representation:">
                                The literal representation defines a new
                                header. The header name is represented either
                                literally or as a reference to an entry of the
                                header table. The header value is represented
                                literally.
                            </t>
                            <t hangText="Indexed Representation:">
                                The indexed representation defines a header as
                                a reference in the header table.
                            </t>
                        </list>
                    </t>
                </section>
            </section>

            <section title="Header Set Processing"
                anchor="header.set.processing">

                <t>
                    To ensure a correct decoding of a set of headers, a
                    decoder MUST execute the following steps or equivalent
                    ones.
                </t>

                <section title="Header Representation Processing"
                    anchor="header.representation.processing">
                    <t>
                        An <spanx>indexed representation</spanx> corresponding
                        to an entry <spanx>not present</spanx> in the
                        reference set entails the following actions:
                        <list style="symbols">
                            <t>The header corresponding to the entry is
                                emitted.</t>
                            <t>The entry is added to the reference set.</t>
                        </list>
                    </t>
                    <t>
                        An <spanx>indexed representation</spanx> corresponding
                        to an entry <spanx>not present</spanx> in the
                        reference set entails the following actions:
                        <list style="symbols">
                            <t>The entry is removed from the reference set.</t>
                        </list>
                    </t>
                    <t>
                        A <spanx>literal representation</spanx> that is
                        <spanx>not added</spanx> to the header table entails
                        the following actions:
                        <list style="symbols">
                            <t>The header is emitted.</t>
                        </list>
                    </t>
                    <t>
                        A <spanx>literal representation</spanx> that is
                        <spanx>added</spanx> to the header table entails
                        the following actions:
                        <list style="symbols">
                            <t>The header is emitted.</t>
                            <t>The header is added to the header table, at a
                                location defined by the representation.</t>
                            <t>The new entry is added to the reference set.</t>
                        </list>
                    </t>
                </section>

                <section title="Header Table Management"
                    anchor="header.table.management">
                    <t>
                        The header table can be modified by either adding a
                        new entry to it or by replacing an existing one.
                        Before doing such a modification, it has to be ensured
                        that the header table size will stay lower than or
                        equal to the SETTINGS_MAX_BUFFER_SIZE limit (see <xref
                            target="parameter.negotiation"/>). If necessary,
                        some entries are removed from the header table.
                        Repeatedly, the first entry of the header table is
                        removed, until enough space is available for the
                        modification.
                    </t>
                    <t>
                        A consequence of removing one or more entries at the
                        beginning of the header table is that the remaining
                        entries are renumbered. The first entry of the header
                        table is always associated to the index 0.
                    </t>
                    <t>
                        When the modification is the replacement of an
                        existing entry, the replace entry is the one indicated
                        in the literal representation before any entry is
                        removed from the header table. If the entry to be
                        replaced is removed from the header table when
                        performing the size adjustment, the replacement entry
                        is inserted at the beginning of the header table.
                    </t>
                    <t>
                        The addition of a new entry with a size greater than
                        the SETTINGS_MAX_BUFFER_SIZE limit cause all the
                        entries from the header table to be dropped and the
                        new entry not to be added to the header table. The
                        replacement of an existing entry with a new entry with
                        a size greater than the SETTINGS_MAX_BUFFER_SIZE has
                        the same consequences.
                    </t>
                </section>

                <section title="">
                    <t><cref>TODO: emit remaining.</cref></t>
                </section>

            </section>

            <section title="Header Table Old">
                <t>
                    The header table is progressively updated based on headers
                    represented as literal.  Two update mechanisms are
                    defined:
                    <list style="symbols">
                        <t>
                            Incremental indexing: the represented header is
                            inserted at the end of the header table as a
                            (name, value) pair.  The inserted pair index is
                            set to the next free index in the table: it is
                            equal to the number of headers in the table before
                            its insertion.
                        </t>
                        <t>
                            Substitution indexing: the represented header
                            contains an index to an existing (name, value)
                            pair. The existing pair value is replaced by the
                            pair representing the new header.
                        </t>
                    </list>
                    Incremental and substitution indexing are optional.  If
                    none of them is selected in a header representation, the
                    header table is not updated.  In particular, no update
                    happens on the header table when processing an indexed
                    representation.
                </t>
            </section>

            <section title="Differential Coding Old">
                <t>
                    Then, the header representations are processed in their
                    order of occurrence in the frame.
                </t>
            </section>
        </section>

        <section title="Detailed Format" anchor="detailed.format">
            <section title="Header Blocks" anchor="header.blocks">
                <t>
                    A header block consists of a set of header fields, which
                    are name-value pairs. Each header field is encoded using
                    one of the header representation.
                </t>
            </section>

            <section title="Low-level representations" anchor="string.encoding">
                <section title="Integer representation" anchor="integer.representation">
                    <t>
                        Integers are used to represent name indexes, pair
                        indexes or string lengths.

                        The integer representation keeps byte-alignment as
                        much as possible as this allows various processing
                        optimizations as well as efficient use of DEFLATE.
                        For that purpose, an integer representation always
                        finishes at the end of a byte.
                    </t>
                    <t>
                        An integer is represented in two parts: a prefix that
                        fills the current byte and an optional list of bytes
                        that are used if the integer value does not fit in the
                        prefix.  The number of bits of the prefix (called N)
                        is a parameter of the integer representation.
                    </t>
                    <t>
                        The N-bit prefix allows filling the current byte.  If
                        the value is small enough (strictly less than 2^N-1),
                        it is encoded within the N-bit prefix.  Otherwise all
                        the bits of the prefix are set to 1 and the value is
                        encoded using an <eref
                            target="http://en.wikipedia.org/wiki/Variable-length_quantity">
                            unsigned variable length integer</eref>
                        representation.
                    </t>
                    <t>
                        The algorithm to represent an integer I is as follows:
                        <list style="numbers">
                            <t>If I &lt; 2^N - 1, encode I on N bits</t>
                            <t>Else, encode 2^N - 1 on N bits and do the
                                following steps:</t>
                            <t><list style="numbers">
                                <t>Set I to (I - (2^N - 1)) and Q to 1</t>
                                <t>While Q &gt; 0</t>
                                <t><list style="numbers">
                                    <t>Compute Q and R, quotient and remainder
                                        of I divided by 2^7</t>
                                    <t>If Q is strictly greater than 0, write
                                        one 1 bit; otherwise, write one 0
                                        bit</t>
                                    <t>Encode R on the next 7 bits</t>
                                    <t>I = Q</t>
                                </list></t>
                            </list></t>
                        </list>
                    </t>

                    <section title="Example 1: Encoding 10 using a 5-bit prefix"
                        anchor="integer.representation.example1">
                        <t>
                            The value 10 is to be encoded with a 5-bit prefix.
                            <list style="symbols">
                                <t>
                                    10 is less than 31 (= 2^5 - 1) and is
                                    represented using the 5-bit prefix.
                                </t>
                            </list>
                        </t>
                        <figure>
                            <artwork type="inline">
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| X | X | X | 0 | 1 | 0 | 1 | 0 |   10 stored on 5 bits
+---+---+---+---+---+---+---+---+
</artwork>
                        </figure>
                    </section>

                    <section title="Example 2: Encoding 1337 using a 5-bit prefix"
                        anchor="integer.representation.example2">
                        <t>
                            The value I=1337 is to be encoded with a 5-bit
                            prefix.
                            <list style="symbols">
                                <t>1337 is greater than 31 (= 2^5 - 1).</t>
                                <t><list style="symbols">
                                    <t>The 5-bit prefix is filled with its max
                                        value (31).</t>
                                </list></t>
                                <t>The value to represent on next bytes is I =
                                    1337 - (2^5 - 1) = 1306.</t>
                                <t><list style="symbols">
                                    <t>1306 = 128*10 + 26, i.e. Q=10 and
                                        R=26.</t>
                                    <t>Q is greater than 1, bit 8 is set to
                                        1.</t>
                                    <t>The remainder R=26 is encoded on next 7
                                        bits.</t>
                                    <t>I is replaced by the quotient Q=10.</t>
                                </list></t>
                                <t>The value to represent on next bytes is I =
                                    10.</t>
                                <t><list style="symbols">
                                    <t>10 = 128*0 + 10, i.e. Q=0 and R=10.</t>
                                    <t>Q is equal to 0, bit 16 is set to
                                        0.</t>
                                    <t>The remainder R=10 is encoded on next 7
                                        bits.</t>
                                    <t>I is replaced by the quotient Q=0.</t>
                                </list></t>
                                <t>The process ends.</t>
                            </list>

                        </t>
                        <figure>
                            <artwork type="inline">
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| X | X | X | 1 | 1 | 1 | 1 | 1 |   Prefix = 31
| 1 | 0 | 0 | 1 | 1 | 0 | 1 | 0 |   Q>=1, R=26
| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 |   Q=0 , R=10
+---+---+---+---+---+---+---+---+
</artwork>
                        </figure>
                    </section>
                </section>

                <section title="String literal representation" anchor="string.literal.representation">
                    <t>
                        Literal strings can represent header names or header
                        values.  They are encoded in two parts:
                        <list style="numbers">
                            <t>The string length, defined as the number of
                                bytes needed to store its UTF-8
                                representation, is represented as an integer
                                with a zero bits prefix.  If the string length
                                is strictly less than 128, it is represented
                                as one byte.
                            </t>
                            <t>
                                The string value represented as a list of
                                UTF-8 characters.
                            </t>
                        </list>
                    </t>
                </section>
            </section>

            <section title="Indexed Header Representation">
                <figure title="Indexed Header">
                    <artwork type="inline">
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 1 |        Index (7+)         |
+---+---------------------------+
</artwork>
                </figure>
                <t>
                    This representation starts with the '1' 1-bit pattern,
                    followed by the index of the matching pair, represented as
                    an integer with a 7-bit prefix.
                </t>
            </section>

            <section title="Literal Header Representation">
                <section title="Literal Header without Indexing">
                    <figure title="Literal Header without Indexing - Indexed Name">
                        <artwork type="inline">
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 1 | 1 |    Index (5+)     |
+---+---+---+-------------------+
|       Value Length (8+)       |
+-------------------------------+
| Value String (Length octets)  |
+-------------------------------+
</artwork>
                    </figure>
                    <figure title="Literal Header without Indexing - New Name">
                        <artwork type="inline">
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 1 | 1 |         0         |
+---+---+---+-------------------+
|       Name Length (8+)        |
+-------------------------------+
|  Name String (Length octets)  |
+-------------------------------+
|       Value Length (8+)       |
+-------------------------------+
| Value String (Length octets)  |
+-------------------------------+
</artwork>
                    </figure>
                    <t>
                        This representation, which does not involve updating
                        the header table, starts with the '011' 3-bit pattern.
                    </t>
                    <t>
                        If the header name matches the header name of a (name,
                        value) pair stored in the Header Table, the index of
                        the pair increased by one (index + 1) is represented
                        as an integer with a 5-bit prefix.  Note that if the
                        index is strictly below 31, one byte is used.
                    </t>
                    <t>
                        If the header name does not match a header name entry,
                        the value 0 is represented on 5 bits followed by the
                        header name, represented as a literal string.
                    </t>
                    <t>
                        Header name representation is followed by the header
                        value represented as a literal string as described in
                        <xref target="string.literal.representation" />.
                    </t>

                </section>

                <section title="Literal Header with Incremental Indexing">
                    <figure title="Literal Header with Incremental Indexing -
                        Indexed Name">
                        <artwork type="inline">
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 1 | 0 |    Index (5+)     |
+---+---+---+-------------------+
|       Value Length (8+)       |
+-------------------------------+
| Value String (Length octets)  |
+-------------------------------+
</artwork>
                    </figure>
                    <figure title="Literal Header with Incremental Indexing -
                        New Name">
                        <artwork type="inline">
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 1 | 0 |         0         |
+---+---+---+-------------------+
|       Name Length (8+)        |
+-------------------------------+
|  Name String (Length octets)  |
+-------------------------------+
|       Value Length (8+)       |
+-------------------------------+
| Value String (Length octets)  |
+-------------------------------+
</artwork>
                    </figure>
                    <t>
                        This representation starts with the '010' 3-bit
                        pattern.
                    </t>
                    <t>
                        If the header name matches the header name of a (name,
                        value) pair stored in the Header Table, the index of
                        the pair increased by one (index + 1) is represented
                        as an integer with a 5-bit prefix.  Note that if the
                        index is strictly below 31, one byte is used.
                    </t>
                    <t>
                        If the header name does not match a header name entry,
                        the value 0 is represented on 5 bits followed by the
                        header name, represented as a literal string.
                    </t>
                    <t>
                        Header name representation is followed by the header
                        value represented as a literal string as described in
                        <xref target="string.literal.representation" />.
                    </t>
                </section>
                <section title="Literal Header with Substitution Indexing">
                    <figure title="Literal Header with Substitution Indexing -
                        Indexed Name">
                        <artwork type="inline">
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 |      Index (6+)       |
+---+---+-----------------------+
|    Substituted Index (8+)     |
+-------------------------------+
|       Value Length (8+)       |
+-------------------------------+
| Value String (Length octets)  |
+-------------------------------+
</artwork>
                    </figure>
                    <figure title="Literal Header with Substitution Indexing -
                        New Name">
                        <artwork type="inline">
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 |           0           |
+---+---+-----------------------+
|       Name Length (8+)        |
+-------------------------------+
|  Name String (Length octets)  |
+-------------------------------+
|    Substituted Index (8+)     |
+-------------------------------+
|       Value Length (8+)       |
+-------------------------------+
| Value String (Length octets)  |
+-------------------------------+
</artwork>
                    </figure>
                    <t>
                        This representation starts with the '00' 2-bit
                        pattern.
                    </t>
                    <t>
                        If the header name matches the header name of a (name,
                        value) pair stored in the Header Table, the index of
                        the pair increased by one (index + 1) is represented
                        as an integer with a 6-bit prefix.  Note that if the
                        index is strictly below 62, one byte is used.
                    </t>
                    <t>
                        If the header name does not match a header name entry,
                        the value 0 is represented on 6 bits followed by the
                        header name, represented as a literal string.
                    </t>
                    <t>
                        The index of the substituted (name, value) pair is
                        inserted after the header name representation as a
                        0-bit prefix integer.
                    </t>
                    <t>
                        The index of the substituted pair MUST correspond to a
                        position in the header table containing a non-void
                        entry. An index for the substituted pair that
                        corresponds to empty position in the header table MUST
                        be treated as an error.
                    </t>
                    <t>
                        This index is followed by the header
                        value represented as a literal string as described in
                        <xref target="string.literal.representation" />.
                    </t>
                </section>
            </section>
        </section>

        <section anchor="parameter.negotiation" title="Parameter Negotiation">
            <t>
                A few parameters can be used to accomodate client and server
                processing and memory requirements.
                <cref>
                    These settings are currently not supported as they have
                    not been integrated in the main specification. Therefore,
                    the maximum buffer size for the header table is fixed at
                    4096 bytes.
                </cref>
                <list style="hanging">
                    <t hangText="SETTINGS_MAX_BUFFER_SIZE:">
                        Allows the sender to inform the remote endpoint of the
                        maximum size it accepts for the header table.
                        <vspace blankLines="0"/>
                        The default value is 4096 bytes.
                        <vspace blankLines="0"/>
                        <cref>Is this default value OK? Do we need a maximum size? Do we want to allow infinite buffer?</cref>
                        <vspace blankLines="0"/>
                        When the remote endpoint receives a SETTINGS frame
                        containing a SETTINGS_MAX_BUFFER_SIZE setting with a
                        value smaller than the one currently in use, it MUST
                        send as soon as possible a HEADER frame with a stream
                        identifier of 0x0 containing a value smaller than or
                        equal to the received setting value.
                        <vspace blankLines="0"/>
                        <cref>This changes slightly the behaviour of the
                            HEADERS frame, which should be updated as follows:
                        </cref>
                        <vspace blankLines="0"/>
                        A HEADER frame with a stream identifier of 0x0
                        indicates that the sender has reduced the maximum size
                        of the header table. The new maximum size of the
                        header table is encoded on 32-bit. The decoder MUST
                        reduce its own header table by dropping entries from
                        it until the size of the header table is lower than or
                        equal to the transmitted maximum size.
                    </t>
                </list>
            </t>
        </section>
        <section anchor="Security" title="Security Considerations">
            <t>TODO?</t>
        </section>
        <section anchor="IANA" title="IANA Considerations">
            <t>This memo includes no request to IANA.</t>
        </section>
    </middle>

    <back>
        <references title="Informative References">
            <reference anchor="SPDY" target="http://tools.ietf.org/html/draft-mbelshe-httpbis-spdy">
                <front>
                    <title>SPDY Protocol</title>
                    <author initials="M" surname="Belshe" fullname="Mike Belshe">
                        <organization>Twist</organization>
                    </author>
                    <author initials="R" surname="Peon" fullname="Roberto Peon">
                        <organization>Google</organization>
                    </author>
                    <date month="February" year="2012"/>
                </front>
            </reference>
        </references>


        <section title="Change Log (to be removed by RFC Editor before publication">
            <section title="Since draft-ietf-httpbis-header-compression-01">
                <t>
                    <list style="symbols">
                        <t>Refactored of Header Encoding Section: split
                            definitions and processing rule.</t>
                        <t>Updated reference set management as per issue
                            #214</t>
                        <t>Added example of 32 bytes entry structure (issue #191).</t>
                    </list>
                </t>
            </section>
        </section>
        <section title="Initial header names" anchor="initial.headers">
            <t>
                <cref>
                    The tables in this section should be updated based on
                    statistical analysis of header names frequency and specific
                    HTTP 2.0 header rules (like removal of some headers).
                </cref>
                <vspace blankLines="0"/>
                <cref>
                    These tables are not adapted for headers contained in
                    PUSH_PROMISE frames. Either the tables can be merged, or the
                    table for responses can be updated.
                </cref>
            </t>
            <section title="Requests">
                <t>
                    The following table lists the pre-defined headers that
                    make-up the initial header table user to represent
                    requests sent from a client to a server.
                </t>
                <texttable anchor="initial.headers.request">
                    <ttcol>Index</ttcol>
                    <ttcol>Header Name</ttcol>
                    <ttcol>Header Value</ttcol>
                    <c>0</c><c>:scheme</c><c>http</c>
                    <c>1</c><c>:scheme</c><c>https</c>
                    <c>2</c><c>:host</c><c></c>
                    <c>3</c><c>:path</c><c>/</c>
                    <c>4</c><c>:method</c><c>GET</c>
                    <c>5</c><c>accept</c><c></c>
                    <c>6</c><c>accept-charset</c><c></c>
                    <c>7</c><c>accept-encoding</c><c></c>
                    <c>8</c><c>accept-language</c><c></c>
                    <c>9</c><c>cookie</c><c></c>
                    <c>10</c><c>if-modified-since</c><c></c>
                    <c>11</c><c>keep-alive</c><c></c>
                    <c>12</c><c>user-agent</c><c></c>
                    <c>13</c><c>proxy-connection</c><c></c>
                    <c>14</c><c>referer</c><c></c>
                    <c>15</c><c>accept-datetime</c><c></c>
                    <c>16</c><c>authorization</c><c></c>
                    <c>17</c><c>allow</c><c></c>
                    <c>18</c><c>cache-control</c><c></c>
                    <c>19</c><c>connection</c><c></c>
                    <c>20</c><c>content-length</c><c></c>
                    <c>21</c><c>content-md5</c><c></c>
                    <c>22</c><c>content-type</c><c></c>
                    <c>23</c><c>date</c><c></c>
                    <c>24</c><c>expect</c><c></c>
                    <c>25</c><c>from</c><c></c>
                    <c>26</c><c>if-match</c><c></c>
                    <c>27</c><c>if-none-match</c><c></c>
                    <c>28</c><c>if-range</c><c></c>
                    <c>29</c><c>if-unmodified-since</c><c></c>
                    <c>30</c><c>max-forwards</c><c></c>
                    <c>31</c><c>pragma</c><c></c>
                    <c>32</c><c>proxy-authorization</c><c></c>
                    <c>33</c><c>range</c><c></c>
                    <c>34</c><c>te</c><c></c>
                    <c>35</c><c>upgrade</c><c></c>
                    <c>36</c><c>via</c><c></c>
                    <c>37</c><c>warning</c><c></c>
                </texttable>
            </section>

            <section title="Responses">
                <t>
                    The following table lists the pre-defined headers that
                    make-up the initial header table used to represent
                    responses sent from a server to a client. The same header
                    table is also used to represent request headers sent from
                    a server to a client in a PUSH_PROMISE frame.
                </t>
                <texttable anchor="initial.headers.response">
                    <ttcol>Index</ttcol>
                    <ttcol>Header Name</ttcol>
                    <ttcol>Header Value</ttcol>
                    <c>0</c><c>:status</c><c>200</c>
                    <c>1</c><c>age</c><c></c>
                    <c>2</c><c>cache-control</c><c></c>
                    <c>3</c><c>content-length</c><c></c>
                    <c>4</c><c>content-type</c><c></c>
                    <c>5</c><c>date</c><c></c>
                    <c>6</c><c>etag</c><c></c>
                    <c>7</c><c>expires</c><c></c>
                    <c>8</c><c>last-modified</c><c></c>
                    <c>9</c><c>server</c><c></c>
                    <c>10</c><c>set-cookie</c><c></c>
                    <c>11</c><c>vary</c><c></c>
                    <c>12</c><c>via</c><c></c>
                    <c>13</c><c>access-control-allow-origin</c><c></c>
                    <c>14</c><c>accept-ranges</c><c></c>
                    <c>15</c><c>allow</c><c></c>
                    <c>16</c><c>connection</c><c></c>
                    <c>17</c><c>content-disposition</c><c></c>
                    <c>18</c><c>content-encoding</c><c></c>
                    <c>19</c><c>content-language</c><c></c>
                    <c>20</c><c>content-location</c><c></c>
                    <c>21</c><c>content-md5</c><c></c>
                    <c>22</c><c>content-range</c><c></c>
                    <c>23</c><c>link</c><c></c>
                    <c>24</c><c>location</c><c></c>
                    <c>25</c><c>p3p</c><c></c>
                    <c>26</c><c>pragma</c><c></c>
                    <c>27</c><c>proxy-authenticate</c><c></c>
                    <c>28</c><c>refresh</c><c></c>
                    <c>29</c><c>retry-after</c><c></c>
                    <c>30</c><c>strict-transport-security</c><c></c>
                    <c>31</c><c>trailer</c><c></c>
                    <c>32</c><c>transfer-encoding</c><c></c>
                    <c>33</c><c>warning</c><c></c>
                    <c>34</c><c>www-authenticate</c><c></c>
                </texttable>
            </section>
        </section>

        <section title="Example" anchor="example">
            <t>
                Here is an example that illustrates different representations
                and how tables are updated.
                <cref>This section needs to be updated to integrate differential coding.</cref>
            </t>
            <section title="First header set">
                <t>
                    The first header set to represent is the following:
                    <figure><artwork type="message/http">
:path: /my-example/index.html
user-agent: my-user-agent
x-my-header: first
</artwork></figure>
                    The header table is empty, all headers are represented as
                    literal headers with indexing.  The 'x-my-header' header
                    name is not in the header name table and is encoded
                    literally.  This gives the following representation:
                    <figure><artwork type="message/http">
0x44      (literal header with incremental indexing, name index = 3)
0x16      (header value string length = 22)
/my-example/index.html
0x4D      (literal header with incremental indexing, name index = 12)
0x0D      (header value string length = 13)
my-user-agent
0x40      (literal header with incremental indexing, new name)
0x0B      (header name string length = 11)
x-my-header
0x05      (header value string length = 5)
first
</artwork></figure>
                    The header table is as follows after the processing of
                    these headers:
                    <figure><artwork type="inline">
Header table
+---------+----------------+---------------------------+
|  Index  | Header Name    | Header Value              |
+---------+----------------+---------------------------+
|    0    | :scheme        | http                      |
+---------+----------------+---------------------------+
|    1    | :scheme        | https                     |
+---------+----------------+---------------------------+
|   ...   | ...            | ...                       |
+---------+----------------+---------------------------+
|   37    | warning        |                           |
+---------+----------------+---------------------------+
|   38    | :path          | /my-example/index.html    | added header
+---------+----------------+---------------------------+
|   39    | user-agent     | my-user-agent             | added header
+---------+----------------+---------------------------+
|   40    | x-my-header    | first                     | added header
+---------+----------------+---------------------------+
</artwork></figure>
                    As all the headers in the first header set are indexed in
                    the header table, all are kept in the reference 
                    set of headers, which is:
                    <figure><artwork type="inline">
Reference Set:
:path, /my-example/index.html
user-agent, my-user-agent
x-my-header, first
</artwork></figure>
                </t>
            </section>
            <section title="Second header set">
                <t>
                    The second header set to represent is the following:
                    <figure><artwork type="message/http">
:path: /my-example/resources/script.js
user-agent: my-user-agent
x-my-header: second
</artwork></figure>
                    Comparing this second header set to the reference set, the
                    first and third headers are from the reference set are not
                    present in this second header set and must be removed. In
                    addition, in this new set, the first and third headers
                    have to be encoded. 
                    The path header is represented as a literal header with
                    substitution indexing. The x-my-header will be
                    represented as a literal header with incremental indexing.
                    <figure><artwork type="message/http">
0xa6       (indexed header, index = 38: removal from reference set)
0xa8       (indexed header, index = 40: removal from reference set)
0x04       (literal header, substitution indexing, name index = 3)
0x26       (replaced entry index = 38)
0x1f       (header value string length = 31)
/my-example/resources/script.js
0x5f 0x0a  (literal header, incremental indexing, name index = 40)
0x06       (header value string length = 6)
second
</artwork></figure>
                    The header table is updated as follow:
                    <figure><artwork type="inline">
Header table
+---------+----------------+---------------------------+
|  Index  | Header Name    | Header Value              |
+---------+----------------+---------------------------+
|    0    | :scheme        | http                      |
+---------+----------------+---------------------------+
|    1    | :scheme        | https                     |
+---------+----------------+---------------------------+
|   ...   | ...            | ...                       |
+---------+----------------+---------------------------+
|   37    | warning        |                           |
+---------+----------------+---------------------------+
|   38    | :path          | /my-example/resources/    | replaced
|         |                |     script.js             | header
+---------+----------------+---------------------------+
|   39    | user-agent     | my-user-agent             |
+---------+----------------+---------------------------+
|   40    | x-my-header    | first                     |
+---------+----------------+---------------------------+
|   41    | x-my-header    | second                    | added header
+---------+----------------+---------------------------+
</artwork></figure>
                    All the headers in this second header set are indexed in
                    the header table, therefore, all are kept in the reference 
                    set of headers, which becomes:
                    <figure><artwork type="inline">
Reference Set:
:path, /my-example/resources/script.js
user-agent, my-user-agent
x-my-header, second
</artwork></figure>
                </t>
            </section>
        </section>

    </back>
</rfc>
<!--
  vim:et:tw=78:sw=4:
 -->
