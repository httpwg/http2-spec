<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='lib/rfc2629.xslt' ?>

<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc linkmailto="no"?>
<?rfc editing="no"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-index="no" ?>

<rfc category="info"
    ipr="trust200902"
    docName="draft-ietf-httpbis-header-compression-latest"
    x:maturity-level="proposed"
    xmlns:x="http://purl.org/net/xml2rfc/ext">
    <x:feedback template="mailto:ietf-http-wg@w3.org?subject={docname},%20%22{section}%22&amp;body=&lt;{ref}&gt;:"/>
    <front>
        <title abbrev="HPACK">HPACK - Header Compression for HTTP/2.0 </title>

        <author initials="R." surname="Peon" fullname="Roberto Peon">
            <organization>Google, Inc</organization>
            <address>
                <email>fenix@google.com</email>
            </address>
        </author>

        <author initials="H." surname="Ruellan" fullname="HervÃ© Ruellan">
            <organization>Canon CRF</organization>
            <address>
                <email>herve.ruellan@crf.canon.fr</email>
            </address>
        </author>

        <date year="2013"/>
        <area>Applications</area>
        <workgroup>HTTPbis Working Group</workgroup>
        <keyword>HTTP</keyword>
        <keyword>Header</keyword>
        <abstract>
            <t>
                This document describes HPACK, a format adapted to efficiently
                represent HTTP header fields in the context of HTTP/2.0.
            </t>
        </abstract>

      <note title="Editorial Note (To be removed by RFC Editor)">
        <t>
          Discussion of this draft takes place on the HTTPBIS working group
          mailing list (ietf-http-wg@w3.org), which is archived at <eref
          target="http://lists.w3.org/Archives/Public/ietf-http-wg/"/>.
        </t>
        <t>
          Working Group information and related documents can be found at
          <eref target="http://tools.ietf.org/wg/httpbis/"/> (Wiki) and <eref
              target="https://github.com/http2/http2-spec"/> (source code and
          issues tracker).
        </t>
        <t>
          The changes in this draft are summarized in <xref
          target="changes.since.draft-ietf-httpbis-header-compression-03"/>.
        </t>
      </note>

    </front>

    <middle>
        <section title="Introduction">

            <t>
                This document describes HPACK, a format adapted to efficiently
                represent HTTP header fields in the context of HTTP/2.0 (see <xref
                    target="HTTP2"/>).
            </t>
        </section>

        <section title="Overview" anchor="overview">
            <t>
                In HTTP/1.X, header fields are sent without any form of compression.
                As web pages have grown to include dozens to hundreds of
                requests, the redundant header fields in these requests now pose a
                problem of measurable latency and unnecessary bandwidth (see
                <xref target="PERF1"/> and <xref target="PERF2"/>).
            </t>

            <t>
                <xref target="SPDY">SPDY</xref> initially addressed this
                redundancy by compressing header fields with Deflate, which proved
                very effective at eliminating the redundant header fields.  However,
                that aproach exposed a security risk as demonstrated by the
                <xref target="CRIME">CRIME</xref>.
            </t>

            <t>
                In this document, we propose a new header field compressor which
                eliminates the redundant header fields, is not vulnerable to the 
                CRIME style attack, and which also has a bounded memory
                cost for use in small constrained environments.
            </t>

            <section title="Outline">
                <t>
                    The HTTP header field encoding described in this document is based
                    on a header table that map (name, value) pairs to index
                    values.  Header tables are incrementally updated during the
                    HTTP/2.0 session.
                </t>
                <t>
                    The encoder is responsible for deciding which header fields to
                    insert as new entries in the header table.  The
                    decoder then does exactly what the encoder prescribes,
                    ending in a state that exactly matches the encoder's
                    state.  This enables decoders to remain simple and
                    understand a wide variety of encoders.
                </t>
                <t>
                    As two consecutive sets of header fields often have header fields in
                    common, each set of header fields is coded as a difference from
                    the previous set of header fields. The goal is to only encode
                    the changes (header fields present in one of the set and not in
                    the other) between the two sets of header fields.
                </t>
                <t>
                    An example illustrating the use of these different
                    mechanisms to represent header fields is available in <xref
                        target="example"/>.
                </t>
            </section>
        </section>

        <section title="Header Field Encoding" anchor="header.encoding">
            <section title="Encoding Concepts" anchor="encoding.concepts">
                <t>
                    The encoding and decoding of header fields relies on some
                    components and concepts. The set of components used form
                    an encoding context.
                    <list style="hanging">
                        <t hangText="Header Table:">
                            The header table (see <xref
                                target="header.table"/>) is a component used
                            to associate header fields to index values.
                        </t>
                        <t hangText="Reference Set:">
                            The reference set (see <xref
                                target="reference.set"/>) is a component
                            containing a group of header fields used as a reference
                            for the differential encoding of a new set of
                            header fields.
                        </t>
                        <t hangText="Header Set:">
                            A header set (see <xref target="header.set"/>) is
                            a group of header fields that are encoded jointly. A
                            complete set of key-value pairs as encoded in
                            a HTTP request or response is a header set.
                        </t>
                        <t hangText="Header Field Representation:">
                            A header field can be represented in encoded form either
                            as a literal or as an index (see <xref
                                target="header.representation"/>). The indexed
                            representation is based on the header table.
                        </t>
                        <t hangText="Header Field Emission:">
                            When decoding a set of header fields, some operations
                            emit a header field (see <xref
                                target="header.emission"/>). An emitted header
                            field
                            is added to the set of header fields that form the HTTP
                            request or response. Once emitted, a header field can't
                            be removed from the set of header fields.
                        </t>
                    </list>
                </t>

                <section title="Encoding Context" anchor="encoding.context">
                    <t>
                        The set of components used to encode or decode a
                        header set form an encoding context: an encoding
                        context contains a header table and a reference set.
                    </t>
                    <t>
                        Using HTTP, messages are exchanged between a client
                        and a server in both direction. To keep the encoding
                        of header fields in each direction independent from the
                        other direction, there is one encoding context for
                        each direction.
                    </t>
                    <t>
                        The header fields contained in a PUSH_PROMISE frame sent by
                        a server to a client are encoded within the same
                        context as the header fields contained in the HEADERS frame
                        corresponding to a response sent from the server to
                        the client.
                    </t>
                </section>

                <section title="Header Table" anchor="header.table">
                    <t>
                        A header table consists of an ordered list of (name,
                        value) pairs. The first entry of a header table is
                        assigned the index 0.
                    </t>
                    <t>
                        A header field can be represented by an entry from the header
                        table. Rather than encoding a literal value for the
                        header field name and value, the encoder can select an
                        entry from the header table.
                    </t>
                    <t>
                        There is no need for the header table to contain
                        duplicate entries. However, duplicate entries MUST NOT
                        be treated as an error by a decoder.
                    </t>
                    <t>
                        The header table has two parts, the first part is
                        dynamic and is controlled by the encoder, while the
                        second part is static. The content of the static part
                        is defined by <xref target="static.headers"/>. The
                        index of the first entry of the static part is the
                        number of entries in the dynamic part: in index order,
                        the static part is appended after the dynamic part.
                    </t>
                    <t>
                        Initially, the dynamic part of the header table is
                        empty.
                    </t>
                    <t>
                        A header table is modified by adding a new
                        entry at the beginning of the table.
                    </t>
                    <t>
                        The encoder decides how to update the header table and
                        as such can control how much memory is used by the
                        header table. To limit the memory requirements on the
                        decoder side, the size of the dynamic part of the
                        header table is bounded (see <xref
                            target="maximum.table.size"/>).
                    </t>
                    <t>
                        When necessary, entries at the end of the dynamic part
                        of the table are dropped to reduce the size of the
                        header table and keep it under its limit.
                    </t>
                </section>

                <section title="Reference Set" anchor="reference.set">
                    <t>
                        A reference set is defined as an unordered set of
                        references to entries of the header table.
                    </t>
                    <t>
                        The initial reference set is the empty set.
                    </t>
                    <t>
                        The reference set is updated during the processing of
                        a set of header fields.
                    </t>
                    <t>
                        Using the differential encoding, a header field that is not
                        present in the reference set can be encoded either
                        with an indexed representation (if the header field is
                        present in the header table), or with a literal
                        representation (if the header field is not present in the
                        header table).
                    </t>
                    <t>
                        A header field that is to be removed from the reference set
                        is encoded with an indexed representation.
                    </t>
                </section>

                <section title="Header set" anchor="header.set">
                    <t>
                        A header set is a group of header fields that are
                        encoded as a whole. Each header field is a (name,
                        value) pair.
                    </t>
                    <t>
                        A header set is encoded using an ordered list of zero
                        or more header field representations. All the header
                        field
                        representations describing a header set a grouped into
                        a header block.
                    </t>
                </section>

                <section title="Header Field Representation"
                    anchor="header.representation">
                    <t>
                        A header field can be represented either as a literal or as
                        an index.
                    </t>
                    <t>
                        <list style="hanging">
                            <t hangText="Literal Representation:">
                                A literal representation defines a new
                                header field. The header field name is represented either
                                literally or as a reference to an entry of the
                                header table. The header field value is represented
                                literally.
                            </t>
                            <t>
                                Two different literal representations are provided:
                                <list style="symbols">
                                    <t>
                                        A literal representation that does not
                                        add the header field to the header table
                                        (see <xref
                                            target="literal.header.without.indexing"/>).
                                    </t>
                                    <t>
                                        A literal representation that adds the
                                        header field as a new entry at the
                                        beginning of the header table (see
                                        <xref
                                            target="literal.header.with.incremental.indexing"/>).
                                    </t>
                                </list>
                            </t>
                            <t hangText="Indexed Representation:">
                                The indexed representation defines a header
                                field as
                                a reference in the header table (see <xref
                                    target="indexed.header.representation"/>).
                            </t>
                        </list>
                    </t>
                </section>

                <section title="Header Field Emission" anchor="header.emission">
                    <t>
                        The emission of header field is the process of adding a
                        header field to the current set of header fields. Once an header field
                        is emitted, it can't be removed from the current set
                        of header fields.
                    </t>
                    <t>
                        The concept of header field emission allows a decoder to
                        know when it can pass a header field safely to a higher
                        level on the receiver side. This allows a decoder to
                        be implemented in a streaming way, and as such to only
                        keep in memory the header table and the reference set.
                        With such an implementation, the amount of memory used
                        by the decoder is bounded, even in presence of a very
                        large set of header fields. The management of memory for
                        handling very large sets of header fields can therefore be
                        deferred to the application, which may be able to
                        process these header fields upon receiving them and
                        thus free up memory quickly.
                    </t>
                </section>

            </section>

            <section title="Header Set Processing"
                anchor="header.set.processing">

                <t>
                    The processing of an encoded header set to obtain a list
                    of header fields is defined in this section.  To ensure a
                    correct decoding of a header set, a decoder MUST obey the
                    following rules.
                </t>

                <section title="Header Field Representation Processing"
                    anchor="header.representation.processing">
                    <t>
                        All the header field representations contained in a header
                        block are processed in the order in which they are
                        presented, as specified below.
                    </t>
                    <t>
                        An <spanx>indexed representation</spanx> corresponding
                        to an entry <spanx>not present</spanx> in the
                        reference set entails the following actions:
                        <list style="symbols">
                            <t>The header field corresponding to the entry is
                                emitted.</t>
                            <t>The entry is added to the reference set.</t>
                        </list>
                    </t>
                    <t>
                        An <spanx>indexed representation</spanx> corresponding
                        to an entry <spanx>present</spanx> in the
                        reference set entails the following actions:
                        <list style="symbols">
                            <t>The entry is removed from the reference set.</t>
                        </list>
                    </t>
                    <t>
                        A <spanx>literal representation</spanx> that is
                        <spanx>not added</spanx> to the header table entails
                        the following action:
                        <list style="symbols">
                            <t>The header field is emitted.</t>
                        </list>
                    </t>
                    <t>
                        A <spanx>literal representation</spanx> that is
                        <spanx>added</spanx> to the header table entails
                        the following actions:
                        <list style="symbols">
                            <t>The header field is emitted.</t>
                            <t>The header field is inserted at the beginning of  the header table.</t>
                            <t>The new entry is added to the reference set.</t>
                        </list>
                    </t>
                </section>

                <section title="Reference Set Emission"
                    anchor="reference.set.emission">
                    <t>
                        Once all the representations contained in a header
                        block have been processed, the header fields that are in
                        common with the previous header set are emitted,
                        during the reference set emission.
                    </t>
                    <t>
                        For the reference set emission, each header field contained
                        in the reference set that has not been emitted during
                        the processing of the header block is emitted.
                    </t>
                </section>

                <section title="Header Set Completion"
                    anchor="header.set.completion">
                    <t>
                        Once all of the header field representations have been
                        processed, and the remaining items in the reference
                        set have been emitted, the header set is complete.
                    </t>
                </section>
            </section>

            <section title="Header Table Management"
                anchor="header.table.management">
                <section title="Maximum Table Size"
                    anchor="maximum.table.size">
                    <t>
                        To limit the memory requirements on the decoder side,
                        the size of the dynamic part of the header table is
                        bounded. The size of the dynamic part MUST stay lower
                        than or equal to the value of the HTTP/2.0 setting
                        SETTINGS_HEADER_TABLE_SIZE (see <xref
                            target="HTTP2"/>). The size of the dynamic part of
                        the header table is the sum of the size of its
                        entries.
                    </t>
                    <t>
                        The size of an entry is the sum of its name's length
                        in bytes (as defined in <xref
                            target="string.literal.representation" />), of its
                        value's length in bytes (<xref
                            target="string.literal.representation" />) and of
                        32 bytes. The 32 bytes are an accounting for the entry
                        structure overhead. For example, an entry structure
                        using two 64-bits pointers to reference the name and
                        the value and the entry, and two 64-bits integer for
                        counting the number of references to these name and
                        value would use 32 bytes.
                    </t>
                    <t>
                        To prevent the header table size from exceeding its
                        limit, an eviction mechanism is used (see <xref
                            target="entry.eviction"/>). The eviction mechanism
                        is applied in two cases: before inserting a new entry
                        in the table, when applying a reduction of the
                        SETTINGS_HEADER_TABLE_SIZE setting value.
                    </t>
                </section>

                <section title="Entry Addition" anchor="entry.addition">
                    <t>
                        The header table can be modified by adding a new entry
                        to it. A new entry is always inserted in the dynamic
                        part of the header table, at the index 0. As a
                        consequence, all the other entries in the table are
                        shifted, and their index is increased by one (both for
                        the entries in the dynamic part and in the static
                        part).
                    </t>
                    <t>
                        Before inserting a new entry in the header table, it
                        has to be ensured that the header table size will stay
                        lower than or equal to the SETTINGS_HEADER_TABLE_SIZE
                        limit (see <xref target="parameter.negotiation"/>). If
                        not enought space is available for this new entry,
                        the eviction mechanism (see <xref
                            target="entry.eviction"/>) is applied until the size of
                        the header table added to the size of the new entry is
                        lower than or equal to the SETTINGS_HEADER_TABLE_SIZE.
                    </t>
                    <t>
                        The addition of a new entry with a size greater than
                        the SETTINGS_HEADER_TABLE_SIZE limit is allowed. It
                        causes all the entries from the header table to be
                        dropped and the new entry not to be added to the
                        header table.
                    </t>
                </section>

                <section title="Entry Eviction" anchor="entry.eviction">
                    <t>
                        The size of the header table is reduced through the
                        eviction mechanism.
                    </t>
                    <t>
                        While the size of dynamic part of the header table is
                        strictly greater than its limit, the entry with the
                        highest index in the header table is dropped. 
                    </t>
                    <t>
                        The eviction of one or more entries from the dynamic
                        part of the header table cause the index of the
                        entries in the static part of the header table to be
                        reduced.
                    </t>
                </section>
            </section>

        </section>

        <section title="Detailed Format" anchor="detailed.format">
            <section title="Low-level representations"
                anchor="low-level.representation">
                <section title="Integer representation"
                    anchor="integer.representation">
                    <t>
                        Integers are used to represent name indexes, pair
                        indexes or string lengths. To allow for optimized
                        processing, an integer representation always finishes
                        at the end of a byte.
                    </t>
                    <t>
                        An integer is represented in two parts: a prefix that
                        fills the current byte and an optional list of bytes
                        that are used if the integer value does not fit in the
                        prefix.  The number of bits of the prefix (called N)
                        is a parameter of the integer representation.
                    </t>
                    <t>
                        The N-bit prefix allows filling the current byte.  If
                        the value is small enough (strictly less than 2<x:sup>N</x:sup>-1),
                        it is encoded within the N-bit prefix.  Otherwise all
                        the bits of the prefix are set to 1 and the value is
                        encoded using an <eref
                            target="http://en.wikipedia.org/wiki/Variable-length_quantity">
                            unsigned variable length integer</eref>
                        representation.
                    </t>
                    <t>
                        The algorithm to represent an integer I is as follows:
                        <figure><artwork type = "inline">
If I &lt; 2^N - 1, encode I on N bits
Else
    encode 2^N - 1 on N bits
    I = I - (2^N - 1)
    While I >= 128
         Encode (I % 128 + 128) on 8 bits
         I = I / 128
    encode (I) on 8 bits
                        </artwork></figure>
                    </t>

                    <section title="Example 1: Encoding 10 using a 5-bit prefix"
                        anchor="integer.representation.example1">
                        <t>
                            The value 10 is to be encoded with a 5-bit prefix.
                            <list style="symbols">
                                <t>
                                    10 is less than 31 (= 2<x:sup>5</x:sup> - 1) and is
                                    represented using the 5-bit prefix.
                                </t>
                            </list>
                        </t>
                        <figure>
                            <artwork type="inline">
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| X | X | X | 0 | 1 | 0 | 1 | 0 |   10 stored on 5 bits
+---+---+---+---+---+---+---+---+
</artwork>
                        </figure>
                    </section>

                    <section title="Example 2: Encoding 1337 using a 5-bit prefix"
                        anchor="integer.representation.example2">
                        <t>
                            The value I=1337 is to be encoded with a 5-bit
                            prefix.
                            <list>
                                <t>1337 is greater than 31 (= 2<x:sup>5</x:sup> - 1).</t>
                                <t>
                                    <list>
                                        <t>The 5-bit prefix is filled with its
                                            max value (31).</t>
                                    </list>
                                </t>
                                <t>I = 1337 - (2<x:sup>5</x:sup> - 1) = 1306.</t>
                                <t>
                                    <list>
                                        <t>I (1306) is greater than or equal
                                            to 128, the while loop body
                                            executes:</t>
                                        <t>
                                            <list>
                                                <t>I % 128 == 26</t>
                                                <t>26 + 128 == 154</t>
                                                <t>154 is encoded in 8 bits as:
                                                    10011010</t>
                                                <t>I is set to 10 (1306 / 128 ==
                                                    10)</t>
                                                <t>I is no longer greater than or
                                                    equal to 128, the while loop
                                                    terminates.</t>
                                            </list>
                                        </t>
                                        <t>
                                            I, now 10, is encoded on 8 bits as: 00001010
                                        </t>
                                    </list>
                                </t>

                                <t>The process ends.</t>
                            </list>

                        </t>
                        <figure>
                            <artwork type="inline">
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| X | X | X | 1 | 1 | 1 | 1 | 1 |  Prefix = 31, I = 1306
| 1 | 0 | 0 | 1 | 1 | 0 | 1 | 0 |  1306>=128, encode(154), I=1306/128
| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 |  10&lt;128, encode(10), done
+---+---+---+---+---+---+---+---+
</artwork>
                        </figure>
                    </section>
                </section>

                <section title="String Literal Representation"
                    anchor="string.literal.representation">
                    <t>
                        Header field names and header field values are encoded
                        as sequences of bytes. A header field name or a header
                        field value is encoded in two parts:
                        <list style="numbers">
                          <t>The number of bytes in the sequence, represented
                              as a <xref target="integer.representation">
                                  variable-length-quantity </xref>.
                          </t>
                          <t>
                              The sequence of bytes representing the header
                              field name or value.
                          </t>
                        </list>
                    </t>
                </section>
            </section>

            <section title="Indexed Header Field Representation"
                anchor="indexed.header.representation">
                <t>
                    An indexed header field representation identifies an entry in the
                    header table.  The entry is emitted and added to the
                    reference set if it is not currently in the reference set.
                    The entry is removed from the reference set if it is present
                    in the reference set.
                </t>
                <figure title="Indexed Header Field">
                    <artwork type="inline">
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 1 |        Index (7+)         |
+---+---------------------------+
</artwork>
                </figure>
                <t>
                    This representation starts with the '1' 1-bit pattern,
                    followed by the index of the matching pair, represented as
                    an integer with a 7-bit prefix.
                </t>
            </section>

            <section title="Literal Header Field Representation"
                anchor="literal.header.representation">
                <t>
                    Literal header field representations contain a literal header
                    field value.  Header field names are either provided as a
                    literal or by reference to an existing header table entry.
                </t>
                <t>
                    Literal representations all result in the emission of a
                    header field when decoded.
                </t>
                <section title="Literal Header Field without Indexing"
                    anchor="literal.header.without.indexing">
                    <t>
                        A literal header field without indexing causes the emission
                        of a header field without altering the header table.
                    </t>
                    <figure title="Literal Header Field without Indexing - Indexed Name">
                        <artwork type="inline">
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 1 |      Index (6+)       |
+---+---+---+-------------------+
|       Value Length (8+)       |
+-------------------------------+
| Value String (Length octets)  |
+-------------------------------+
</artwork>
                    </figure>
                    <figure title="Literal Header Field without Indexing - New Name">
                        <artwork type="inline">
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 1 |           0           |
+---+---+---+-------------------+
|       Name Length (8+)        |
+-------------------------------+
|  Name String (Length octets)  |
+-------------------------------+
|       Value Length (8+)       |
+-------------------------------+
| Value String (Length octets)  |
+-------------------------------+
</artwork>
                    </figure>
                    <t>
                        This representation starts with the '01' 2-bit pattern.
                    </t>
                    <t>
                        If the header field name matches the header field name of a (name,
                        value) pair stored in the Header Table, the index of
                        the pair increased by one (index + 1) is represented
                        as an integer with a 6-bit prefix.  Note that if the
                        index is strictly below 63, one byte is used.
                    </t>
                    <t>
                        If the header field name does not match a header field name entry,
                        the value 0 is represented on 6 bits followed by the
                        header field name (<xref
                            target="string.literal.representation" />).
                    </t>
                    <t>
                        The header field name representation is followed by
                        the header field value represented as a literal string
                        as described in <xref
                            target="string.literal.representation" />.
                    </t>

                </section>

                <section title="Literal Header Field with Incremental Indexing"
                    anchor="literal.header.with.incremental.indexing">
                    <t>
                        A literal header field with incremental indexing adds a new
                        entry to the header table.
                    </t>
                    <figure title="Literal Header Field with Incremental Indexing -
                        Indexed Name">
                        <artwork type="inline">
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 |      Index (6+)       |
+---+---+---+-------------------+
|       Value Length (8+)       |
+-------------------------------+
| Value String (Length octets)  |
+-------------------------------+
</artwork>
                    </figure>
                    <figure title="Literal Header Field with Incremental Indexing -
                        New Name">
                        <artwork type="inline">
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 |           0           |
+---+---+---+-------------------+
|       Name Length (8+)        |
+-------------------------------+
|  Name String (Length octets)  |
+-------------------------------+
|       Value Length (8+)       |
+-------------------------------+
| Value String (Length octets)  |
+-------------------------------+
</artwork>
                    </figure>
                    <t>
                        This representation starts with the '00' 2-bit
                        pattern.
                    </t>
                    <t>
                        If the header field name matches the header field name of a (name,
                        value) pair stored in the Header Table, the index of
                        the pair increased by one (index + 1) is represented
                        as an integer with a 6-bit prefix.  Note that if the
                        index is strictly below 63, one byte is used.
                    </t>
                    <t>
                        If the header field name does not match a header field name entry,
                        the value 0 is represented on 6 bits followed by the
                        header field name (<xref
                            target="string.literal.representation" />).
                    </t>
                    <t>
                        The header field name representation is followed by the header field
                        value represented as a literal string as described in
                        <xref target="string.literal.representation" />.
                    </t>
                </section>
           </section>
        </section>

        <section anchor="parameter.negotiation" title="Parameter Negotiation">
            <t>
              When a decompressor wishes to change the size of the header
              table, it sends a SETTINGS frame with a new value for the 
              SETTINGS_HEADER_TABLE_SIZE.  Upon receipt of this SETTINGS
              frame, the compressor must modify the header table accordingly
              (including any resulting evictions) as soon as possible.
            </t>
          <t>
            After modifying the header table and performing any associated
            evictions, the recipient of the SETTINGS frame MUST respond
            with a SETTINGS frame in which the ACK flag is set before sending
            any additional HEADERS, PUSH_PROMISE, or CONTINUATION frames.
          </t>
        </section>
        <section anchor="Security" title="Security Considerations">
            <t>
                This compressor exists to solve security issues present in
                stream compressors such as DEFLATE whereby the compression
                context can be efficiently probed to reveal secrets.
                A conformant implementation of this specification should be
                fairly safe against that kind of attack, as the reaping of any
                information from the compression context requires more work than
                guessing and verifying the plaintext data directly with the
                server.  As with any secret, however, the longer the length
                of the secret, the more difficult the secret is to guess. It
                is inadvisable to have short cookies that are relied upon to
                remain secret for any duration of time.
            </t>
            <t>
                A proper security-conscious implementation will also need to
                prevent timing attacks by ensuring that the amount of time it
                takes to do string comparisons is always a function of the
                total length of the strings, and not a function of the number
                of matched characters.
            </t>
            <t>
                Another common security problem is when the remote endpoint
                successfully causes the local endpoint to exhaust its memory.
                This compressor attempts to deal with the most obvious ways
                that this could occur by limiting both the peak and the
                steady-state amount of memory consumed in the compressor
                state, by providing ways for the application to consume/flush
                the emitted header fields in small chunks, and by considering
                overhead in the state size calculation.  Implementors must
                still be careful in the creation of APIs to an implementation
                of this compressor by ensuring that header field keys and values are
                either emitted as a stream, or that the compression
                implementation have a limit on the maximum size of a key or
                value. Failure to implement these kinds of safeguards may
                still result in a scenario where the local endpoint exhausts
                its memory.
            </t>
        </section>
        <section anchor="IANA" title="IANA Considerations">
            <t>
                This document registers the SETTINGS_HEADER_TABLE_SIZE setting
                in the "HTTP/2.0 Settings" registry established by <xref
                target="HTTP2"/>.  The assigned code for this setting is TBD.
            </t>
        </section>
    </middle>

    <back>
        <references title="Normative References">
            <reference anchor="HTTP2">
                <front>
                    <title>Hypertext Transfer Protocol version 2.0</title>
                    <author initials="M." surname="Belshe" fullname="Mike Belshe">
                        <organization>Twist</organization>
                    </author>
                    <author initials="R." surname="Peon" fullname="Roberto Peon">
                        <organization>Google</organization>
                    </author>
                    <author initials="M." surname="Thomson" fullname="Martin Thomson">
                        <organization></organization>
                    </author>
                    <author initials="A." surname="Melnikov" fullname="Alexey Melnikov">
                        <organization></organization>
                    </author>
                    <date month="August" year="2013"/>
                </front>
                <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-http2-06"/>
            </reference>
        </references>

        <references title="Informative References">
            <reference anchor="SPDY" target="http://tools.ietf.org/html/draft-mbelshe-httpbis-spdy">
                <front>
                    <title>SPDY Protocol</title>
                    <author initials="M." surname="Belshe" fullname="Mike Belshe">
                        <organization>Twist</organization>
                    </author>
                    <author initials="R." surname="Peon" fullname="Roberto Peon">
                        <organization>Google</organization>
                    </author>
                    <date month="February" year="2012"/>
                </front>
            </reference>
            <reference anchor="CRIME" target="https://docs.google.com/a/twist.com/presentation/d/11eBmGiHbYcHR9gL5nDyZChu_-lCa2GizeuOfaLU2HOU/edit#slide=id.g1eb6c1b5_3_6">
                <front>
                    <title>The Crime Attack</title>
                    <author initials="J." surname="Rizzo" fullname="Juliano Rizzo"></author>
                    <author initials="T." surname="Duong" fullname="Thai Duong"></author>
                    <date month="September" year="2012"/>
                </front>
            </reference>
            <reference anchor="PERF1" target="http://www.ietf.org/proceedings/83/slides/slides-83-httpbis-3">
                <front>
                    <title>IETF83: SPDY and What to Consider for HTTP/2.0</title>
                    <author initials="M." surname="Belshe" fullname="Mike Belshe">
                    </author>
                    <date month="March" year="2012"/>
                </front>
            </reference>
            <reference anchor="PERF2" target="http://bitsup.blogspot.com/2011/09/spdy-what-i-like-about-you.html">
                <front>
                    <title>SPDY: What I Like About You</title>
                    <author initials="P." surname="McManus" fullname="Patrick McManus">
                    </author>
                    <date month="September" year="2011"/>
                </front>
            </reference>
        </references>


        <section title="Change Log (to be removed by RFC Editor before publication">
            <section title="Since draft-ietf-httpbis-header-compression-03" anchor="changes.since.draft-ietf-httpbis-header-compression-03">
                <t><list style="symbols">
                    <t>
                        Initial header table always accessible.
                    </t>
                    <t>
                        Combined initial header tables.
                    </t>
                    <t>
                        Removed substitution.
                    </t>
                </list></t>
            </section>
            <section title="Since draft-ietf-httpbis-header-compression-02">
                <t><list style="symbols">
                    <t>
                        Corrected error in integer encoding pseudocode.
                    </t>
                </list></t>
            </section>

            <section title="Since draft-ietf-httpbis-header-compression-01">
                <t>
                    <list style="symbols">
                        <t>
                            Refactored of Header Encoding Section: split
                            definitions and processing rule.
                        </t>
                        <t>
                            Backward incompatible change: Updated
                            reference set management as per issue #214. This
                            changes how the interaction between the reference
                            set and eviction works. This also changes the
                            working of the reference set in some specific
                            cases.
                        </t>
                        <t>
                            Backward incompatible change: modified initial
                            header list, as per issue #188.
                        </t>
                        <t>
                            Added example of 32 bytes entry structure (issue
                            #191).
                        </t>
                        <t>
                            Added Header Set Completion section.  Reflowed
                            some text. Clarified some writing which was
                            akward.  Added text about duplicate header entry
                            encoding.  Clarified some language w.r.t Header
                            Set.  Changed x-my-header to mynewheader. Added
                            text in the HeaderEmission section indicating that
                            the application may also be able to free up memory
                            more quickly.  Added information in Security
                            Considerations section.
                        </t>
                    </list>
                </t>
            </section>
            <section title="Since draft-ietf-httpbis-header-compression-01">
                <t>
                    <list>
                        <t>Fixed bug/omission in integer representation algorithm.</t>
                        <t>Changed the document title.</t>
                        <t>Header matching text rewritten.</t>
                        <t>Changed the definition of header emission.</t>
                        <t>Changed the name of the setting which dictates how
                            much memory the compression context should
                            use.</t>
                        <t>Removed "specific use cases" section</t>
                        <t>Corrected erroneous statement about what index can
                            be contained in one byte</t>
                        <t>Added descriptions of opcodes</t>
                        <t>Removed security claims from introduction.</t>
                    </list>
                </t>
            </section>
        </section>
        <section title="Static Header Field Table" anchor="static.headers">
            <t>
                <cref>
                    The table in this section should be updated based on
                    statistical analysis of header field names frequency and specific
                    HTTP 2.0 header field rules (like removal of some header fields).
                </cref>
            </t>
            <t>
                The following table lists the pre-defined header fields that
                make-up the static part of a header table used to encode or
                decode a set of header fields.
            </t>
            <texttable title="Static Header Field Table"
                anchor="static.headers.table">
                <ttcol>Index</ttcol>
                <ttcol>Header Field Name</ttcol>
                <ttcol>Header Field Value</ttcol>
                <c>0</c><c>:method</c><c>GET</c>
                <c>1</c><c>:method</c><c>POST</c>
                <c>2</c><c>:scheme</c><c>http</c>
                <c>3</c><c>:scheme</c><c>https</c>
                <c>4</c><c>:path</c><c>/</c>
                <c>5</c><c>:status</c><c>200</c>
                <c>6</c><c>:authority</c><c></c>
                <c>7</c><c>accept-charset</c><c></c>
                <c>8</c><c>accept-encoding</c><c></c>
                <c>9</c><c>accept-language</c><c></c>
                <c>10</c><c>accept-ranges</c><c></c>
                <c>11</c><c>accept</c><c></c>
                <c>12</c><c>access-control-allow-origin</c><c></c>
                <c>13</c><c>age</c><c></c>
                <c>14</c><c>allow</c><c></c>
                <c>15</c><c>authorization</c><c></c>
                <c>16</c><c>cache-control</c><c></c>
                <c>17</c><c>content-disposition</c><c></c>
                <c>18</c><c>content-encoding</c><c></c>
                <c>19</c><c>content-language</c><c></c>
                <c>20</c><c>content-length</c><c></c>
                <c>21</c><c>content-location</c><c></c>
                <c>22</c><c>content-range</c><c></c>
                <c>23</c><c>content-type</c><c></c>
                <c>24</c><c>cookie</c><c></c>
                <c>25</c><c>date</c><c></c>
                <c>26</c><c>etag</c><c></c>
                <c>27</c><c>expect</c><c></c>
                <c>28</c><c>expires</c><c></c>
                <c>29</c><c>from</c><c></c>
                <c>30</c><c>host</c><c></c>
                <c>31</c><c>if-match</c><c></c>
                <c>32</c><c>if-modified-since</c><c></c>
                <c>33</c><c>if-none-match</c><c></c>
                <c>34</c><c>if-range</c><c></c>
                <c>35</c><c>if-unmodified-since</c><c></c>
                <c>36</c><c>last-modified</c><c></c>
                <c>37</c><c>link</c><c></c>
                <c>38</c><c>location</c><c></c>
                <c>39</c><c>max-forwards</c><c></c>
                <c>40</c><c>proxy-authenticate</c><c></c>
                <c>41</c><c>proxy-authorization</c><c></c>
                <c>42</c><c>range</c><c></c>
                <c>43</c><c>referer</c><c></c>
                <c>44</c><c>refresh</c><c></c>
                <c>45</c><c>retry-after</c><c></c>
                <c>46</c><c>server</c><c></c>
                <c>47</c><c>set-cookie</c><c></c>
                <c>48</c><c>strict-transport-security</c><c></c>
                <c>49</c><c>user-agent</c><c></c>
                <c>50</c><c>vary</c><c></c>
                <c>51</c><c>via</c><c></c>
                <c>52</c><c>www-authenticate</c><c></c>
            </texttable>
            <t>
                The table give the index of each entry inside the static part
                of the header table. The full index of each entry, to be used
                for encoding a reference to this entry, is computed by adding
                the number of entries in the dynamic part of the header table
                to this index.
            </t>
            <!-- 53 vim renumber command: :let i=0 | g/<c>/s/\d\+/\=i/ | let i=i+1 -->
        </section>

        <section title="Example" anchor="example">
            <t>
                Here is an example that illustrates different representations
                and how tables are updated.
                <cref>This section needs to be updated to better reflect the new processing of header fields, and include more examples.</cref>
            </t>
            <section title="First header set">
                <t>
                    The first header set to represent is the following:
                    <figure><artwork type="message/http">
:path, /my-example/index.html
user-agent, my-user-agent
mynewheader, first
</artwork></figure>
                    The header table is empty, all header fields are represented as
                    literal header fields with indexing.  The 'mynewheader' header field
                    name is not in the header table and is encoded
                    literally.  This gives the following representation:
                    <figure><artwork type="message/http">
0x04      (literal header field with incremental indexing, name index = 3)
0x16      (header field value string length = 22)
/my-example/index.html
0x0D      (literal header field with incremental indexing, name index = 12)
0x0D      (header field value string length = 13)
my-user-agent
0x00      (literal header field with incremental indexing, new name)
0x0B      (header field name string length = 11)
mynewheader
0x05      (header field value string length = 5)
first
</artwork></figure>
                    The header table is as follows after the processing of
                    these header fields:
                    <figure><artwork type="inline">
Header table
+---------+----------------+---------------------------+
|  Index  | Header Name    | Header Value              |
+---------+----------------+---------------------------+
|    0    | mynewheader    | first                     | added header field
+---------+----------------+---------------------------+
|    1    | user-agent     | my-user-agent             | added header field
+---------+----------------+---------------------------+
|    2    | :path          | /my-example/index.html    | added header field
+---------+----------------+---------------------------+
|    3    | :scheme        | http                      |
+---------+----------------+---------------------------+
|    4    | :scheme        | https                     |
+---------+----------------+---------------------------+
|   ...   | ...            | ...                       |
+---------+----------------+---------------------------+
|   32    | via            |                           |
+---------+----------------+---------------------------+
</artwork></figure>
                    As all the header fields in the first header set are indexed in
                    the header table, all are kept in the reference
                    set of header fields, which is:
                    <figure><artwork type="inline">
Reference Set:
:path, /my-example/index.html
user-agent, my-user-agent
mynewheader, first
</artwork></figure>
                </t>
            </section>
            <section title="Second header set">
                <t>
                    The second header set to represent is the following:
                    <figure><artwork type="message/http">
:path, /my-example/resources/script.js
user-agent, my-user-agent
mynewheader, second
</artwork></figure>
                    Comparing this second header set to the reference set, the
                    first and third header fields are from the reference set are not
                    present in this second header set and must be removed. In
                    addition, in this new set, the first and third header
                    fields
                    have to be encoded.
                    The path header field is represented as a literal header
                    field
                    without indexing. The mynewheader will be
                    represented as a literal header field with incremental indexing.
                    <figure><artwork type="message/http">
0x80       (indexed header field, index = 0: removal from reference set)
0x82       (indexed header field, index = 2: removal from reference set)
0x43       (literal header field, without indexing, name index = 2)
0x1f       (header field value string length = 31)
/my-example/resources/script.js
0x01       (literal header field, incremental indexing, name index = 0)
0x06       (header field value string length = 6)
second
</artwork></figure>
                    The header table is updated as follow:
                    <figure><artwork type="inline">
Header table
+---------+----------------+---------------------------+
|  Index  | Header Name    | Header Value              |
+---------+----------------+---------------------------+
|    0    | mynewheader    | second                    | added header field
+---------+----------------+---------------------------+
|    1    | mynewheader    | first                     |
+---------+----------------+---------------------------+
|    2    | user-agent     | my-user-agent             |
+---------+----------------+---------------------------+
|    3    | :path          | /my-example/index.html    |
+---------+----------------+---------------------------+
|    4    | :scheme        | http                      |
+---------+----------------+---------------------------+
|    5    | :scheme        | https                     |
+---------+----------------+---------------------------+
|   ...   | ...            | ...                       |
+---------+----------------+---------------------------+
|   33    | via            |                           |
+---------+----------------+---------------------------+
</artwork></figure>
                    All the header fields in this second header set are indexed in
                    the header table, therefore, all are kept in the reference
                    set of header fields, which becomes:
                    <figure><artwork type="inline">
Reference Set:
:path, /my-example/resources/script.js
user-agent, my-user-agent
mynewheader, second
</artwork></figure>
                </t>
            </section>
        </section>

    </back>
</rfc>
<!--
  vim:et:tw=78:sw=4:
 -->
