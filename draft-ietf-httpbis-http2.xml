<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="lib/rfc2629.xslt"?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no" ?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-index="no" ?>

<rfc ipr="trust200902" 
     category="std"
     docName="draft-ietf-httpbis-http2-latest" 
     x:maturity-level="proposed"
     xmlns:x="http://purl.org/net/xml2rfc/ext">
  <x:feedback template="mailto:ietf-http-wg@w3.org?subject={docname},%20%22{section}%22&amp;body=&lt;{ref}&gt;:"/>
  <front>
    <title abbrev="HTTP/2.0">Hypertext Transfer Protocol version 2.0</title>

    <author initials="M." surname="Belshe" fullname="Mike Belshe">
      <organization>Twist</organization>
      <address>
        <email>mbelshe@chromium.org</email>
      </address>
    </author>

    <author initials="R." surname="Peon" fullname="Roberto Peon">
      <organization>Google, Inc</organization>
      <address>
        <email>fenix@google.com</email>
      </address>
    </author>

    <author initials="M." surname="Thomson" fullname="Martin Thomson" role="editor">
      <organization>Microsoft</organization>
      <address>
        <postal>
          <street>3210 Porter Drive</street>
          <city>Palo Alto</city>
          <code>94304</code>
          <country>US</country>
        </postal>
        <email>martin.thomson@skype.net</email>
      </address>
    </author>

    <author initials="A." surname="Melnikov" fullname="Alexey Melnikov" role="editor">
      <organization>Isode Ltd</organization>
      <address>
        <postal>
          <street>5 Castle Business Village</street>
          <street>36 Station Road</street>
          <city>Hampton</city>
          <region>Middlesex</region>

          <code>TW12 2BX</code>
          <country>UK</country>
        </postal>
        <email>Alexey.Melnikov@isode.com</email>
      </address>
    </author>

    <date year="2013" />
    <area>Applications</area>
    <workgroup>HTTPbis Working Group</workgroup>
    <keyword>HTTP</keyword>
    <keyword>SPDY</keyword>
    <keyword>Web</keyword>

    <abstract>
      <t>
        This specification describes an optimized expression of the syntax of the Hypertext 
        Transfer Protocol (HTTP). The HTTP/2.0 encapsulation enables more efficient use of 
        network resources and reduced perception of latency by allowing header field 
        compression and multiple concurrent messages on the same connection. It also 
        introduces unsolicited push of representations from servers to clients.
      </t>
      <t>
        This document is an alternative to, but does not obsolete the HTTP/1.1 message format
        or protocol. HTTP's existing semantics remain unchanged.
      </t>
      <t>
        This version of the draft has been marked for implementation.  Interoperability
        testing will occur in the HTTP/2.0 interim in Hamburg, DE, starting 2013-08-05.
      </t>
    </abstract>

    <note title="Editorial Note (To be removed by RFC Editor)">
      <t>
        Discussion of this draft takes place on the HTTPBIS working group
        mailing list (ietf-http-wg@w3.org), which is archived at
        <eref target="http://lists.w3.org/Archives/Public/ietf-http-wg/"/>.
      </t>
      <t>
        Working Group information and related documents can be found
        at <eref target="http://tools.ietf.org/wg/httpbis/"/> (Wiki) and
        <eref target="https://github.com/http2/http2-spec"/> (source code
        and issues tracker).
      </t>
      <t>
        The changes in this draft are summarized in <xref
        target="changes.since.draft-ietf-httpbis-http2-03"/>.
      </t>
    </note>

  </front>

  <middle>
    <section anchor="intro" title="Introduction">
      
      <t>
        The Hypertext Transfer Protocol (HTTP) is a wildly successful protocol. However, the HTTP/1.1 message
        format (<xref target="HTTP-p1" x:fmt="," x:rel="#http.message"/>) is optimized for
        implementation simplicity and accessibility, not application performance.  As such it has
        several characteristics that have a negative overall effect on application performance.
      </t>
      <t>
        In particular, HTTP/1.0 only allows one request to be delivered at a time on a given
        connection.  HTTP/1.1 pipelining only partially addressed request concurrency, and is not
        widely deployed.  Therefore, clients that need to make many requests (as is common on the
        Web) typically use multiple connections to a server in order to reduce perceived latency.
      </t>
      <t>
        Furthermore, HTTP/1.1 header fields are often repetitive and verbose, which, in
        addition to generating more or larger network packets, can cause the small initial TCP
        congestion window to quickly fill.  This can result in excessive latency when multiple
        requests are made on a single new TCP connection.
      </t>
      <t>
        This document addresses these issues by defining an optimized mapping of HTTP's semantics to
        an underlying connection.  Specifically, it allows interleaving of request and response
        messages on the same connection and uses an efficient coding for HTTP header fields.  It
        also allows prioritization of requests, letting more important requests complete more
        quickly, further improving perceived performance.
      </t>
      <t>
        The resulting protocol is designed to have be more friendly to the network, because fewer
        TCP connections can be used, in comparison to HTTP/1.x. This means less competition with
        other flows, and longer-lived connections, which in turn leads to better utilization of
        available network capacity.
      </t>
      <t>
        Finally, this encapsulation also enables more scalable processing of messages through use of
        binary message framing.
      </t>

      <section title="Document Organization">
        <t>
          The HTTP/2.0 Specification is split into three parts: <xref target="starting">starting
          HTTP/2.0</xref>, which covers how a HTTP/2.0 connection is initiated; <xref target="FramingLayer">a
          framing layer</xref>, which multiplexes a single TCP connection into independent
          frames of various types; and <xref target="HTTPLayer">an HTTP layer</xref>, which specifies the mechanism
          for expressing HTTP interactions using the framing layer. While some of the
          framing layer concepts are isolated from HTTP, building a generic framing layer
          has not been a goal. The framing layer is tailored to the needs of the HTTP protocol and
          server push.
        </t>
      </section>
      <section title="Conventions and Terminology">
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD
          NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
          described in <xref target="RFC2119">RFC 2119</xref>.
        </t>
        <t>
          All numeric values are in network byte order.  Values are unsigned unless otherwise
          indicated.  Literal values are provided in decimal or hexadecimal as appropriate.
          Hexadecimal literals are prefixed with <spanx style="verb">0x</spanx> to distinguish them
          from decimal literals.
        </t>
        <t>
          The following terms are used:
          <list style="hanging">
            <t hangText="client:">
              The endpoint initiating the HTTP connection.
            </t>
            <t hangText="connection:">
              A transport-level connection between two endpoints.
            </t>
            <t hangText="endpoint:">
              Either the client or server of the connection.
            </t>
            <t hangText="frame:">
              The smallest unit of communication within an HTTP/2.0 connection, 
              consisting of a header and a variable-length sequence of bytes
              structured according to the frame type.
            </t>
            <t hangText="peer:">
              An endpoint.  When discussing a particular endpoint, "peer" refers to the endpoint
              that is remote to the primary subject of discussion.
            </t>
            <t hangText="receiver:">
              An endpoint that is receiving frames.
            </t>
            <t hangText="sender:">
              An endpoint that is transmitting frames.
            </t>
            <t hangText="server:">
              The endpoint which did not initiate the HTTP connection.
            </t>
            <t hangText="connection error:">
              An error on the HTTP/2.0 connection.
            </t>
            <t hangText="stream:">
              A bi-directional flow of frames across a virtual channel within 
              the HTTP/2.0 connection.
            </t>
            <t hangText="stream error:">
              An error on the individual HTTP/2.0 stream.
            </t>
          </list>
        </t>
      </section>
    </section>

    <section anchor="Overview" title="HTTP/2.0 Protocol Overview">
      <t>
        HTTP/2.0 provides an optimized transport for HTTP semantics.  
      </t>
      <t>
        An HTTP/2.0 connection is an application level protocol running on top
        of a TCP connection (<xref target="RFC0793"/>). The client is the TCP
        connection initiator.
      </t>
      <t>
        This document describes the HTTP/2.0 protocol using a logical structure that is formed of three parts:
        framing, streams, and application mapping.  This structure is provided primarily as an aid
        to specification, implementations are free to diverge from this structure as necessary.
      </t>
      
      <!-- we need to, at some stage, introduce a "message" term and provide a definition, this is the place that starts talking about that concept... -->
      <section title="HTTP Frames">
        <t>
          HTTP/2.0 provides an efficient serialization of HTTP semantics.  HTTP requests and responses are
          encoded into length-prefixed frames (see <xref target="FrameHeader"/>).
        </t>
        <t>
          HTTP headers are compressed into a series of frames that contain header block fragments
          (see <xref target="HeaderBlock"/>).
        </t>
      </section>

      <section title="HTTP Multiplexing">
        <t>
           HTTP/2.0 provides the ability to multiplex multiple HTTP requests and responses onto a single connection.  
           Multiple requests or responses can be sent concurrently on a connection using
           <xref target="StreamsLayer">streams</xref>.  In order to maintain independent streams, flow control and
           prioritization are necessary.
        </t>
      </section>

      <section title="HTTP Semantics">
        <t>
          HTTP/2.0 defines how HTTP requests and responses are mapped to streams (see <xref target="HTTPLayer"/>)
          and introduces a new interaction model, <xref target="PushResources">server push</xref>.
        </t>
      </section>

    </section>

    <section anchor="starting" title="Starting HTTP/2.0">
      <t>
        HTTP/2.0 uses the same "http" and "https" URI schemes used by HTTP/1.1. HTTP/2.0
        shares the same default port numbers: 80 for "http" URIs and 443 for "https" URIs.  As a
        result, implementations processing requests for target resource URIs like <spanx
        style="verb">http://example.org/foo</spanx> or <spanx
        style="verb">https://example.com/bar</spanx> are required to first discover whether the
        upstream server (the immediate peer to which the client wishes to establish a connection)
        supports HTTP/2.0.
      </t>
 
      <t>
        The means by which support for HTTP/2.0 is determined is different for "http" and "https"
        URIs. Discovery for "http" URIs is described in <xref target="discover-http"/>.
        Discovery for "https" URIs is described in <xref target="discover-https"/>.
      </t>

      <section anchor="versioning" title="HTTP/2.0 Version Identification">
        <t>
          The protocol defined in this document is identified using the string "HTTP/2.0".  This
          identification is used in the HTTP/1.1 Upgrade header field, in the <xref
          target="TLSALPN">TLS application layer protocol negotiation extension</xref> field, and
          other places where protocol identification is required.
        </t>
        <t>
          Negotiating "HTTP/2.0" implies the use of the transport, security, framing and message
          semantics described in this document.
        </t>
        <t>
          <cref>Editor's Note: please remove the following text prior to the publication of a final
          version of this document.</cref>
        </t>
        <t>
          Only implementations of the final, published RFC can identify themselves as "HTTP/2.0".
          Until such an RFC exists, implementations MUST NOT identify themselves using "HTTP/2.0".
        </t>
        <t>
          Examples and text throughout the rest of this document use "HTTP/2.0" as a matter of
          editorial convenience only.  Implementations of draft versions MUST NOT identify using
          this string.
        </t>
        <t>
          Implementations of draft versions of the protocol MUST add the string "-draft-" and the
          corresponding draft number to the identifier before the separator ('/').  For example,
          draft-ietf-httpbis-http2-03 is identified using the string "HTTP-draft-03/2.0".
        </t>
        <t>
          Non-compatible experiments that are based on these draft versions MUST instead replace the
          string "draft" with a different identifier.  For example, an experimental implementation
          of packet mood-based encoding based on draft-ietf-httpbis-http2-07 might identify itself
          as "HTTP-emo-07/2.0".  Note that any label MUST conform to the "token" syntax defined in
          <xref target="HTTP-p1" x:fmt="of" x:rel="#field.components"/>.  Experimenters are
          encouraged to coordinate their experiments on the ietf-http-wg@w3.org mailing list.
        </t>
      </section>
      
      <section anchor="discover-http" title="Starting HTTP/2.0 for &quot;http&quot; URIs">
        <t>
          A client that makes a request to an "http" URI without prior knowledge about support for
          HTTP/2.0 uses the HTTP Upgrade mechanism (<xref target="HTTP-p1" x:fmt="of"
          x:rel="#header.upgrade"/>).  The client makes an HTTP/1.1 request that includes an Upgrade
          header field identifying HTTP/2.0.  The HTTP/1.1 request MUST include an <xref 
            target="Http2SettingsHeader">HTTP2-Settings</xref> header field.
        </t>
        <figure>
          <preamble>For example:</preamble>
          <artwork type="message/http; msgtype=&#34;request&#34;" x:indent-with="  ">
GET /default.htm HTTP/1.1
Host: server.example.com
Connection: Upgrade, HTTP2-Settings
Upgrade: HTTP/2.0
HTTP2-Settings: &lt;base64url encoding of HTTP/2.0 SETTINGS payload>
</artwork>
        </figure>
        <t>
          Requests that contain a request entity body MUST be sent in their entirety before the
          client can send HTTP/2.0 frames.  This means that a large request entity can block the use
          of the connection until it is completely sent.
          <list>
            <t>
              If concurrency of an initial request with subsequent requests is important, a small
              request can be used to perform the upgrade to HTTP/2.0, at the cost of an additional
              round trip.
            </t>
          </list>
        </t>
        <t>
          A server that does not support HTTP/2.0 can respond to the request as though the Upgrade
          header field were absent:
        </t>
        <figure>
          <artwork type="message/http; msgtype=&#34;responset&#34;" x:indent-with="  ">
HTTP/1.1 200 OK
Content-length: 243
Content-type: text/html

...
</artwork>
        </figure>
        <t>
          A server that supports HTTP/2.0 accepts the upgrade with a 101 (Switching Protocols)
          status code.  After the empty line that terminates the 101 response, the server can begin
          sending HTTP/2.0 frames.  These frames MUST include a response to the request that
          initiated the Upgrade.
        </t>

        <figure>
          <artwork type="message/http; msgtype=&#34;response&#34;" x:indent-with="  ">
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: HTTP/2.0

[ HTTP/2.0 connection ...
</artwork>
        </figure>
        <t>
          The first HTTP/2.0 frame sent by the server is a <xref target="SETTINGS">SETTINGS
          frame</xref>.  Upon receiving the 101 response, the client sends a <xref
          target="ConnectionHeader">connection header</xref>, which includes a SETTINGS frame.
        </t>
        <t>
          The HTTP/1.1 request that is sent prior to upgrade is associated with stream 1 and is
          assigned the highest possible priority.  Stream 1 is implicitly half closed from the
          client toward the server, since the request is completed as an HTTP/1.1 request.  After
          commencing the HTTP/2.0 connection, stream 1 is used for the response.
        </t>

        <section anchor="Http2SettingsHeader" title="HTTP2-Settings Header Field">
          <t>
            A client that upgrades from HTTP/1.1 to HTTP/2.0 MUST include an
            <spanx style="verb">HTTP2-Settings</spanx> header field.
            The <spanx style="verb">HTTP2-Settings</spanx> header field is a hop-by-hop header 
            field that includes settings that govern the HTTP/2.0 connection,
            provided in anticipation of the server accepting the request to upgrade.
            A server MUST reject an attempt to upgrade if this header is not present.
          </t>
          <figure>
            <artwork type="abnf" x:indent-with="  "><![CDATA[
HTTP2-Settings    = token68
]]></artwork>
          </figure>

          <t>
            The content of the <spanx style="verb">HTTP2-Settings</spanx> header field is the
            payload of a <xref target="SETTINGS">SETTINGS frame</xref>, encoded as a base64url string 
            (that is, the URL- and filename-safe Base64 encoding described in 
            <xref target="RFC4648" x:fmt="of" x:sec="5"/>, with any trailing '=' characters omitted).
            The <xref target="RFC5234">ABNF</xref> production for <spanx style="verb">token68</spanx> is 
            defined in <xref target="HTTP-p7" x:fmt="of" x:rel="#challenge.and.response"/>.
          </t>
          <t>
            The client MUST include values for the following <xref target="SettingFormat">settings</xref>:
            <list style="symbols">
              <t>SETTINGS_MAX_CONCURRENT_STREAMS</t>
              <t>SETTINGS_INITIAL_WINDOW_SIZE</t>
            </list>
          </t>
          <t>
            As a hop-by-hop header field, the <spanx style="verb">Connection</spanx> header field MUST include
            a value of <spanx style="verb">HTTP2-Settings</spanx> in addition to <spanx style="verb">Upgrade</spanx>
            when upgrading to HTTP/2.0.
          </t>
          <t>
            A server decodes and interprets these values as it would any other SETTINGS frame.
            Providing these values in the Upgrade request ensures that the protocol does not require default values for
            the above settings, and gives a client an opportunity to provide other settings prior to receiving any frames from the server.
          </t>
        </section>
      </section>

      <section anchor="discover-https" title="Starting HTTP/2.0 for &quot;https&quot; URIs">
        <t>
          A client that makes a request to an "https" URI without prior knowledge about support for
          HTTP/2.0 uses <xref target="RFC5246">TLS</xref> with the <xref
          target="TLSALPN">application layer protocol negotiation extension</xref>.
        </t>

        <t>
          Once TLS negotiation is complete, both the client and the server send a <xref
          target="ConnectionHeader">connection header</xref>.
        </t>
      </section>

      <section anchor="known-http" title="Starting HTTP/2.0 with Prior Knowledge">
        <t>
          A client can learn that a particular server supports HTTP/2.0 by other means.  A client
          MAY immediately send HTTP/2.0 frames to a server that is known to support HTTP/2.0, after the <xref
          target="ConnectionHeader">connection header</xref>.  This
          only affects the resolution of "http" URIs; servers supporting HTTP/2.0 are required to
          support <xref target="TLSALPN">protocol negotiation in TLS</xref> for "https" URIs.
        </t>
        <t>
          Prior support for HTTP/2.0 is not a strong signal that a given server will support
          HTTP/2.0 for future connections.  It is possible for server configurations to change or for
          configurations to differ between instances in clustered server.  Interception proxies
          (a.k.a. "transparent" proxies) are another source of variability.
        </t>
      </section>
      
      <section anchor="ConnectionHeader" title="Connection Header">
        <t>
          Upon establishment of a TCP connection and determination
          that HTTP/2.0 will be used by both peers, each
          endpoint MUST send a connection header as a final confirmation
          and to establish the initial settings for the HTTP/2.0 connection.
        </t>

        <t>
          The client connection header is a sequence of 24 octets, which in hex notation are:
        </t>
        <figure>
          <artwork type="inline" x:indent-with="  "><![CDATA[
505249202a20485454502f322e300d0a0d0a534d0d0a0d0a
]]></artwork>
        </figure>
        <t>
          (the string <spanx style="verb">PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</spanx>) followed by a
          <xref target="SETTINGS">SETTINGS frame</xref>.  The client sends the client connection header
          immediately upon receipt of a 101 Switching Protocols response (indicating a successful
          upgrade), or after receiving a TLS Finished message from the server. If starting an
          HTTP/2.0 connection with prior knowledge of server support for the protocol, the client
          connection header is sent upon connection establishment.
        </t>
        <t>
          <list>
            <t>
              The client connection header is selected so that a large proportion of HTTP/1.1 or
              HTTP/1.0 servers and intermediaries do not attempt to process further frames.  Note
              that this does not address the concerns raised in <xref target="TALKING"/>.
            </t>
          </list>
        </t>
        <t>
          The server connection header consists of just
          a <xref target="SETTINGS">SETTINGS frame</xref> that MUST be the
          first frame the server sends in the HTTP/2.0 connection.
        </t>
        <t>
          To avoid unnecessary latency, clients are permitted to send
          additional frames to the server immediately after sending the client
          connection header, without waiting to receive the server connection header.
          It is important to note, however, that the server connection header
          SETTINGS frame might include parameters that necessarily alter
          how a client is expected to communicate with the server. Upon
          receiving the SETTINGS frame, the client is expected to honor any
          parameters established.
        </t>
        <t>
          Clients and servers MUST terminate the TCP connection if either
          peer does not begin with a valid connection header.  A
          <xref target="GOAWAY">GOAWAY frame</xref> MAY be omitted if it is
          clear that the peer is not using HTTP/2.0.
        </t>
      </section>
    </section>

    <section anchor="FramingLayer" title="HTTP Frames">
      <t>
        Once the HTTP/2.0 connection is established, endpoints
        can begin exchanging frames.
      </t>

      <section anchor="FrameHeader" title="Frame Header">
        <t>
          All frames begin with an 8-octet header followed by a payload of between 0 and 65,535 octets.
        </t>
        <figure title="Frame Header">
          <artwork type="inline">
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |         Length (16)           |   Type (8)    |   Flags (8)   |
 +-+-------------+---------------+-------------------------------+
 |R|                 Stream Identifier (31)                      |
 +-+-------------------------------------------------------------+
 |                   Frame Payload (0...)                      ...
 +---------------------------------------------------------------+
          </artwork>
        </figure>
        <t>
          The fields of the frame header are defined as:
          <list style="hanging">
            <t hangText="Length:">
              The length of the frame payload expressed as an unsigned 16-bit
              integer. The 8 octets of the frame header are not included
              in this value.
            </t>
            <t hangText="Type:">
              The 8-bit type of the frame.  The frame type determines how the remainder of the
              frame header and payload are interpreted.  Implementations MUST ignore unsupported
              and unrecognized frame types.
            </t>
            <t hangText="Flags:">
              An 8-bit field reserved for frame-type specific boolean flags.
              <vspace blankLines="1"/>
              Flags are assigned semantics specific to the indicated frame type.
              Flags that have no defined semantics for a particular frame type
              MUST be ignored, and MUST be left unset (0) when sending.
            </t>
            <t hangText="R:">
              A reserved 1-bit field.  The semantics of this bit are undefined
              and the bit MUST remain unset (0) when sending and MUST be ignored
              when receiving.
            </t>
            <t hangText="Stream Identifier:">
              A 31-bit stream identifier (see <xref target="StreamIdentifiers"/>).  A value 0 is
              reserved for frames that are associated with the connection as a
              whole as opposed to an individual stream.
            </t>
          </list>
        </t>
        <t>
          The structure and content of the frame payload is
          dependent entirely on the frame type.
        </t>
      </section>
      
      <section anchor="FrameSize" title="Frame Size">
        <t>
          The maximum size of a frame payload varies by frame type and
          use. The absolute maximum size
           is 65,535 octets. All implementations SHOULD be capable
          of receiving and minimally processing frames up to this size.
        </t>
        <t>
          Certain frame types, such as PING (see <xref target="PING"/>),
          impose additional limits on the amount of payload data allowed.
          Likewise, additional size limits can be set by specific
          application uses (see <xref target="HttpExtra" />).
        </t>
        <t>
          If a frame size exceeds any defined limit, or is too small to contain mandatory frame
          data, the endpoint MUST send a FRAME_TOO_LARGE error. Frame size errors in frames that
          affect connection-level state MUST be treated as a <xref
            target="ConnectionErrorHandler">connection error</xref>.
        </t>
      </section>

      <section anchor="HeaderBlock"  title="Header Compression and Decompression">
        <t>
          A header in HTTP/2.0 is a name-value pair with one or more associated values. They are
          used within HTTP request and response messages as well as server push operations (see
          <xref target="PushResources" />).
        </t>
        
        <t>
          Header sets are logical collections of zero or more header fields arranged at the
          application layer.  When transmitted over a connection, the header set is serialized into
          a header block using <xref target="COMPRESSION">HTTP Header Compression</xref>.  The
          serialized header block is then divided into one or more octet sequences,
          called header block fragments, and transmitted within the payload of <xref
          target="HEADERS">HEADERS</xref> or <xref target="PUSH_PROMISE">PUSH_PROMISE</xref> frames.
          The receiving endpoint reassembles the header block by concatenating the individual
          fragments, then decompresses the block to reconstruct the header set.
        </t>

        <t>
          Header block fragments can only be sent as the payload of HEADERS or PUSH_PROMISE frames.
        </t>

        <t>
          A compressed and encoded header block is transmitted in one or more HEADERS or
          PUSH_PROMISE frames.  If the number of octets in the block is greater than the space
          remaining in the frame, the block is divided into multiple fragments, which are then
          transmitted in multiple frames.
        </t>
        <t>
          Header blocks MUST be transmitted as a contiguous sequence of frames, with no interleaved
          frames of any other type, or from any other stream.  The last frame in a sequence of
          HEADERS frames MUST have the END_HEADERS flag set.  The last frame in a sequence of
          PUSH_PROMISE frames MUST have the END_PUSH_PROMISE flag set.
        </t>

        <t>
          HEADERS and PUSH_PROMISE frames carry data that can modify the compression context
          maintained by a receiver.  An endpoint receiving HEADERS or PUSH_PROMISE frames MUST
          reassemble header blocks and perform decompression even if the frames are to be discarded,
          which is likely to occur after a stream is reset.  A receiver MUST terminate the
          connection with a <xref target="ConnectionErrorHandler">connection error</xref> of type
          COMPRESSION_ERROR, if it does not decompress a header block.
        </t>
      </section>
    </section>

    <section anchor="StreamsLayer" title="Streams and Multiplexing">
        <t>
          A "stream" is an independent, bi-directional sequence of HEADER and DATA frames
          exchanged between the client and server within an HTTP/2.0 connection.
          Streams have several important characteristics:
          <list style="symbols">
            <t>
              A single HTTP/2.0 connection can contain multiple concurrently
              active streams, with either endpoint interleaving frames from
              multiple streams.
            </t>
            <t>
              Streams can be established and used unilaterally or shared by
              either the client or server.
            </t>
            <t>
              Streams can be closed by either endpoint.
            </t>
            <t>
              The order in which frames are sent within a stream is
              significant. Recipients process frames
              in the order they are received.
            </t>
            <t>
              Streams are identified by an integer.  Stream identifiers are
              assigned to streams by the endpoint that initiates a stream.
            </t>
          </list>
        </t>

     <section anchor="StreamStates" title="Stream States">
        <t>
          The lifecycle of a stream is shown in <xref target="StreamStatesFigure"/>.
        </t>

        <figure anchor="StreamStatesFigure" title="Stream States">
          <artwork>
            <![CDATA[
                       +--------+
                 PP    |        |    PP
              ,--------|  idle  |--------.
             /         |        |         \
            v          +--------+          v
     +----------+          |           +----------+
     |          |          | H         |          |
 ,---| reserved |          |           | reserved |---.
 |   | (local)  |          v           | (remote) |   |
 |   +----------+      +--------+      +----------+   |
 |      |          ES  |        |  ES          |      |
 |      | H    ,-------|  open  |-------.      | H    |
 |      |     /        |        |        \     |      |
 |      v    v         +--------+         v    v      |
 |   +----------+          |           +----------+   |
 |   |   half   |          |           |   half   |   |
 |   |  closed  |          | R         |  closed  |   |
 |   | (remote) |          |           | (local)  |   |
 |   +----------+          |           +----------+   |
 |        |                v                 |        |
 |        |  ES / R    +--------+  ES / R    |        |
 |        `----------->|        |<-----------'        |
 |  R                  | closed |                  R  |
 `-------------------->|        |<--------------------'
                       +--------+
]]>
          </artwork>
        </figure>

        <t>
          Both endpoints have a subjective view of the state of a stream that could be different
          when frames are in transit.  Endpoints do not coordinate the creation of streams, they are
          created unilaterally by either endpoint.
          The negative consequences of a mismatch in states are limited to the "closed" state
          after sending RST_STREAM, where frames might be received for some time after closing.
        </t>
        <t>
          Streams have the following states:
          <list style="hanging">

            <t hangText="idle:">
              <vspace blankLines="0"/>
              All streams start in the "idle" state.  In this state, no frames have been exchanged.
              <vspace blankLines="1"/>
              The following transitions are valid from this state:
              <list style="symbols">
                <t>
                  Sending or receiving a HEADERS frame causes the stream to become "open".  
                  The stream identifier is selected as described in <xref target="StreamIdentifiers"/>.
                </t>
                <t>
                  Sending a PUSH_PROMISE frame marks the associated stream for
                  later use.  The stream state for the reserved stream transitions to "reserved (local)".
                </t>
                <t>
                  Receiving a PUSH_PROMISE frame marks the associated stream as reserved by the 
                  remote peer.  The state of the stream becomes "reserved (remote)".
                </t>
              </list>
            </t>

            <t hangText="reserved (local):">
              <vspace blankLines="0"/>
              A stream in the "reserved (local)" state is one that has been promised by sending a PUSH_PROMISE frame.
              A PUSH_PROMISE frame reserves an idle stream by associating the stream with an open stream
              that was initiated by the remote peer (see <xref target="PushResources"/>).
              <vspace blankLines="1"/>
              In this state, only the following transitions are possible:
              <list style="symbols">
                <t>
                  The endpoint can send a HEADERS frame.  This causes the stream to open in a "half
                  closed (remote)" state.
                </t>
                <t>
                  Either endpoint can send a RST_STREAM frame to cause the stream to become
                  "closed".  This releases the stream reservation.
                </t>
              </list>
              An endpoint MUST NOT send any other type of frame in this state.  
            </t>

            <t hangText="reserved (remote):">
              <vspace blankLines="0"/>
              A stream in the "reserved (remote)" state has been reserved by a remote peer.
              <vspace blankLines="1"/>
              In this state, only the following transitions are possible:
              <list style="symbols">
                <t>
                  Receiving a HEADERS frame causes the stream to transition to "half closed (local)".
                </t>
                <t>
                  Either endpoint can send a RST_STREAM frame to cause the stream to become
                  "closed".  This releases the stream reservation.
                </t>
              </list>
              Receiving any other type of frame MUST be treated as a <xref target="StreamErrorHandler">stream
              error</xref> of type PROTOCOL_ERROR.
            </t>

            <t hangText="open:">
              <vspace blankLines="0"/>
              The "open" state is where both peers can send frames.  In this state, sending peers
              observe advertised <xref target="FlowControl">stream level flow control limits</xref>.
              <vspace blankLines="1"/>
              From this state either endpoint can send a frame with a END_STREAM flag set, which
              causes the stream to transition into one of the "half closed" states: an endpoint
              sending a END_STREAM flag causes the stream state to become "half closed (local)";
              an endpoint receiving a END_STREAM flag causes the stream state to become "half closed
              (remote)".
              <vspace blankLines="1"/>
              Either endpoint can send a RST_STREAM frame from this state, causing it to transition
              immediately to "closed".
            </t>

            <t hangText="half closed (local):">
              <vspace blankLines="0"/>
              A stream that is "half closed (local)" cannot be used for sending frames.
              <vspace blankLines="1"/>
              A stream transitions from this state to "closed" when a frame that contains
              a END_STREAM flag is received, or when either peer sends a RST_STREAM frame.
            </t>

            <t hangText="half closed (remote):">
              <vspace blankLines="0"/>
              A stream that is "half closed (remote)" is no longer being used by the peer to send frames.
              In this state, an endpoint is no longer obligated to maintain a receiver flow control
              window if it performs flow control.
              <vspace blankLines="1"/>
              If an endpoint receives additional frames for a stream that is in this state it MUST
              respond with a <xref target="StreamErrorHandler">stream error</xref> of type STREAM_CLOSED.
              <vspace blankLines="1"/>
              A stream can transition from this state to "closed" by sending
              a frame that contains a END_STREAM flag, or when either peer sends a RST_STREAM
              frame.
            </t>

            <t hangText="closed:">
              <vspace blankLines="0"/>
              The "closed" state is the terminal state.
              <vspace blankLines="1"/>
              An endpoint MUST NOT send frames on a closed stream.  An endpoint that receives a
              frame after receiving a RST_STREAM or a frame containing a END_STREAM flag on that stream
              MUST treat that as a <xref target="StreamErrorHandler">stream error</xref> of type
              STREAM_CLOSED.
              <vspace blankLines="1"/>
              If this state is reached as a result of sending a RST_STREAM frame, the peer that receives
              the RST_STREAM might have already sent - or enqueued for sending - frames on the
              stream that cannot be withdrawn.  An endpoint that sends a RST_STREAM frame MUST ignore
              frames that it receives on closed streams after it has sent a RST_STREAM frame.  An endpoint MAY
              choose to limit the period over which it ignores frames and treat frames that arrive
              after this time as being in error.
              <vspace blankLines="1"/>
              An endpoint might receive a PUSH_PROMISE frame after it sends RST_STREAM.
              PUSH_PROMISE causes a stream to become "reserved".  If promised streams are not
              desired, a RST_STREAM can be used to close any of those streams.
            </t>
          </list>
        </t>

        <section anchor="StreamIdentifiers" title="Stream Identifiers">
          <t>
            Streams are identified with an unsigned 31-bit integer.  Streams initiated by a client
            MUST use odd-numbered stream identifiers; those initiated by the server MUST use even-numbered
            stream identifiers.  A stream identifier of zero (0x0) is used for connection control
            message; the stream identifier zero MUST NOT be used to establish a new stream.
          </t>
          <t>
            The identifier of a newly established stream MUST be numerically greater than all
            streams that the initiating endpoint has opened or reserved.  This governs streams that 
            are opened using a HEADERS frame and streams that are reserved using PUSH_PROMISE.  
            An endpoint that receives an unexpected stream identifier MUST respond with a
            <xref target="ConnectionErrorHandler">connection error</xref> of type PROTOCOL_ERROR.
          </t>
          <t>
            Stream identifiers cannot be reused.  Long-lived connections can
            result in endpoint exhausting the available range of stream identifiers. A client that
            is unable to establish a new stream identifier can establish a new connection for new
            streams.
          </t>
        </section>
        
        <section title="Stream Concurrency">
          <t>
            A peer can limit the number of concurrently active streams using the
            SETTINGS_MAX_CONCURRENT_STREAMS parameters within a SETTINGS frame. The maximum
            concurrent streams setting is specific to each endpoint and applies only to the peer
            that receives the setting. That is, clients specify the maximum number of concurrent
            streams the server can initiate, and servers specify the maximum number of concurrent
            streams the client can initiate.  Endpoints MUST NOT exceed the limit set by their
            peer.
          </t>
          <t>
            Streams that are in the "open" state, or either of the "half closed" states count
            toward the maximum number of streams that an endpoint is permitted to open.  Streams
            in any of these three states count toward the limit advertised in the
            SETTINGS_MAX_CONCURRENT_STREAMS setting (see <xref target="SettingValues"/>).
          </t>
          <t>
            Streams in either of the "reserved" states do not count as open, even if a small amount of
            application state is retained to ensure that the promised stream can be successfully used.
          </t>
        </section>
      </section>

     <section anchor="FlowControl" title="Flow Control">
        <!-- details -->
        <t>
          Using streams for multiplexing introduces contention over use of the TCP connection,
          resulting in blocked streams.  A flow control scheme ensures that streams on the same
          connection do not destructively interfere with each other.  Flow control is used for both
          individual streams and for the connection as a whole.
        </t>
        <t>
          HTTP/2.0 provides for flow control through use of the
          <xref target="WINDOW_UPDATE">WINDOW_UPDATE</xref> frame type.
        </t>

        <section anchor="fc-principles" title="Flow Control Principles">
          <t>
            Experience with TCP congestion control has shown that algorithms can evolve over time to
            become more sophisticated without requiring protocol changes.  TCP congestion control
            and its evolution is clearly different from HTTP/2.0 flow control, though the evolution
            of TCP congestion control algorithms shows that a similar approach could be feasible for
            HTTP/2.0 flow control.
          </t>
          <t>
            HTTP/2.0 stream flow control aims to allow for future improvements to flow control
            algorithms without requiring protocol changes.  Flow control in HTTP/2.0 has the
            following characteristics:
            <list style="numbers">
              <t>
                Flow control is hop-by-hop, not end-to-end.
              </t>
              <t>
                Flow control is based on window update frames.  Receivers advertise how many
                bytes they are prepared to receive on a stream and for the entire connection.
                This is a credit-based scheme.
              </t>
              <t>
                Flow control is directional with overall control provided by the receiver.  A
                receiver MAY choose to set any window size that it desires for each stream and for
                the entire connection.  A sender MUST respect flow control limits imposed by a
                receiver.  Clients, servers and intermediaries all independently advertise their
                flow control preferences as a receiver and abide by the flow control limits set by
                their peer when sending.
              </t>
              <t>
                The initial value for the flow control window is 65536 bytes for both new streams
                and the overall connection.
              </t>
              <t>
                The frame type determines whether flow control applies to a frame.  Of the frames
                specified in this document, only DATA frames are subject to flow control; all other
                frame types do not consume space in the advertised flow control window.  This
                ensures that important control frames are not blocked by flow control.
              </t>
              <t>
                Flow control can be disabled by a receiver.  A receiver can choose to either disable
                flow control for a stream or connection by sending a window update frame with a specific
                flag. See <xref target="EndFlowControl">Ending Flow Control</xref> for more details.
              </t>
              <t>
                HTTP/2.0 standardizes only the format of the <xref target="WINDOW_UPDATE">
                  WINDOW_UPDATE frame
                </xref>.  This does not stipulate how a receiver decides when to send
                this frame or the value that it sends.  Nor does it specify how a sender chooses
                to send packets.  Implementations are able to select any algorithm that suits their
                needs.
              </t>
            </list>
          </t>
          <t>
            Implementations are also responsible for managing how requests and responses are sent
            based on priority; choosing how to avoid head of line blocking for requests; and
            managing the creation of new streams.  Algorithm choices for these could interact with
            any flow control algorithm.
          </t>

        </section>
        
        <section anchor="DisableFlowControl" title="Appropriate Use of Flow Control">
          <t>
            Flow control is defined to protect endpoints that are operating under resource constraints.
            For example, a proxy needs to share memory between many
            connections, and also might have a slow upstream connection and a fast downstream one.
            Flow control addresses cases where the receiver is unable process data on
            one stream, yet wants to continue to process other streams in the same connection.
          </t>
          <t>
            Deployments that do not require this capability SHOULD disable flow control for data
            that is being received.  Note that flow control cannot be disabled for sending.
            Sending data is always subject to the flow control window advertised by the receiver.
          </t>
          <t>
            Deployments with constrained resources (for example, memory) MAY employ flow control to
            limit the amount of memory a peer can consume.  Note, however, that this can lead to
            suboptimal use of available network resources if flow control is enabled without
            knowledge of the bandwidth-delay product (see <xref target="RFC1323"/>).
          </t>
          <t>
            Even with full awareness of the current bandwidth-delay product, implementation of flow control
            is difficult. However, it can ensure that constrained resources are protected without any
            reduction in connection utilization.
          </t>
        </section>
      </section>
      
      <section anchor="StreamPriority" title="Stream priority">
        <t>
          The endpoint establishing a new stream can assign a priority for the stream.  Priority
          is represented as an unsigned 31-bit integer.  0 represents the highest priority and
          2<x:sup>31</x:sup>-1 represents the lowest priority.
        </t>

        <t>
          The purpose of this value is to allow the initiating endpoint to request that frames for
          the stream be processed with a specified priority relative to other concurrently active
          streams. That is, if an endpoint receives interleaved frames for multiple streams, the
          endpoint ought to make a best-effort attempt at processing frames for higher priority
          streams before processing those for lower priority streams.
        </t>

        <t>
          Explicitly setting the priority for a stream does not guarantee any particular
          processing order for the stream relative to any other stream. Nor is there any
          mechanism provided by which the initiator of a stream can force or require a receiving
          endpoint to process frames from one stream before processing frames from another.
        </t>

        <t>
          Unless explicitly specified in the <xref target="HEADERS">HEADERS frame</xref> during stream creation,
          the default stream priority is 2<x:sup>30</x:sup>.

          <!--PUSH_PROMISE has no priority, so "If priority is not assigned through other means,"
              wouldn't apply below-->
          <xref target="PushResources">Pushed streams</xref>
          are assumed to inherit the priority of the associated stream plus one
          (or 2<x:sup>31</x:sup>-1 if the the associated stream priority is 2<x:sup>31</x:sup>-1),
          i.e. they have priority one lower than the associated stream.
        </t>

      </section>

      <section title="Error Handling">
        <t>
          HTTP/2.0 framing permits two classes of error:
          <list style="symbols">
            <t>
              An error condition that renders the entire connection unusable is a connection error.
            </t>
            <t>
              An error in an individual stream is a stream error.
            </t>
          </list>
        </t>

        <t>
          A list of error codes is included in <xref target="ErrorCodes"/>.
        </t>

        <section anchor="ConnectionErrorHandler" title="Connection Error Handling">
          <t>
            A connection error is any error which prevents further processing of the framing layer or
            which corrupts any connection state.
          </t>
          <t>
            An endpoint that encounters a connection error SHOULD first send a <xref
            target="GOAWAY">GOAWAY</xref> frame with the stream identifier of the last stream that
            it successfully received from its peer.  The GOAWAY frame includes an error code that
            indicates why the connection is terminating.  After sending the GOAWAY frame, the endpoint
            MUST close the TCP connection.
          </t>
          <t>
            It is possible that the GOAWAY will not be reliably received by the receiving endpoint.
            In the event of a connection error, GOAWAY only provides a best-effort attempt to
            communicate with the peer about why the connection is being terminated.
          </t>
          <t>
            An endpoint can end a connection at any time.  In particular, an endpoint MAY choose to
            treat a stream error as a connection error if the error is recurrent.  Endpoints SHOULD
            send a GOAWAY frame when ending a connection, as long as circumstances permit it.
          </t>
        </section>

        <section anchor="StreamErrorHandler" title="Stream Error Handling">
          <t>
            A stream error is an error related to a specific stream identifier that does not affect
            processing of other streams.
          </t>
          <t>
            An endpoint that detects a stream error sends a <xref
            target="RST_STREAM">RST_STREAM</xref> frame that contains the stream identifier of the
            stream where the error occurred.  The RST_STREAM frame includes an error code that
            indicates the type of error.
          </t>
          <t>
            A RST_STREAM is the last frame that an endpoint can send on a stream.  The peer that
            sends the RST_STREAM frame MUST be prepared to receive any frames that were sent or
            enqueued for sending by the remote peer.  These frames can be ignored, except where they
            modify connection state (such as the state maintained for <xref
            target="HeaderBlock">header compression</xref>).
          </t>
          <t>
            Normally, an endpoint SHOULD NOT send more than one RST_STREAM frame for any
            stream. However, an endpoint MAY send additional RST_STREAM frames if it receives frames
            on a closed stream after more than a round trip time.  This behavior is permitted to
            deal with misbehaving implementations.
          </t>
          <t>
            An endpoint MUST NOT send a RST_STREAM in response to an RST_STREAM frame, to avoid
            looping.
          </t>
        </section>

        <section title="Connection Termination">
          <t>
            If the TCP connection is torn down while streams remain in open or half closed states, then 
            the endpoint MUST assume that the stream was abnormally interrupted and
            could be incomplete.
          </t>
        </section>
      </section>
    </section>

    <section  anchor="frame-types" title="Frame Definitions">

        <t>
          This specification defines a number of frame types,
          each identified by a unique 8-bit type code. Each frame
          type serves a distinct purpose either in the establishment and
          management of the connection as a whole, or of individual streams.
        </t>

        <t>
          The transmission of specific frame types can alter the state of
          a connection. If endpoints fail to maintain a synchronized view
          of the connection state, successful communication within the connection
          will no longer be possible. Therefore, it is important that endpoints
          have a shared comprehension of how the state is affected by the use
          any given frame. Accordingly, while it is expected that new frame
          types will be introduced by extensions to this protocol, only frames
          defined by this document are permitted to alter the connection state.
        </t>

        <section anchor="DATA" title="DATA">
          <t>
            DATA frames (type=0x0) convey arbitrary, variable-length
            sequences of octets associated with a stream. One or more
            DATA frames are used, for instance, to carry HTTP request
            or response payloads.
          </t>

          <t>
            The DATA frame defines the following flags:
            <list style="hanging">
              <t hangText="END_STREAM (0x1):">
                Bit 1 being set indicates that this frame is the last that the endpoint
                will send for the identified stream.  Setting this flag causes the stream
                to enter a <xref target="StreamStates">"half closed" state</xref>.
              </t>
              <t hangText="RESERVED (0x2):">
                Bit 2 is reserved for future use.
              </t>
            </list>
          </t>

          <t>
            DATA frames MUST be associated with a stream. If a DATA frame is
            received whose stream identifier field is 0x0, the recipient MUST
            respond with a <xref target="ConnectionErrorHandler">connection error</xref>
            of type PROTOCOL_ERROR.
          </t>

        </section>

        <section anchor="HEADERS" title="HEADERS">
          <t>
            The HEADERS frame (type=0x1) carries name-value pairs.  
            The HEADERS is used to <xref target="StreamStates">open a stream</xref>.
            Any number of HEADERS frames can be sent on an existing stream at any time.
          </t>
          <figure title="HEADERS Frame Payload">
            <artwork type="inline">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |X|                        Priority (31)                        |
 +-+-------------------------------------------------------------+
 |                   Header Block Fragment (*)                 ...
 +---------------------------------------------------------------+
            </artwork>
          </figure>

          <t>
            The HEADERS frame defines the following flags:
            <list style="hanging">
              <t hangText="END_STREAM (0x1):">
                Bit 1 being set indicates that this frame is the last that the endpoint
                will send for the identified stream.  Setting this flag causes the stream
                to enter a <xref target="StreamStates">"half closed" state</xref>.
              </t>
              <t hangText="RESERVED (0x2):">
                Bit 2 is reserved for future use.
              </t>
              <t hangText="END_HEADERS (0x4):">
                The END_HEADERS bit indicates that this frame ends the sequence of header block fragments
                necessary to provide a complete set of headers.
                <vspace blankLines="1"/>
                The payload for a complete header block is provided by a sequence of HEADERS
                frames, terminated by a HEADERS frame with the END_HEADERS flag set.  Once the sequence
                terminates, the payload of all HEADERS frames are concatenated and interpreted as a
                single block.
                <vspace blankLines="1"/>
                A HEADERS frame without the END_HEADERS flag set MUST be followed by a HEADERS frame
                for the same stream.  A receiver MUST treat the receipt of any other type of frame
                or a frame on a different stream as a <xref
                target="ConnectionErrorHandler">connection error</xref> of type PROTOCOL_ERROR.
              </t>
              <t hangText="PRIORITY (0x8):">
                Bit 4 being set indicates that the first four octets of this frame contain a
                single reserved bit and a 31-bit priority; see <xref target="StreamPriority"/>.  
                If this bit is not set, the four bytes do not appear and the frame only contains a
                header block fragment.
              </t>
            </list>
          </t>

          <t>
            The payload of a HEADERS frame contains a <xref target="HeaderBlock">header block
            fragment</xref>.
          </t>

          <t>
            HEADERS frames MUST be associated with a stream. If a HEADERS frame is received
            whose stream identifier field is 0x0, the recipient MUST respond with a
            <xref target="ConnectionErrorHandler">connection error</xref> of type
            PROTOCOL_ERROR.
          </t>

          <t>
            The HEADERS frame changes the connection state as defined in <xref target="HeaderBlock" />.
          </t>

        </section>

        <section anchor="PRIORITY" title="PRIORITY">
          <t>
            The PRIORITY frame (type=0x2) specifies the sender-advised priority of a stream.
            It can be sent at any time for an existing stream. This enables
            reprioritisation of existing streams.
          </t>
          <figure title="PRIORITY Frame Payload">
            <artwork type="inline">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |X|                        Priority (31)                        |
 +-+-------------------------------------------------------------+
            </artwork>
          </figure>
          <t>
            The payload of a PRIORITY frame contains a single reserved bit and a
            31-bit priority.
          </t>

          <t>
            The PRIORITY frame does not define any flags.
          </t>

          <t>
            The PRIORITY frame is associated with an existing stream. If
            a PRIORITY frame is received with a stream identifier of 0x0,
            the recipient MUST respond with a
            <xref target="ConnectionErrorHandler">connection error</xref> of type
            PROTOCOL_ERROR.
          </t>
        </section>

        <section anchor="RST_STREAM" title="RST_STREAM">
          <t>
            The RST_STREAM frame (type=0x3) allows for abnormal termination of a stream.  When sent by
            the initiator of a stream, it indicates that they wish to cancel the stream or
            that an error condition has occurred.  When
            sent by the receiver of a stream, it indicates that either the
            receiver is rejecting the stream, requesting that the stream be
            cancelled or that an error condition has occurred.
          </t>
          <figure title="RST_STREAM Frame Payload">
            <artwork type="inline">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                        Error Code (32)                        |
 +---------------------------------------------------------------+
            </artwork>
          </figure>

          <t>
            The RST_STREAM frame contains a single unsigned,
            32-bit integer identifying the <xref target="ErrorCodes">error code</xref>.
            The error code indicates why the stream is being terminated.
          </t>

          <t>
            The RST_STREAM frame does not define any flags.
          </t>

          <t>
            The RST_STREAM frame fully terminates the referenced stream
            and causes it to enter the closed state. After receiving a
            RST_STREAM on a stream, the receiver MUST NOT send additional
            frames for that stream. However, after sending the RST_STREAM,
            the sending endpoint MUST be prepared to receive and process
            additional frames sent on the stream that might have been sent
            by the peer prior to the arrival of the RST_STREAM.
          </t>

          <t>
            RST_STREAM frames MUST be associated with a stream. If a
            RST_STREAM frame is received whose stream
            identifier field is 0x0 the recipient MUST respond with a
            <xref target="ConnectionErrorHandler">connection error</xref> of type
            PROTOCOL_ERROR.
          </t>

        </section>

        <section anchor="SETTINGS" title="SETTINGS">
          <t>
            The SETTINGS frame (type=0x4) conveys configuration parameters that affect how endpoints
            communicate. The parameters are either constraints on peer behavior or preferences.
          </t>

          <t>
            SETTINGS frames MUST be sent at the start of a connection, and MAY
            be sent at any other time by either endpoint over the lifetime
            of the connection.
          </t>

          <t>
            Implementations MUST support all of the settings defined by this
            specification and MAY support additional settings defined by
            extensions. Unsupported or unrecognized settings MUST be ignored.
            New settings MUST NOT be defined or implemented in a way that
            requires endpoints to understand them in order to communicate
            successfully.
          </t>

          <t>
            A SETTINGS frame is not required to include every defined
            setting; senders can include only those parameters for which it
            has accurate values and a need to convey. When multiple parameters
            are sent, they SHOULD be sent in order of numerically lowest ID to
            highest ID.  A single SETTINGS frame MUST NOT contain multiple values for the same ID.  If the
            receiver of a SETTINGS frame discovers multiple values for the same ID, it MUST ignore
            all values for that ID except the first one.
          </t>
          <t>
            Over the lifetime of a connection, an endpoint MAY send multiple SETTINGS frames
            containing previously unspecified parameters or new values for parameters whose values
            have already been established. Only the most recent provided setting value
            applies.
          </t>
          <t>
            The SETTINGS frame does not define any flags.
          </t>
          <t>
            SETTINGS frames always apply to a connection, never a single stream.
            The stream identifier for a settings frame MUST be zero. If an
            endpoint receives a SETTINGS frame whose stream identifier field
            is anything other than 0x0, the endpoint MUST respond with a
            <xref target="ConnectionErrorHandler">connection error</xref> of type
            PROTOCOL_ERROR.
          </t>
          <t>
            The SETTINGS frame affects connection state.  A badly formed or incomplete SETTINGS
            frame MUST be treated as a <xref target="ConnectionErrorHandler">
              connection
              error
            </xref>.
          </t>

          <section title="Setting Format" anchor="SettingFormat">
            <t>
              The payload of a SETTINGS frame consists of zero or more settings.  Each setting
              consists of an 8-bit reserved field, an unsigned 24-bit setting identifier, and an
              unsigned 32-bit value.
            </t>

            <figure title="Setting Format">
              <artwork type="inline">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |  Reserved (8) |            Setting Identifier (24)            |
 +---------------+-----------------------------------------------+
 |                        Value (32)                             |
 +---------------------------------------------------------------+
              </artwork>
            </figure>
          </section>

          <section anchor="SettingValues" title="Defined Settings">
            <t>
              The following settings are defined:
              <list style="hanging">
                <x:lt hangText="SETTINGS_MAX_CONCURRENT_STREAMS (4):">
                  <t>
                    indicates the maximum number of concurrent streams that the sender will allow.
                    This limit is directional: it applies to the number
                    of streams that the sender permits the receiver to create. By default there is no
                    limit.  It is recommended that this value be no smaller than 100,
                    so as to not unnecessarily limit parallelism.
                  </t>
                </x:lt>
                <x:lt hangText="SETTINGS_INITIAL_WINDOW_SIZE (7):">
                  <t>
                    indicates the sender's initial window size (in bytes) for stream level flow control.
                  </t>
                  <t>
                    This settings affects the window size of all streams, including existing streams,
                    see <xref target="InitialWindowSize"/>.
                  </t>
                </x:lt>
                <x:lt hangText="SETTINGS_FLOW_CONTROL_OPTIONS (10):">
                  <t>
                    indicates that streams directed to the sender will not
                    be subject to flow control.  The least significant bit (0x1) of the value is set to indicate
                    that new streams are not flow controlled.  All other bits are reserved.
                  </t>
                  <t>
                    This setting applies to all streams, including existing streams.
                  </t>
                  <t>
                    These bits cannot be cleared once set, see <xref target="EndFlowControl"/>.
                  </t>
                </x:lt>
              </list>
            </t>

          </section>
        </section>

        <section anchor="PUSH_PROMISE" title="PUSH_PROMISE">

          <t>
            The PUSH_PROMISE frame (type=0x5) is used to notify the peer
            endpoint in advance of streams the sender intends to initiate.
            The PUSH_PROMISE frame includes the unsigned 31-bit identifier
            of the stream the endpoint plans to create along with a minimal
            set of headers that provide additional context for the stream.
            <xref target="PushResources"/> contains a thorough description
            of the use of PUSH_PROMISE frames.
          </t>

          <figure title="PUSH_PROMISE Payload Format">
            <artwork type="inline">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |X|                Promised-Stream-ID (31)                      |
 +-+-------------------------------------------------------------+
 |                 Header Block Fragment (*)                   ...
 +---------------------------------------------------------------+
            </artwork>
          </figure>

          <t>
            The payload of a PUSH_PROMISE includes a "Promised-Stream-ID".  This
            unsigned 31-bit integer identifies the stream the endpoint
            intends to start sending frames for.  The promised stream
            identifier MUST be a valid choice for the next stream sent by the sender (see <xref
            target="StreamIdentifiers">new stream identifier</xref>).
          </t>
          
          <t>
            Following the "Promised-Stream-ID" is a <xref target="HeaderBlock">header block
            fragment</xref>.
          </t>

          <t>
            PUSH_PROMISE frames MUST be associated with an existing, peer-initiated stream. If
            the stream identifier field specifies the value 0x0, a recipient
            MUST respond with a <xref target="ConnectionErrorHandler">
            connection error </xref> of type PROTOCOL_ERROR.
          </t>

          <t>
            The PUSH_PROMISE frame defines the following flags:
            <list style="hanging">
              <t hangText="END_PUSH_PROMISE (0x1):">
                The END_PUSH_PROMISE bit indicates that this frame ends the sequence of header block fragments
                necessary to provide a complete set of headers.
                <vspace blankLines="1"/>
                The payload for a complete header block is provided by a sequence of PUSH_PROMISE
                frames, terminated by a PUSH_PROMISE frame with the END_PUSH_PROMISE flag set.
                Once the sequence terminates, the payload of all PUSH_PROMISE frames are concatenated
                and interpreted as a single block.
                <vspace blankLines="1"/>
                A PUSH_PROMISE frame without the END_PUSH_PROMISE flag set MUST be followed by a
                PUSH_PROMISE frame for the same stream.  A receiver MUST treat the receipt of any
                other type of frame or a frame on a different stream as a <xref
                target="ConnectionErrorHandler">connection error</xref> of type PROTOCOL_ERROR.
              </t>
            </list>
          </t>

          <t>
            Promised streams are not required to be used in order promised.
            The PUSH_PROMISE only reserves stream identifiers for later use.
          </t>

          <t>
            Recipients of PUSH_PROMISE frames can choose to reject promised
            streams by returning a RST_STREAM referencing the promised stream
            identifier back to the sender of the PUSH_PROMISE.
          </t>

          <t>
            The PUSH_PROMISE frame modifies the connection state as
            defined in <xref target="HeaderBlock" />.
          </t>

        </section>

        <section anchor="PING" title="PING">
          <t>
            The PING frame (type=0x6) is a mechanism for measuring a minimal round-trip time from the
            sender, as well as determining whether an idle connection is still functional.
            PING frames can be sent from any endpoint.
          </t>
          <figure title="PING Payload Format">
            <artwork type="inline">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 |                      Opaque Data (64)                         |
 |                                                               |
 +---------------------------------------------------------------+
            </artwork>
          </figure>

          <t>
            In addition to the frame header, PING frames MUST contain 8 octets of data in the
            payload.  A sender can include any value it chooses and use those bytes in any fashion.
          </t>
          <t>
            Receivers of a PING frame that does not include a PONG flag MUST send a PING frame with
            the PONG flag set in response, with an identical payload.  PING responses SHOULD given
            higher priority than any other frame.
          </t>

          <t>
            The PING frame defines the following flags:
            <list style="hanging">
              <t hangText="PONG (0x1):">
                Bit 1 being set indicates that this PING frame is a PING response.  An endpoint MUST
                set this flag in PING responses.  An endpoint MUST NOT respond to PING frames
                containing this flag.
              </t>
            </list>
          </t>
          <t>
            PING frames are not associated with any individual stream. If a PING frame is received
            with a stream identifier field value other than 0x0, the recipient MUST respond with a
            <xref target="ConnectionErrorHandler">connection error</xref> of type PROTOCOL_ERROR.
          </t>
          <t>
            Receipt of a PING frame with a length field value other than 8 MUST be treated as a
            <xref target="ConnectionErrorHandler">connection error</xref> of type PROTOCOL_ERROR.
          </t>

        </section>

        <section anchor="GOAWAY" title="GOAWAY">
          <t>
            The GOAWAY frame (type=0x7) informs the remote peer to stop creating
            streams on this connection.  It can be sent from the client or the server. Once sent, the
            sender will ignore frames sent on new streams for the remainder of the
            connection. Receivers of a GOAWAY frame MUST NOT open additional streams on the connection,
            although a new connection can be established for new streams.  The purpose of this frame
            is to allow an endpoint to gracefully stop accepting new streams (perhaps for a reboot
            or maintenance), while still finishing processing of previously established streams.
          </t>
          <t>
            There is an inherent race condition between an endpoint starting new streams and the
            remote sending a GOAWAY frame.  To deal with this case, the GOAWAY contains the stream
            identifier of the last stream which was processed on the sending endpoint in this
            connection.  If the receiver of the GOAWAY used streams that are newer than the indicated
            stream identifier, they were not processed by the sender and the receiver may treat the
            streams as though they had never been created at all (hence the receiver may want to
            re-create the streams later on a new connection).
          </t>
          <t>
            Endpoints SHOULD always send a GOAWAY frame before closing a connection so that the
            remote can know whether a stream has been partially processed or not.  For example, if
            an HTTP client sends a POST at the same time that a server closes a connection, the
            client cannot know if the server started to process that POST request if the server does
            not send a GOAWAY frame to indicate where it stopped working.  An endpoint might choose
            to close a connection without sending GOAWAY for misbehaving peers.
          </t>

          <t>
            After sending a GOAWAY frame, the sender can discard frames for new streams.  However,
            any frames that alter connection state cannot be completely ignored.  For instance,
            HEADERS and PUSH_PROMISE frames MUST be minimally processed to ensure a consistent
            compression state (see <xref target="HeaderBlock"/>).
          </t>

          <figure title="GOAWAY Payload Format">
            <artwork type="inline">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |X|                  Last-Stream-ID (31)                        |
 +-+-------------------------------------------------------------+
 |                      Error Code (32)                          |
 +---------------------------------------------------------------+
 |                  Additional Debug Data (*)                    |
 +---------------------------------------------------------------+
            </artwork>
          </figure>
          <t>
            The GOAWAY frame does not define any flags.
          </t>
          <t>
            The GOAWAY frame applies to the connection, not a specific stream.  The stream identifier
            MUST be zero.
          </t>
          <t>
            The last stream identifier in the GOAWAY frame contains the highest numbered stream
            identifier for which the sender of the GOAWAY frame has received frames on and might
            have taken some action on.  All streams up to and including the identified stream might
            have been processed in some way.  The last stream identifier is set to 0 if no streams
            were processed.
            <list>
              <t>
                Note: In this case, "processed" means that some data from the stream was passed to
                some higher layer of software that might have taken some action as a result.
              </t>
            </list>
          </t>
          <t>
            On streams with lower or equal numbered identifiers that were not closed completely prior
            to the connection being closed, re-attempting requests, transactions, or any protocol
            activity is not possible (with the exception of idempotent actions like HTTP GET, PUT,
            or DELETE).  Any protocol activity that uses higher numbered streams can be safely
            retried using a new connection.
          </t>
          <t>
            Activity on streams numbered lower or equal to the last stream identifier might still complete
            successfully.  The sender of a GOAWAY frame might gracefully shut down a connection by sending
            a GOAWAY frame, maintaining the connection in an open state until all in-progress
            streams complete.
          </t>
          <t>
            The last stream ID MUST be 0 if no streams were acted upon.
          </t>
          <t>
            The GOAWAY frame also contains a 32-bit <xref target="ErrorCodes">error code</xref> that
            contains the reason for closing the connection.
          </t>
          <t>
            In addition to any other metadata, endpoints MAY append opaque data to the payload of
            any GOAWAY frame. The length of this data is reflected in the length field in the frame
            header. This data is to be used strictly for debugging purposes and has no semantic effect at
            protocol or application levels. As it may contain sensitive information, said debug data
            MUST NOT be persistently stored.
          </t>
        </section>

        <section anchor="WINDOW_UPDATE" title="WINDOW_UPDATE">
          <t>
            The WINDOW_UPDATE frame (type=0x9) is used to implement flow control.
          </t>
          <t>
            Flow control operates at two levels: on each individual stream and on the
            entire connection.
          </t>
          <t>
            Both types of flow control are hop by hop; that is, only between the two endpoints.
            Intermediaries do not forward WINDOW_UPDATE frames between
            dependent connections.  However, throttling of data transfer by any receiver can
            indirectly cause the propagation of flow control information toward the original
            sender.
          </t>
          <t>
            Flow control only applies to frames that are identified as being subject to flow
            control. Of the frame types defined in this document, this includes only DATA frame.
            Frames that are exempt from flow control MUST be accepted and processed, unless the
            receiver is unable to assign resources to handling the frame.  A receiver MAY respond
            with a <xref target="StreamErrorHandler">stream error</xref> or <xref
            target="ConnectionErrorHandler">connection error</xref> of type FLOW_CONTROL_ERROR if it
            is unable accept a frame.
          </t>
          <figure title="WINDOW_UPDATE Payload Format">
            <artwork type="inline">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |X|              Window Size Increment (31)                     |
 +-+-------------------------------------------------------------+
            </artwork>
          </figure>
          <t>
            The payload of a WINDOW_UPDATE frame is one reserved bit, plus an unsigned 31-bit
            integer indicating the number of bytes that the sender can transmit in addition to the
            existing flow control window.  The legal range for the increment to the flow control
            window is 1 to 2<x:sup>31</x:sup> - 1 (0x7fffffff) bytes.
          </t>
          <t>
            The WINDOW_UPDATE frame defines the following flags:
            <list style="hanging">
              <t hangText="END_FLOW_CONTROL (0x1):">
                Bit 1 being set indicates that flow control for the identified stream or connection has been
                ended; subsequent frames do not need to be flow controlled.
              </t>
            </list>
          </t>
          <t>
            The WINDOW_UPDATE frame can be specific to a stream or to the entire connection.
            In the former case, the frame's stream identifier indicates the affected stream;
            in the latter, the value "0" indicates that the entire connection is the subject of
            the frame.
          </t>

          <section title="The Flow Control Window">
            <t>
              Flow control in HTTP/2.0 is implemented using a window kept by each sender on every
              stream. The flow control window is a simple integer value that indicates how many
              bytes of data the sender is permitted to transmit; as such, its size is a
              measure of the buffering capability of the receiver.
            </t>
            <t>
              Two flow control windows are applicable; the stream flow
              control window and the connection flow control window.  The sender MUST NOT send a flow
              controlled frame with a length that exceeds the space available in either of the flow
              control windows advertised by the receiver.  Frames with zero length with the END_STREAM
              flag set (for example, an empty data frame) MAY be sent if there is no available space
              in either flow control window.
            </t>
            <t>
              For flow control calculations, the 8 byte frame header is not counted.
            </t>
            <t>
              After sending a flow controlled frame, the sender reduces the space available in both
              windows by the length of the transmitted frame.
            </t>
            <t>
              The receiver of a frame sends a WINDOW_UPDATE frame as it consumes data and frees up
              space in flow control windows.  Separate WINDOW_UPDATE frames are sent for the
              stream and connection level flow control windows.
            </t>
            <t>
              A sender that receives a WINDOW_UPDATE frame updates the corresponding window by the
              amount specified in the frame.
            </t>
            <t>
              A sender MUST NOT allow a flow control window to exceed 2<x:sup>31</x:sup> - 1 bytes.
              If a sender receives a WINDOW_UPDATE that causes a flow control window to exceed this
              maximum it MUST terminate either the stream or the connection, as appropriate.  For
              streams, the sender sends a RST_STREAM with the error code of FLOW_CONTROL_ERROR code;
              for the connection, a GOAWAY frame with a FLOW_CONTROL_ERROR code.
            </t>
            <t>
              Flow controlled frames from the sender and WINDOW_UPDATE frames from the receiver are
              completely asynchronous with respect to each other. This property allows a receiver to
              aggressively update the window size kept by the sender to prevent streams from
              stalling.
            </t>
          </section>

          <section anchor="InitialWindowSize" title="Initial Flow Control Window Size">
            <t>
              When a HTTP/2.0 connection is first established, new streams are created with an
              initial flow control window size of 65535 bytes. The connection flow control window is
              65535 bytes.  Both endpoints can adjust the initial window size for new streams by
              including a value for SETTINGS_INITIAL_WINDOW_SIZE in the SETTINGS frame that forms
              part of the connection header.
            </t>
            <t>
              Prior to receiving a SETTINGS frame that sets a value for
              SETTINGS_INITIAL_WINDOW_SIZE, an endpoint can only use the default initial window size
              when sending flow controlled frames.  Similarly, the connection flow control window is
              set to the default initial window size until a WINDOW_UPDATE frame is received.
            </t>
            <t>
              A SETTINGS frame can alter the initial flow control window size for all current
              streams. When the value of SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST
              adjust the size of all stream flow control windows that it maintains by the difference
              between the new value and the old value. A SETTINGS frame cannot alter the connection
              flow control window.
            </t>
            <t>
              A change to SETTINGS_INITIAL_WINDOW_SIZE could cause the available space in a flow
              control window to become negative.  A sender MUST track the negative flow control
              window, and MUST NOT send new flow controlled frames until it receives WINDOW_UPDATE
              frames that cause the flow control window to become positive.
            </t>
            <t>
	      For example, if the client sends 64KB immediately on connection establishment, and the
	      server sets the initial window size to be 16KB, the client will recalculate the
              available flow control window to be -48KB on receipt of the SETTINGS frame.  The
              client retains a negative flow control window until WINDOW_UPDATE frames restore the
              window to being positive, after which the client can resume sending.
            </t>
          </section>

          <section title="Reducing the Stream Window Size">
            <t>
              A receiver that wishes to use a smaller flow control window than the current size
              can send a new SETTINGS frame.  However, the receiver MUST be prepared to receive data
              that exceeds this window size, since the sender might send data that exceeds the lower
              limit prior to processing the SETTINGS frame.
            </t>
            <t>
              A receiver has two options for handling streams that exceed flow control limits:
              <list style="numbers">
                <t>
                  The receiver can immediately send RST_STREAM with FLOW_CONTROL_ERROR error code
                  for the affected streams.
                </t>
                <t>
                  The receiver can accept the streams and tolerate the resulting head of line
                  blocking, sending WINDOW_UPDATE frames as it consumes data.
                </t>
              </list>
              If a receiver decides to accept streams, both sides MUST recompute the available flow
              control window based on the initial window size sent in the SETTINGS.
            </t>
          </section>

          <section anchor="EndFlowControl" title="Ending Flow Control">
            <t>
              After a receiver reads in a frame that marks the end of a stream (for example, a data
              stream with a END_STREAM flag set), it MUST cease transmission of WINDOW_UPDATE frames for
              that stream. A sender is not obligated to maintain the available flow control window
              for streams that it is no longer sending on.
            </t>
            <t>
              Flow control can be disabled for all streams on the connection using the
              SETTINGS_FLOW_CONTROL_OPTIONS setting.  An implementation that does not wish to
              perform stream flow control can use this in the initial SETTINGS exchange.
            </t>
            <t>
              Flow control can be disabled for an individual stream or the overall connection by
              sending a WINDOW_UPDATE with the END_FLOW_CONTROL flag set.  The payload of a
              WINDOW_UPDATE frame that has the END_FLOW_CONTROL flag set is ignored.
            </t>
            <t>
              Flow control cannot be enabled again once disabled.  Any attempt to re-enable flow
              control - by sending a WINDOW_UPDATE or by clearing the bits on the
              SETTINGS_FLOW_CONTROL_OPTIONS setting - MUST be rejected with a FLOW_CONTROL_ERROR
              error code.
            </t>
          </section>
        </section>
    </section>

    <section anchor="ErrorCodes" title="Error Codes">
      <t>
        Error codes are 32-bit fields that are used in RST_STREAM and GOAWAY frames to convey
        the reasons for the stream or connection error.
      </t>

      <t>
        Error codes share a common code space.  Some error codes only apply to specific
        conditions and have no defined semantics in certain frame types.
      </t>

      <t>
        The following error codes are defined:
        <list style="hanging">
          <t hangText="NO_ERROR (0):">
            The associated condition is not as a result of an error.  For example, a GOAWAY
            might include this code to indicate graceful shutdown of a connection.
          </t>
          <t hangText="PROTOCOL_ERROR (1):">
            The endpoint detected an unspecific protocol error.  This error is for use when a more
            specific error code is not available.
          </t>
          <t hangText="INTERNAL_ERROR (2):">
            The endpoint encountered an unexpected internal error.
          </t>
          <t hangText="FLOW_CONTROL_ERROR (3):">
            The endpoint detected that its peer violated the flow control protocol.
          </t>
          <t hangText="STREAM_CLOSED (5):">
            The endpoint received a frame after a stream was half closed.
          </t>
          <t hangText="FRAME_TOO_LARGE (6):">
            The endpoint received a frame that was larger than the maximum size that it
            supports.
          </t>
          <t hangText="REFUSED_STREAM (7):">
            The endpoint refuses the stream prior to performing any application processing, see
            <xref target="Reliability"/> for details.
          </t>
          <t hangText="CANCEL (8):">
            Used by the endpoint to indicate that the stream is no longer needed.
          </t>
          <t hangText="COMPRESSION_ERROR (9):">
            The endpoint is unable to maintain the compression context for the connection.
          </t>
        </list>
      </t>
    </section>

    <section anchor="HTTPLayer" title="HTTP Message Exchanges">
      <t>
        HTTP/2.0 is intended to be as compatible as possible with current web-based
        applications. This means that, from the perspective of the server business logic or
        application API, the features of HTTP are unchanged. To achieve this, all of the application
        request and response header semantics are preserved, although the syntax of conveying those
        semantics has changed.  Thus, the rules from HTTP/1.1 (<xref target="HTTP-p1"/>, <xref
        target="HTTP-p2"/>, <xref target="HTTP-p4"/>, <xref target="HTTP-p5"/>, <xref
        target="HTTP-p6"/>, and <xref target="HTTP-p7"/>) apply with the changes in the sections
        below.
      </t>

      <section anchor="HttpSequence" title="HTTP Request/Response Exchange">
        <t>
          A client sends an HTTP request on a new stream, using a previously unused <xref
          target="StreamIdentifiers">stream identifier</xref>.  A server sends an HTTP response on
          the same stream as the request.
        </t>
        <t>
          An HTTP request or response each consist of:
          <list style="symbols">
            <t>
              one contiguous sequence of HEADERS frames;
            </t>
            <t>
              zero or more DATA frames; and
            </t>
            <t>
              optionally, a contiguous sequence of HEADERS frames
            </t>
          </list>
          The last frame in the sequence bears an END_STREAM flag.
        </t>
        <t>
          Other frames, including HEADERS, MAY be interspersed with these frames, but those frames
          do not carry HTTP semantics.
        </t>

        <t>
          Trailing header fields are carried in a header block that also terminates the stream.
          That is, a sequence of HEADERS frames that carries an END_STREAM flag on the last frame.
          Header blocks after the first that do not terminate the stream are not part of an HTTP
          request or response.
        </t>

        <t>
          An HTTP request/response exchange fully consumes a single stream.  A request starts with
          the HEADERS frame that puts the stream into an "open" state and ends with a frame bearing
          END_STREAM, which causes the stream to become "half closed" for the client.  A response
          starts with a HEADERS frame and ends with a frame bearing END_STREAM, which places the
          stream in the "closed" state.
        </t>

        <section title="Examples">
          <t>
            For example, an HTTP GET request that includes request header fields and no body, is
            transmitted as a single contiguous sequence of HEADERS frames containing the
            serialized block of request header fields.  The last HEADERS frame in the sequence has
            both the END_HEADERS and END_STREAM flag set:
          </t>
          
          <figure>
            <artwork><![CDATA[
  GET /resource HTTP/1.1         HEADERS
  Host: example.org        ==>     + END_STREAM
  Accept: image/jpeg               + END_HEADERS
                                     :method = get
                                     :scheme = https
                                     :host = example.org
                                     :path = /resource
                                     accept = image/jpeg
]]></artwork>
          </figure>
          
          <t>
            Similarly, a response that includes only response header fields is transmitted as a sequence of
            HEADERS frames containing the serialized block of response header fields. The last HEADERS
            frame in the sequence has both the END_HEADERS and END_STREAM flag set:
          </t>
          
          <figure>
            <artwork><![CDATA[
  HTTP/1.1 204 No Content       HEADERS 
  Content-Length: 0        ===>   + END_STREAM
                                  + END_HEADERS
                                    :status = 204
                                    content-length: 0
]]></artwork>
          </figure>

          <t>
            An HTTP POST request that includes request header fields and payload data is transmitted
            as one or more HEADERS frames containing the request headers followed by one or more DATA
            frames, with the last HEADERS frame having the END_HEADERS flag set and the final DATA
            frame having the END_STREAM flag set:
          </t>
          
          <figure>
            <artwork><![CDATA[
  POST /resource HTTP/1.1        HEADERS 
  Host: example.org         ==>    - END_STREAM
  Content-Type: image/jpeg         + END_HEADERS
  Content-Length: 123                :method = post
                                     :scheme = https
  {binary data}                      :host = example.org
                                     :path = /resource
                                     content-type = image/jpeg
                                     content-length = 123

                                 DATA 
                                   + END_STREAM
                                     {binary data}
]]></artwork>
          </figure>

          <t>
            A response that includes header fields and payload data is transmitted as one or more
            HEADERS frames followed by one or more DATA frames, with the last DATA frame in the
            sequence having the END_STREAM flag set:
          </t>
          
          <figure>
            <artwork><![CDATA[
  HTTP/1.1 200 OK                HEADERS 
  Content-Type: image/jpeg  ==>    - END_STREAM
  Content-Length: 123              + END_HEADERS
                                     :status = 200
  {binary data}                      content-type = image/jpeg
                                     content-length = 123
                                    
                                 DATA 
                                   + END_STREAM
                                     {binary data}
]]></artwork>
          </figure>

          <t>
            Trailing header fields are sent as a header block after both the request or response
            header block and all the DATA frames have been sent.  The sequence of HEADERS frames that
            bears the trailers includes a terminal frame that has both END_HEADERS and END_STREAM
            flags set.
          </t>
          
          <figure>
            <artwork><![CDATA[
  HTTP/1.1 200 OK               HEADERS 
  Content-Type: image/jpeg ===>   - END_STREAM
  Content-Length: 123             + END_HEADERS 
  TE: trailers                      :status        = 200
  123                               content-type   = image/jpeg
  {binary data}                     content-length = 123
  0                             
  Foo: bar                      DATA 
                                  - END_STREAM 
                                    {binary data}
  
                                HEADERS 
                                  + END_STREAM
                                  + END_HEADERS
                                    foo: bar
]]></artwork>
        </figure>
      </section>        

      <section anchor="HttpRequest" title="Request Header Fields">
        
        <t>
          The definitions of the request header fields are largely unchanged 
          relative to HTTP/1.1, with a few notable exceptions:
          <list style="symbols">
            <t>
              The HTTP/1.1 request-line has been split into two separate
              header fields named :method and :path, whose values 
              specify the HTTP method for the request and the request-target,
              respectively. The HTTP-version component of the request-line
              is removed entirely from the headers.
            </t>
            <t>
              The host and optional port portions of the request URI 
              (see <xref target="RFC3986" x:fmt="," x:sec="3.2"/>), 
              are specified using the new :host header field. <cref>Ed. Note: it 
              needs to be clarified whether or not this replaces the
              existing HTTP/1.1 Host header.</cref>
            </t>
            <t>
              A new :scheme header field has been added to specify the 
              scheme portion of the request-target (e.g. "https")
            </t>
            <t>
              All header field names MUST be lowercased, and the 
              definitions of all header field names defined by 
              HTTP/1.1 are updated to be all lowercase.
            </t>
            <t>
              The Connection, Host, Keep-Alive, Proxy-Connection, and 
              Transfer-Encoding header fields are no longer valid and 
              MUST NOT be sent. <cref>Ed. Note: And "TE" I presume?</cref>
            </t>
          </list>
        </t>

        <t>
          All HTTP Requests MUST include the ":method", ":path", ":host",
          and ":scheme" header fields.
        </t>
        
        <t>
          Header fields whose names begin with ":" (whether defined in this 
          document or future extensions to this document) MUST appear before 
          any other header fields. <cref>Ed. Note: This requirement is currently
          pending review. Consider it "on hold" for the moment.</cref>
        </t>
        
        <t>
          All HTTP Requests that include a body SHOULD include the 
          "content-length" header field. If a server receives a request
          where the sum of the DATA frame payload lengths does not equal
          the value of the "content-length" header field, the server MUST
          return a 400 (Bad Request) error.
        </t>

        <t>
          If a client omits a mandatory header field from the request, the server 
          MUST reply with a HTTP 400 Bad Request reply.
        </t>
        
      </section>

      <section anchor="HttpResponse" title="Response Header Fields">
        
        <t>
          The definitions of the response header fields are largely unchanged 
          relative to HTTP/1.1, with a few notable exceptions:
          <list style="symbols">
            <t>
              The response status line has been reduced to a single ":status" 
              header field whose value specifies only the numeric response
              status code. The status text component of the HTTP/1.1 response
              has been dropped entirely.
            </t>
            <t>
              The response MUST contain exactly one :status header field with
              exactly one response status value. If the client receives
              an HTTP response that does not include the :status field, or 
              provides multiple response status code values, it MUST respond 
              with a <xref target="StreamErrorHandler">stream error</xref> of 
              type PROTOCOL_ERROR.
            </t>
            <t>
              All header field names MUST be lowercased, and the definitions 
              of all header field names defined by HTTP/1.1 are updated to 
              be all lowercase.
            </t>
            <t>
              The Connection, Keep-Alive, Proxy-Connection, and 
              Transfer-Encoding header fields are not valid and MUST NOT be 
              sent.
            </t>
          </list>
        </t>

        <t>
          Header fields whose names begin with ":" (whether defined in this 
          document or future extensions to this document) MUST appear before 
          any other header fields. <cref>Ed. Note: This requirement is currently
          pending review. Consider it "on hold" for the moment.</cref>
        </t>

      </section>

      <section anchor="Compression" title="GZip Content-Encoding">
        
        <t>
          Clients MUST support gzip compression for HTTP response bodies.  
          Regardless of the value of the accept-encoding header field, a 
          server MAY send responses with gzip or deflate encoding.  A compressed
          response MUST still bear an appropriate content-encoding header field.
        </t>
        
        </section>

        <section anchor="Reliability" title="Request Reliability Mechanisms in HTTP/2.0">
          <t>
            In HTTP/1.1, an HTTP client is unable to retry a non-idempotent request when an error
            occurs, because there is no means to determine the nature of the error.  It is possible
            that some server processing occurred prior to the error, which could result in
            undesirable effects if the request were reattempted.
          </t>
          <t>
            HTTP/2.0 provides two mechanisms for providing a guarantee to a client that a request
            has not been processed:
            <list style="symbols">
              <t>
                The GOAWAY frame indicates the highest stream number that might have been processed.
                Requests on streams with higher numbers are therefore guaranteed to be safe to
                retry.
              </t>
              <t>
                The REFUSED_STREAM error code can be included in a RST_STREAM frame to indicate that
                the stream is being closed prior to any processing having occurred.  Any request
                that was sent on the reset stream can be safely retried.
              </t>
            </list>
          </t>
          <t>
            In both cases, clients MAY automatically retry all requests, including those with
            non-idempotent methods.
          </t>
          <t>
            A server MUST NOT indicate that a stream has not been processed unless it can guarantee
            that fact.  If frames that are on a stream are passed to the application layer for any
            stream, then REFUSED_STREAM MUST NOT be used for that stream, and a GOAWAY frame MUST
            include a stream identifier that is greater than or equal to the given stream
            identifier.
          </t>
          <t>
            In addition to these mechanisms, the PING frame provides a way for a client to easily
            test a connection.  Connections that remain idle can become broken as some middleboxes
            (for instance, network address translators, or load balancers) silently discard
            connection bindings.  The PING frame allows a client to safely test whether a connection
            is still active without sending a request.
          </t>
        </section>
      </section>

      <section anchor="PushResources" title="Server Push">
        <t>
          HTTP/2.0 enables a server to pre-emptively send (or "push") multiple associated resources
          to a client in response to a single request.  This feature becomes particularly helpful
          when the server knows the client will need to have those resources available in order to
          fully process the originally requested resource.
        </t>
       
        <t>
          Pushing additional resources is optional, and is negotiated only between individual
          endpoints.  For instance, an intermediary could receive pushed resources from the server
          but is not required to forward those on to the client.  How to make use of the pushed
          resources is up to that intermediary.  Equally, the intermediary might choose to push
          additional resources to the client, without any action taken by the server.
        </t>
        
        <t>
          Server push is semantically equivalent to a server responding to a GET request for that
          resource. The PUSH_PROMISE frame, or frames, sent by the server includes a header block
          that contains the request headers that the server has assumed.  
        </t>
      
        <t>
          Pushed resources are always associated with an explicit request from a client.  The
          PUSH_PROMISE frames sent by the server are sent on the stream created for the original
          request.  The PUSH_PROMSE frame includes a promised stream identifier, chosen from the
          stream identifiers available to the server (see <xref target="StreamIdentifiers"/>).  Any
          header fields that are not specified in the PUSH_PROMISE frames sent by the server are
          inherited from the original request sent by the client.
        </t>

        <t>
          The header fields in PUSH_PROMISE MUST include the <spanx style="verb">:scheme</spanx>,
          <spanx style="verb">:host</spanx> and <spanx style="verb">:path</spanx> header fields that
          identify the resource that is being pushed.  A PUSH_PROMISE always implies an HTTP method
          of GET.  If a client receives a PUSH_PROMISE that does not include these header fields, or
          a value for the <spanx style="verb">:method</spanx> header field, it MUST respond with a
          <xref target="StreamErrorHandler">stream error</xref> of type PROTOCOL_ERROR.
        </t>
        
        <t>
          After sending the PUSH_PROMISE frame, the server can begin delivering the pushed resource
          on a new, server-initiated stream that uses the promised stream identifier.  This stream
          is already implicitly <xref target="StreamStates">"half closed" to the client</xref>.  The
          server uses this stream to transmit an HTTP response, using the same sequence of frames as
          defined in <xref target="HttpSequence"/>.
        </t>

        <t>
          Once a client receives a PUSH_PROMISE frame and chooses to accept the pushed resource, the
          client SHOULD NOT issue any subsequent GET requests for the promised resource until after
          the promised stream has closed.
        </t>

        <t>
          The server SHOULD send <xref target="PUSH_PROMISE">PUSH_PROMISE</xref> frames prior to
          sending any HEADERS or DATA frames that reference the promised resources.  This avoids a
          race where clients issue requests for resources prior to receiving any PUSH_PROMISE
          frames.
        </t>

        <t>
          For example, if the server receives a request for a document containing embedded links to
          multiple image files, and the server chooses to push those additional images to the
          client, sending push promises before the DATA frames that contain the image links ensure
          that the client is able to see the promises before discovering the resources. Likewise, if
          the server pushes resources referenced by the header block (for instance, in Link header
          fields), sending the push promises before sending the header block ensures that clients do
          not request those resources.
        </t>
        
        <t>
          PUSH_PROMISE frames MUST NOT be sent by the client.  PUSH_PROMISE frames can be sent by
          the server on any stream that was opened by the client.  They MUST be sent on a stream
          that is in either the "open" or "half closed (remote)" to the server.  PUSH_PROMISE frames
          can be interspersed within the frames that comprise response, with the exception that they
          cannot be interspersed with HEADERS frames that comprise a single header block.
        </t>

        <t>
          A client can use the SETTINGS_MAX_CONCURRENT_STREAMS setting to limit the number of
          resources that can be concurrently pushed by a server.  Advertising a
          SETTINGS_MAX_CONCURRENT_STREAMS value of zero disables server push by preventing the
          server from creating the necessary streams.
        </t>
        
        <t>
          The request header fields provided in the PUSH_PROMISE frame SHOULD include enough
          information for a client to determine whether a cached representation of the resource is
          already available.  If the client determines, for any reason, that it does not wish to
          receive the pushed resource from the server, or if the server takes too long to begin
          sending the promised resource, the client can send an RST_STREAM frame, using either the
          CANCEL or REFUSED_STREAM codes, and referencing the pushed stream's identifier.
        </t>
       
        <t>
          Clients receiving a pushed response MUST validate that the server is authorized to push
          the resource using the same-origin policy (<xref target="RFC6454" x:fmt="," x:sec="3"/>).
          For example, a HTTP/2.0 connection to <spanx style="verb">example.com</spanx> is generally
          <cref>Ed: weaselly use of "generally", needs better definition</cref> not permitted to
          push a response for <spanx style="verb">www.example.org</spanx>.
        </t>        
      </section>

    </section>

    <section anchor="HttpExtra" title="Additional HTTP Requirements/Considerations">
      <t>
        TODO: SNI, gzip and deflate Content-Encoding, etc..
      </t>
      <section title="Frame Size Limits for HTTP">
        <t>
          Frames used for HTTP messages MUST NOT exceed 2<x:sup>14</x:sup>-1 (16383) octets in
          length, not counting the 8 octet frame header. An endpoint MUST treat the receipt of a
          larger frame as a FRAME_TOO_LARGE error (see <xref target="FrameSize"/>).
        </t>
      </section>
      <section title="Connection Management">
        <t>
          HTTP/2.0 connections are persistent.  For best performance, it is expected clients will
          not close connections until it is determined that no further communication with a server
          is necessary (for example, when a user navigates away from a particular web page), or
          until the server closes the connection.
        </t>
        <t>
          Clients SHOULD NOT open more than one HTTP/2.0 connection to a given origin (<xref
          target="RFC6454"/>) concurrently.  A client can create additional connections as
          replacements, either to replace connections that are near to exhausting the available
          <xref target="StreamIdentifiers">stream identifiers</xref>, or to replace connections that
          have encountered <xref target="ConnectionErrorHandler">errors</xref>.
        </t>
        <t>
          Servers are encouraged to maintain open connections for as long as possible, but are
          permitted to terminate idle connections if necessary.  When either endpoint chooses to
          close the transport-level TCP connection, the terminating endpoint MUST first send a <xref
          target="GOAWAY">GOAWAY</xref> frame so that both endpoints can reliably determine whether
          previously sent frames have been processed and gracefully complete or terminate any
          necessary remaining tasks.
        </t>
      </section>
    </section>

    <section title="Security Considerations">
      <section title="Server Authority and Same-Origin">
        <t>
          This specification uses the same-origin policy (<xref target="RFC6454" x:fmt=","
          x:sec="3"/>) to determine whether an origin server is permitted to provide content.
        </t>
        <t>
          A server that is contacted using TLS is authenticated based on the certificate that it
          offers in the TLS handshake (see <xref target="RFC2818" x:fmt="," x:sec="3"/>).  A server
          is considered authoritative for an "https" resource if it has been successfully
          authenticated for the domain part of the origin of the resource that it is providing.
        </t>
        <t>
          A server is considered authoritative for an "http" resource if the connection is
          established to a resolved IP address for the domain in the origin of the resource.
        </t>
        <t>
          A client MUST NOT use, in any way, resources provided by a server that is not
          authoritative for those resources.
        </t>
      </section>

      <section title="Cross-Protocol Attacks">
        <t>
          When using TLS, we believe that HTTP/2.0 introduces no new cross-protocol attacks.  TLS
          encrypts the contents of all transmission (except the handshake itself), making it
          difficult for attackers to control the data which could be used in a cross-protocol
          attack.  <cref>Issue: This is no longer true</cref>
        </t>
      </section>

      <section title="Cacheability of Pushed Resources">
        <t>
          Pushed resources are responses without an explicit request; the request for a pushed
          resource is synthesized from the request that triggered the push, plus resource
          identification information provided by the server.  Request header fields are necessary
          for HTTP cache control validations (such as the Vary header field) to work.  For this
          reason, caches MUST inherit request header fields from the associated stream for the push.
          This includes the Cookie header field.
        </t>
        <t>
          Caching resources that are pushed is possible, based on the guidance provided by the
          origin server in the Cache-Control header field.  However, this can cause issues if a
          single server hosts more than one tenant.  For example, a server might offer multiple
          users each a small portion of its URI space.
        </t>
        <t>
          Where multiple tenants share space on the same server, that server MUST ensure that
          tenants are not able to push representations of resources that they do not have authority
          over.  Failure to enforce this would allow a tenant to provide a representation that would
          be served out of cache, overriding the actual representation that the authoritative tenant
          provides.
        </t>
        <t>
          Pushed resources for which an origin server is not authoritative are never cached or used.
        </t>
      </section>
    </section>

    <section title="Privacy Considerations">
        <t>
          HTTP/2.0 aims to keep connections open longer between clients and servers in order to
          reduce the latency when a user makes a request.  The maintenance of these connections over
          time could be used to expose private information.  For example, a user using a browser
          hours after the previous user stopped using that browser may be able to learn about what
          the previous user was doing.  This is a problem with HTTP in its current form as well,
          however the short lived connections make it less of a risk.
        </t>
    </section>

    <section title="IANA Considerations">
      <t>
        This document establishes registries for frame types, error codes and settings.  These
        new registries are entered in a new "Hypertext Transfer Protocol (HTTP) 2.0 Parameters" section.
      </t>
      <t>
        This document also registers the <spanx style="verb">HTTP2-Settings</spanx> header field for
        use in HTTP.
      </t>
      <section title="Frame Type Registry">
        <t>
          This document establishes a registry for HTTP/2.0 frame types.  The "HTTP/2.0 Frame Type"
          registry operates under the <xref target="RFC5226">"IETF Review" policy</xref>.
        </t>
        <t>
          Frame types are an 8-bit value.  When reviewing new frame type registrations, special
          attention is advised for any frame type-specific flags that are defined.  Frame flags can
          interact with existing flags and could prevent the creation of globally applicable flags.
        </t>
        <t>
          Initial values for the "HTTP/2.0 Frame Type" registry are shown in <xref
          target="IanaInitialFrameType"/>.
        </t>
        <texttable anchor="IanaInitialFrameType">
          <ttcol>Frame Type</ttcol><ttcol>Name</ttcol><ttcol>Flags</ttcol>
          <c>0</c><c>DATA</c><c>END_STREAM(1)</c>
          <c>1</c><c>HEADERS</c><c>END_STREAM(1), END_HEADERS(4), PRIORITY(8)</c>
          <c>2</c><c>PRIORITY</c><c>-</c>
          <c>3</c><c>RST_STREAM</c><c>-</c>
          <c>4</c><c>SETTINGS</c><c>-</c>
          <c>5</c><c>PUSH_PROMISE</c><c>END_PUSH_PROMISE(1)</c>
          <c>6</c><c>PING</c><c>PONG(1)</c>
          <c>7</c><c>GOAWAY</c><c>-</c>
          <c>9</c><c>WINDOW_UPDATE</c><c>END_FLOW_CONTROL(1)</c>
        </texttable>
      </section>

      <section title="Error Code Registry">
        <t>
          This document establishes a registry for HTTP/2.0 error codes.  The "HTTP/2.0 Error Code"
          registry manages a 32-bit space.  The "HTTP/2.0 Error Code" registry operates under the
          <xref target="RFC5226">"Expert Review" policy</xref>.
        </t>
        <t>
          Registrations for error codes are required to include a description of the error code.  An
          expert reviewer is advised to examine new registrations for possible duplication with
          existing error codes.  Use of existing registrations is to be encouraged, but not
          mandated.
        </t>
        <t>
          New registrations are advised to provide the following information:
          <list style="hanging">
            <t hangText="Error Code:">
              The 32-bit error code value.
            </t>
            <t hangText="Name:">
              A name for the error code.  Specifying an error code name is optional.
            </t>
            <t hangText="Description:">
              A description of the conditions where the error code is applicable.
            </t>
            <t hangText="Specification:">
              An optional reference for a specification that defines the error code.
            </t>
          </list>
        </t>
        <t>
          An initial set of error code registrations can be found in <xref target="ErrorCodes"/>.
        </t>
      </section>

      <section title="Settings Registry">
        <t>
          This document establishes a registry for HTTP/2.0 settings.  The "HTTP/2.0 Settings"
          registry manages a 24-bit space.  The "HTTP/2.0 Settings" registry operates under the
          <xref target="RFC5226">"Expert Review" policy</xref>.
        </t>
        <t>
          Registrations for settings are required to include a description of the setting.  An
          expert reviewer is advised to examine new registrations for possible duplication with
          existing settings.  Use of existing registrations is to be encouraged, but not mandated.
        </t>
        <t>
          New registrations are advised to provide the following information:
          <list style="hanging">
            <t hangText="Setting:">
              The 24-bit setting value.
            </t>
            <t hangText="Name:">
              A name for the setting.  Specifying a name is optional.
            </t>
            <t hangText="Flags:">
              Any setting-specific flags that apply, including their value and semantics.
            </t>
            <t hangText="Description:">
              A description of the setting.  This might include the range of values, any applicable
              units and how to act upon a value when it is provided.
            </t>
            <t hangText="Specification:">
              An optional reference for a specification that defines the setting.
            </t>
          </list>
        </t>
        <t>
          An initial set of settings registrations can be found in <xref target="SettingValues"/>.
        </t>
      </section>

      <section title="HTTP2-Settings Header Field Registration">
        <t>
          This section registers the <spanx style="verb">HTTP2-Settings</spanx> header field in the
          <xref target="BCP90">Permanent Message Header Field Registry</xref>.
          <list style="hanging">
            <t hangText="Header field name:">
              HTTP2-Settings
            </t>
            <t hangText="Applicable protocol:">
              http
            </t>
            <t hangText="Status:">
              standard
            </t>
            <t hangText="Author/Change controller:">
              IETF
            </t>
            <t hangText="Specification document(s):">
              RFC XXXX (this document)
            </t>
            <t hangText="Related information:">
              This header field is only used by an HTTP/2.0 client for Upgrade-based negotiation.
            </t>
          </list>
        </t>
      </section>
    </section>

    <section title="Acknowledgements">
      <t>
        This document includes substantial input from the following individuals:
        <list style="symbols">
          <t>
            Adam Langley, Wan-Teh Chang, Jim Morrison, Mark Nottingham, Alyssa Wilk, Costin
            Manolache, William Chan, Vitaliy Lvin, Joe Chan, Adam Barth, Ryan Hamilton, Gavin
            Peters, Kent Alstad, Kevin Lindsay, Paul Amer, Fan Yang, Jonathan Leighton (SPDY
            contributors).
          </t>
          <t>
            Gabriel Montenegro and Willy Tarreau (Upgrade mechanism)
          </t>
          <t>
            William Chan, Salvatore Loreto, Osama Mazahir, Gabriel Montenegro, Jitu Padhye, Roberto
            Peon, Rob Trace (Flow control)
          </t>
          <t>
            Mark Nottingham, Julian Reschke, James Snell, Jeff Pinner (Substantial editorial
            contributions)
          </t>
        </list>
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <reference anchor="COMPRESSION">
        <front>
          <title>HTTP Header Compression</title>
          <author initials="H." surname="Ruellan" fullname="Herve Ruellan"/>
          <author initials="R." surname="Peon" fullname="Roberto Peon"/>
          <date month="June" year="2013" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-header-compression-00" />
      </reference>

      <reference anchor="RFC0793">
        <front>
          <title abbrev="Transmission Control Protocol">
            Transmission Control Protocol
          </title>
          <author initials="J." surname="Postel" fullname="Jon Postel">
            <organization>University of Southern California (USC)/Information Sciences
            Institute</organization>
          </author>
          <date year="1981" month="September" />
        </front>
        <seriesInfo name="STD" value="7" />
        <seriesInfo name="RFC" value="793" />
      </reference>

      <reference anchor="RFC2119">
        <front>
          <title>
            Key words for use in RFCs to Indicate Requirement Levels
          </title>
          <author initials="S." surname="Bradner" fullname="Scott Bradner">
            <organization>Harvard University</organization>
            <address><email>sob@harvard.edu</email></address>
          </author>
          <date month="March" year="1997"/>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="2119"/>
      </reference>

      <reference anchor="RFC2818">
        <front>
          <title>
            HTTP Over TLS
          </title>
          <author initials="E." surname="Rescorla" fullname="Eric Rescorla">
            <organization/>
          </author>
          <date month="May" year="2000"/>
        </front>
        <seriesInfo name="RFC" value="2818"/>
      </reference>

      <reference anchor="RFC3986">
        <front>
          <title abbrev="URI Generic Syntax">Uniform Resource Identifier (URI): Generic
          Syntax</title>
          <author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee"></author>
          <author initials="R." surname="Fielding" fullname="Roy T. Fielding"></author>
          <author initials="L." surname="Masinter" fullname="Larry Masinter"></author>
          <date year="2005" month="January" />
        </front>
        <seriesInfo name="STD" value="66" />
        <seriesInfo name="RFC" value="3986" />
      </reference>

      <reference anchor="RFC4648">
        <front>
          <title>The Base16, Base32, and Base64 Data Encodings</title>
          <author fullname="S. Josefsson" initials="S." surname="Josefsson"/>
          <date year="2006" month="October"/>
        </front>
        <seriesInfo value="4648" name="RFC"/>
      </reference>
      
      <reference anchor="RFC5226">
        <front>
          <title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
          <author initials="T." surname="Narten" fullname="T. Narten">
          <organization /></author>
          <author initials="H." surname="Alvestrand" fullname="H. Alvestrand">
          <organization /></author>
          <date year="2008" month="May" />
        </front>
        <seriesInfo name="BCP" value="26" />
        <seriesInfo name="RFC" value="5226" />
      </reference>

      <reference anchor="RFC5234">
        <front>
          <title>Augmented BNF for Syntax Specifications: ABNF</title>
          <author initials="D." surname="Crocker" fullname="D. Crocker"/>
          <author initials="P." surname="Overell" fullname="P. Overell"/>
          <date year="2008" month="January" />
        </front>
        <seriesInfo name="STD" value="68" />
        <seriesInfo name="RFC" value="5234" />
      </reference>

      <reference anchor="RFC5246">
        <front>
          <title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
          <author initials="T." surname="Dierks" fullname="Tim Dierks"/>
          <author initials="E." surname="Rescorla" fullname="Eric Rescorla"/>
          <date year="2008" month="August" />
        </front>
        <seriesInfo name="RFC" value="5246" />
      </reference>
      
      <reference anchor="RFC6454">
        <front>
          <title>The Web Origin Concept</title>
          <author initials="A." surname="Barth" fullname="A. Barth"/>
          <date year="2011" month="December" />
        </front>
        <seriesInfo name="RFC" value="6454" />
      </reference>

      <reference anchor="TLSALPN">
        <front>
          <title>Transport Layer Security (TLS) Application Layer Protocol Negotiation Extension</title>
          <author initials="S.F." surname="Friedl" fullname="Stephan Friedl"></author>
          <author initials="A." surname="Popov" fullname="Andrei Popov"></author>
          <author initials="A." surname="Langley" fullname="Adam Langley"></author>
          <author initials="E." surname="Stephan" fullname="Emile Stephan"></author>
          <date month="April" year="2013" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-tls-applayerprotoneg-01" />
      </reference>

      <reference anchor="HTTP-p1">
        <front>
          <title>
          Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
          <author initials="R." surname="Fielding" fullname="Roy Fielding"></author>
          <author initials="J." surname="Reschke" fullname="Julian Reschke"></author>
          <date month="February" year="2013" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p1-messaging-22" />
        <x:source href="refs/draft-ietf-httpbis-p1-messaging-22.xml" basename="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/22/p1-messaging"/>
      </reference>
      <reference anchor="HTTP-p2">
        <front>
          <title>
          Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
          <author initials="R." surname="Fielding" fullname="Roy Fielding"></author>
          <author initials="J." surname="Reschke" fullname="Julian Reschke"></author>
          <date month="February" year="2013" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p2-semantics-22" />
        <x:source href="refs/draft-ietf-httpbis-p2-semantics-22.xml" basename="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/22/p2-semantics"/>
      </reference>
      <reference anchor="HTTP-p4">
        <front>
          <title>Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</title>
          <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
            <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
            <address><email>fielding@gbiv.com</email></address>
          </author>
          <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
            <organization abbrev="greenbytes">greenbytes GmbH</organization>
            <address><email>julian.reschke@greenbytes.de</email></address>
          </author>
          <date month="February" year="2013" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p4-conditional-22" />
      </reference>
      <reference anchor="HTTP-p5">
        <front>
          <title>Hypertext Transfer Protocol (HTTP/1.1): Range Requests</title>
          <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
            <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
            <address><email>fielding@gbiv.com</email></address>
          </author>
          <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
            <organization abbrev="W3C">World Wide Web Consortium</organization>
            <address><email>ylafon@w3.org</email></address>
          </author>
          <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
            <organization abbrev="greenbytes">greenbytes GmbH</organization>
            <address><email>julian.reschke@greenbytes.de</email></address>
          </author>
          <date month="February" year="2013" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p5-range-22"/>
      </reference>
      <reference anchor="HTTP-p6">
        <front>
          <title>Hypertext Transfer Protocol (HTTP/1.1): Caching</title>
          <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
            <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
            <address><email>fielding@gbiv.com</email></address>
          </author>
          <author initials="M." surname="Nottingham" fullname="Mark Nottingham" role="editor">
            <organization>Akamai</organization>
            <address><email>mnot@mnot.net</email></address>
          </author>
          <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
            <organization abbrev="greenbytes">greenbytes GmbH</organization>
            <address><email>julian.reschke@greenbytes.de</email></address>
          </author>
          <date month="February" year="2013" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p6-cache-22"/>
      </reference>
      <reference anchor="HTTP-p7">
        <front>
          <title>Hypertext Transfer Protocol (HTTP/1.1): Authentication</title>
          <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
            <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
            <address><email>fielding@gbiv.com</email></address>
          </author>
          <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
            <organization abbrev="greenbytes">greenbytes GmbH</organization>
            <address><email>julian.reschke@greenbytes.de</email></address>
          </author>
          <date month="February" year="2013" />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p7-auth-22"/>
        <x:source href="refs/draft-ietf-httpbis-p7-auth-22.xml" basename="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/22/p7-auth"/>
      </reference>
    </references>

    <references title="Informative References">
      <reference anchor="RFC1323">
        <front>
          <title>
            TCP Extensions for High Performance
          </title>
          <author initials="V." surname="Jacobson" fullname="Van Jacobson"></author>
          <author initials="B." surname="Braden" fullname="Bob Braden"></author>
          <author initials="D." surname="Borman" fullname="Dave Borman"></author>
          <date year="1992" month="May" />
        </front>
        <seriesInfo name="RFC" value="1323" />
      </reference>
      <reference anchor="TALKING" target="http://w2spconf.com/2011/papers/websocket.pdf">
        <front>
          <title>
            Talking to Yourself for Fun and Profit
          </title>
          <author initials="L-S." surname="Huang"/>
          <author initials="E." surname="Chen"/>
          <author initials="A." surname="Barth"/>
          <author initials="E." surname="Rescorla"/>
          <author initials="C." surname="Jackson"/>
          <date year="2011" />
        </front>
      </reference>

      <reference anchor="BCP90">
        <front>
          <title>Registration Procedures for Message Header Fields</title>
          <author initials="G." surname="Klyne" fullname="G. Klyne">
            <organization>Nine by Nine</organization>
            <address><email>GK-IETF@ninebynine.org</email></address>
          </author>
          <author initials="M." surname="Nottingham" fullname="M. Nottingham">
            <organization>BEA Systems</organization>
            <address><email>mnot@pobox.com</email></address>
          </author>
          <author initials="J." surname="Mogul" fullname="J. Mogul">
            <organization>HP Labs</organization>
            <address><email>JeffMogul@acm.org</email></address>
          </author>
          <date year="2004" month="September" />
        </front>
        <seriesInfo name="BCP" value="90" />
        <seriesInfo name="RFC" value="3864" />
      </reference>
    </references>

    <section title="Change Log (to be removed by RFC Editor before publication)" anchor="change.log">

      <section title="Since draft-ietf-httpbis-http2-03" anchor="changes.since.draft-ietf-httpbis-http2-03">
        <t>
          Committed major restructuring atrocities.
        </t>
        <t>
          Added reference to first header compression draft.
        </t>
        <t>
          Added more formal description of frame lifecycle.
        </t>
        <t>
          Moved END_STREAM (renamed from FINAL) back to HEADERS/DATA.
        </t>
        <t>
          Removed HEADERS+PRIORITY, added optional priority to HEADERS frame.
        </t>
        <t>
          Added PRIORITY frame.
        </t>
      </section>

      <section title="Since draft-ietf-httpbis-http2-02" anchor="changes.since.draft-ietf-httpbis-http2-02">
        <t>
          Added continuations to frames carrying header blocks.
        </t>
        <t>
          Replaced use of "session" with "connection" to avoid confusion with other HTTP stateful
          concepts, like cookies.
        </t>
        <t>
          Removed "message".
        </t>
        <t>
          Switched to TLS ALPN from NPN.
        </t>
        <t>
          Editorial changes.
        </t>
      </section>

      <section title="Since draft-ietf-httpbis-http2-01" anchor="changes.since.draft-ietf-httpbis-http2-01">
        <t>
          Added IANA considerations section for frame types, error codes and settings.
        </t>
        <t>
          Removed data frame compression.
        </t>
        <t>
          Added PUSH_PROMISE.
        </t>
        <t>
          Added globally applicable flags to framing.
        </t>
        <t>
          Removed zlib-based header compression mechanism.
        </t>
        <t>
          Updated references.
        </t>
        <t>
          Clarified stream identifier reuse.
        </t>
        <t>
          Removed CREDENTIALS frame and associated mechanisms.
        </t>
        <t>
          Added advice against naive implementation of flow control.
        </t>
        <t>
          Added session header section.
        </t>
        <t>
          Restructured frame header.  Removed distinction between data and control frames.
        </t>
        <t>
          Altered flow control properties to include session-level limits.
        </t>
        <t>
          Added note on cacheability of pushed resources and multiple tenant servers.
        </t>
        <t>
          Changed protocol label form based on discussions.
        </t>
      </section>

      <section title="Since draft-ietf-httpbis-http2-00" anchor="changes.since.draft-ietf-httpbis-http2-00">
        <t>
          Changed title throughout.
        </t>
        <t>
          Removed section on Incompatibilities with SPDY draft#2.
        </t>
        <t>
          Changed INTERNAL_ERROR on GOAWAY to have a value of 2 <eref
          target="https://groups.google.com/forum/?fromgroups#!topic/spdy-dev/cfUef2gL3iU"/>.
        </t>
        <t>
          Replaced abstract and introduction.
        </t>
        <t>
          Added section on starting HTTP/2.0, including upgrade mechanism.
        </t>
        <t>
          Removed unused references.
        </t>
        <t>
          Added <xref target="fc-principles">flow control principles</xref> based on <eref
          target="http://tools.ietf.org/html/draft-montenegro-httpbis-http2-fc-principles-01"/>.
        </t>
      </section>

      <section title="Since draft-mbelshe-httpbis-spdy-00" anchor="changes.since.draft-mbelshe-httpbis-spdy-00">
        <t>
          Adopted as base for draft-ietf-httpbis-http2.
        </t>
        <t>
          Updated authors/editors list.
        </t>
        <t>
          Added status note.
        </t>
      </section>
    </section>

  </back>
</rfc>

